<!DOCTYPE html>
<html lang="zh" data-theme="light" dir="ltr">
  <head>
    <title>[C++游戏开发基础]:构造函数浅析(8000字) - 八尺妖剑</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="description" content="深入解析C++构造函数的原理、使用方法及最佳实践"/>

    <meta property="og:title" content="八尺妖剑 -&nbsp;[C++游戏开发基础]:构造函数浅析(8000字)" />
    <meta property="og:type" content="website"/><meta property="og:url" content="https:&#x2F;&#x2F;ilikexff.cn&#x2F;c-you-xi-kai-fa-ji-chu-gou-zao-han-shu-qian-xi-8000zi&#x2F;"/><meta property="og:description" content="深入解析C++构造函数的原理、使用方法及最佳实践"/>


    <meta name="twitter:card" content="summary">


    <link rel="stylesheet" href="https://ilikexff.cn/spectre/spectre.css">
    <link rel="stylesheet" href="https://ilikexff.cn/theme.css"><link rel="stylesheet" href="https://ilikexff.cn/custom.css">
    
<link rel="shortcut icon" href="https://ilikexff.cn/./assets/bachiico.ico" type="image/x-icon" />
        
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>

    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script>
        function doRenderMath() {
            renderMathInElement(document.body, {
                delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false},
                {left: "\\(", right: "\\)", display: false},
                {left: "\\begin{equation}", right: "\\end{equation}", display: true},
                {left: "\\begin{align}", right: "\\end{align}", display: true},
                {left: "\\begin{alignat}", right: "\\end{alignat}", display: true},
                {left: "\\begin{gather}", right: "\\end{gather}", display: true},
                {left: "\\begin{CD}", right: "\\end{CD}", display: true},
                {left: "\\[", right: "\\]", display: true}
                ]
            });
        }
    </script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
        onload="doRenderMath()"></script>

      </head>
  <body id="top" class="sticky-footer"><div id="page-wrapper">
<header id="header" class="section">
  <section class="container grid-xl">
    <nav class="navbar">
      <section class="navbar-section">
        
<a class="site-logo" href="https:&#x2F;&#x2F;ilikexff.cn">
  
  <div class="col-mx-auto">
    <figure style="margin: 8px">
      <img class="img-responsive"
           style="max-height: 45px"
           alt="frontmatter image"
           src="https://ilikexff.cn/./assets/logo.png">
    </figure>
  </div>
  
</a>

      </section><!-- ./home button -->

      <section class="navbar-center hide-md"></section>

      <section class="navbar-section">
        <nav class="dropmenu animated hide-md">

<ul><li>
        <a href="https://ilikexff.cn/tags">标签</a>
    </li><li>
        <a href="https://ilikexff.cn/categories">分类</a>
    </li><li>
        <a href="https://ilikexff.cn/about">关于</a>
    </li></ul>


          <!-- 暗色模式滑动切换按钮 -->
          <div class="theme-toggle">
            <label class="theme-switch" for="theme-toggle-checkbox">
              <input type="checkbox" id="theme-toggle-checkbox" class="theme-switch-checkbox">
              <div class="theme-switch-slider">
                <div class="theme-switch-handle">
                  <svg class="sun-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                    <circle cx="12" cy="12" r="5"></circle>
                    <line x1="12" y1="1" x2="12" y2="3"></line>
                    <line x1="12" y1="21" x2="12" y2="23"></line>
                    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                    <line x1="1" y1="12" x2="3" y2="12"></line>
                    <line x1="21" y1="12" x2="23" y2="12"></line>
                    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                  </svg>
                  <svg class="moon-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                  </svg>
                </div>
              </div>
            </label>
          </div>

          <!-- 暗色模式切换脚本 -->
          <script>
            (function() {
              'use strict';

              // 主题管理
              function initTheme() {
                const savedTheme = localStorage.getItem('theme');
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                const theme = savedTheme || (prefersDark ? 'dark' : 'light');
                setTheme(theme, false);
              }

              function setTheme(theme, animate = true) {
                const html = document.documentElement;
                const checkbox = document.getElementById('theme-toggle-checkbox');

                if (animate) {
                  html.style.transition = 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
                  setTimeout(() => { html.style.transition = ''; }, 400);
                }

                if (theme === 'dark') {
                  html.setAttribute('data-theme', 'dark');
                  if (checkbox) checkbox.checked = true;
                } else {
                  html.removeAttribute('data-theme');
                  if (checkbox) checkbox.checked = false;
                }

                localStorage.setItem('theme', theme);
              }

              function toggleTheme() {
                const currentTheme = document.documentElement.getAttribute('data-theme');
                setTheme(currentTheme === 'dark' ? 'light' : 'dark');
              }

              // 初始化
              if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initTheme);
              } else {
                initTheme();
              }

              // 绑定事件
              document.addEventListener('DOMContentLoaded', function() {
                const checkbox = document.getElementById('theme-toggle-checkbox');
                if (checkbox) {
                  checkbox.addEventListener('change', toggleTheme);
                }

                // 键盘快捷键
                document.addEventListener('keydown', function(e) {
                  if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'D') {
                    e.preventDefault();
                    toggleTheme();
                  }
                });
              });
            })();
          </script>
        </nav>
      </section><!-- ./desktop-menu -->
    </nav>
  </section><!-- ./container -->
</header>


<div class="mobile-menu">
  <div class="button_container" id="toggle" onclick="openOverlay()">
    <span class="top"></span>
    <span class="middle"></span>
    <span class="bottom"></span>
  </div>
</div><!--./mobile-menu-->


<section id="start"><section id="body-wrapper" class="section">
          <section class="container grid-xl">
<div id="breadcrumbs" itemtype="http://schema.org/BreadcrumbList" class="hide-sm">
  
    
    <span><a href="https:&#x2F;&#x2F;ilikexff.cn&#x2F;">Home</a></span>
  
    <span><a href="https:&#x2F;&#x2F;ilikexff.cn&#x2F;c-you-xi-kai-fa-ji-chu-gou-zao-han-shu-qian-xi-8000zi&#x2F;">[C++游戏开发基础]:构造函数浅析(8000字)</a></span>
</div>
<div class="columns">
              <div id="item" class="column col-8 col-md-12 extra-spacing">
<div class="card">
  

    <div class="card-header">
      <div class="card-title" style="margin-top: .25rem;"><div>
          <h1 class="post-title">[C++游戏开发基础]:构造函数浅析(8000字)</h1>
          
    <div class="post-meta" style="display: inline-flex">
        <span class="blog-date" style="display: inline-flex;">
          <i class="gg-calendar" style="margin-right: 5px;"></i><time datetime="2025.06.19">
          2025.06.19
          </time></span><span class="post-author" style="margin-left: 5px; display: inline-flex;">
          - 
    八尺妖剑
        </span></div>

        </div></div>
    </div><!--./card-header-->

    <div class="card-body">
      
        <h2 id="gou-zao-han-shu">构造函数<a class="zola-anchor" href="#gou-zao-han-shu" aria-label="Anchor link for: gou-zao-han-shu">🔗</a></h2>
<p>构造函数是一种特殊的成员函数,在创建非聚合类类型对象后会自动被调用。当定义一个非聚合类类型对象时,编译器会检查是否能找到一个可以访问的构造函数,该构造函数与调用者提供的初始化值(如果有的情况下)相匹配。 </p>
<ul>
<li>如果找到一个可访问的匹配构造函数，将为该对象分配内存，然后调用构造函数。</li>
<li>如果找不到合适的构造函数，则会生成编译错误。</li>
</ul>
<blockquote>
<ul>
<li>
<p>许多新手程序员可能不太清楚构造函数是否创建对象。实际上,它们不会创建对象,编译器在调用构造函数之前为对象分配内存,然后在未初始化的对象上调用构造函数。</p>
</li>
<li>
<p>然后,如果一组初始化参数找不到匹配的构造函数,则会出现编译错误。因此,虽然构造函数不创建对象,但是缺少匹配的构造函数将阻止对象的创建。</p>
</li>
</ul>
</blockquote>
<p>除了确定对象如何创建之外,构造函数通常还执行下面两个功能:</p>
<ul>
<li>它们通常通过成员初始化列表初始化任何成员。</li>
<li>可能执行其他操作,比如检查初始化值,打开文件或数据库等。 这些都是构造函数可以实现的。</li>
</ul>
<p>构造函数执行完毕之后,我们说该对象已经被“构造”完成,并且对象现在处于一致可用的状态。</p>
<hr />
<h2 id="gou-zao-han-shu-de-ming-ming">构造函数的命名<a class="zola-anchor" href="#gou-zao-han-shu-de-ming-ming" aria-label="Anchor link for: gou-zao-han-shu-de-ming-ming">🔗</a></h2>
<p>与普通函数不同,构造函数必须遵循严格的命名规则:</p>
<ul>
<li>构造函数必须与类同名,这里的同名是严格意义上的,比如大小写一致。这个名称不包括模版参数。</li>
<li>构造函数没有返回类型,甚至没有<code>void</code>。</li>
</ul>
<p>由于构造函数通常是类接口的一部分,因此它们通常是公共的。</p>
<p>下面演示为一个程序添加一个基本的构造函数:</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include</span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Foo
</span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_x </span><span style="color:#657b83;">{}</span><span>;
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_y </span><span style="color:#657b83;">{}</span><span>;
</span><span>
</span><span>    </span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>        </span><span style="color:#b58900;">Foo</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int x</span><span>, </span><span style="color:#268bd2;">int y</span><span style="color:#657b83;">)
</span><span>        </span><span style="color:#657b83;">{
</span><span>            std::cout </span><span style="color:#657b83;">&lt;&lt;</span><span>&quot;</span><span style="color:#2aa198;">Foo(</span><span>&quot; </span><span style="color:#657b83;">&lt;&lt;</span><span> x </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">,</span><span>&quot; </span><span style="color:#657b83;">&lt;&lt;</span><span>y </span><span style="color:#657b83;">&lt;&lt;</span><span>&quot;</span><span style="color:#2aa198;">)constructed</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>        </span><span style="color:#657b83;">}
</span><span>
</span><span>        </span><span style="color:#268bd2;">void </span><span style="color:#b58900;">print</span><span style="color:#657b83;">() </span><span style="color:#859900;">const
</span><span>        </span><span style="color:#657b83;">{
</span><span>            std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">x: </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_x </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">, y: </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_y </span><span style="color:#657b83;">&lt;&lt; </span><span>&#39;</span><span style="color:#dc322f;">\n</span><span>&#39;;
</span><span>        </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    Foo </span><span style="color:#b58900;">foo </span><span style="color:#657b83;">{</span><span style="color:#6c71c4;">6</span><span>,</span><span style="color:#6c71c4;">7</span><span style="color:#657b83;">}</span><span>;
</span><span>    foo.</span><span style="color:#b58900;">print</span><span style="color:#657b83;">()</span><span>;
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span><span>
</span></code></pre>
<p><img src="https://images.waer.ltd/notes/202503201750356.png" alt="image-20250320175001076" /></p>
<p>当编译器看到定义<code>Foo foo{6,7}</code>时,它会寻找一个匹配的<code>Foo</code>构造函数,该构造函数可以接受两个<code>int</code>参数,在运行时，当 <code>foo</code> 被实例化时，会为 <code>foo</code> 分配内存，并调用 <code>Foo(int, int)</code> 构造函数，其中参数 <code>x</code> 被初始化为 <code>6</code> ，参数 <code>y</code> 被初始化为 <code>7</code> 。然后构造函数的主体执行并打印 <code>Foo(6, 7) constructed</code> 。</p>
<p>当我们调用 <code>print()</code> 成员函数时，你会发现成员 <code>m_x</code> 和 <code>m_y</code> 的值为 0。这是因为虽然我们的 <code>Foo(int, int)</code> 构造函数被调用了，但它实际上并没有初始化成员。别急,后文会逐步体现。</p>
<hr />
<h2 id="gou-zao-han-shu-bu-neng-shi-const">构造函数不能是const<a class="zola-anchor" href="#gou-zao-han-shu-bu-neng-shi-const" aria-label="Anchor link for: gou-zao-han-shu-bu-neng-shi-const">🔗</a></h2>
<p>构造函数需要初始化正在构造的对象,因此,构造函数不能是<code>const</code>。</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Something
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#268bd2;">int m_x</span><span style="color:#657b83;">{}</span><span>; </span><span style="color:#586e75;">// 私有成员变量 m_x，默认初始化为 0
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#b58900;">Something</span><span style="color:#657b83;">() </span><span style="color:#586e75;">// 构造函数必须是非常量（non-const）的
</span><span>    </span><span style="color:#657b83;">{
</span><span>        </span><span style="color:#268bd2;">m_x </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">5</span><span>; </span><span style="color:#586e75;">// 在非常量构造函数中可以修改成员变量
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#268bd2;">int </span><span style="color:#b58900;">getX</span><span style="color:#657b83;">() </span><span style="color:#859900;">const </span><span style="color:#657b83;">{ </span><span style="color:#859900;">return </span><span style="color:#268bd2;">m_x</span><span>; </span><span style="color:#657b83;">} </span><span style="color:#586e75;">// 常成员函数，不能修改成员变量
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#859900;">const</span><span> Something </span><span style="color:#b58900;">s</span><span style="color:#657b83;">{}</span><span>; </span><span style="color:#586e75;">// 定义常量对象 s，并隐式调用（非常量的）构造函数
</span><span>
</span><span>    std::cout </span><span style="color:#657b83;">&lt;&lt;</span><span> s.</span><span style="color:#b58900;">getX</span><span style="color:#657b83;">()</span><span>; </span><span style="color:#586e75;">// 输出 5
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p><code>const</code> 对象仍然可以调用非 <code>const</code> 构造函数，因为 <code>const</code> 限制只影响对象创建后，<strong>不影响初始化</strong>。</p>
<hr />
<h2 id="tong-guo-cheng-yuan-chu-shi-hua-lie-biao-jin-xing-cheng-yuan-chu-shi-hua">通过成员初始化列表进行成员初始化<a class="zola-anchor" href="#tong-guo-cheng-yuan-chu-shi-hua-lie-biao-jin-xing-cheng-yuan-chu-shi-hua" aria-label="Anchor link for: tong-guo-cheng-yuan-chu-shi-hua-lie-biao-jin-xing-cheng-yuan-chu-shi-hua">🔗</a></h2>
<p>为了让构造函数初始化成员，我们使用成员初始化列表（通常称为“成员初始化列表”）来完成。不要将这个与用于用值列表初始化聚合体的同名“初始化列表”混淆。</p>
<p>成员初始化列表最好通过示例来学习。在下面的例子中，我们的 <code>Foo(int, int)</code> 构造函数已经被更新为使用成员初始化列表来初始化 <code>m_x</code> 和 <code>m_y</code> 。</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Foo
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_x </span><span style="color:#657b83;">{}</span><span>;
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_y </span><span style="color:#657b83;">{}</span><span>;
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#b58900;">Foo</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int x</span><span>, </span><span style="color:#268bd2;">int y</span><span style="color:#657b83;">)</span><span>: </span><span style="color:#268bd2;">m_x </span><span style="color:#657b83;">{</span><span> x </span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_y </span><span style="color:#657b83;">{</span><span> y </span><span style="color:#657b83;">} </span><span style="color:#586e75;">// here&#39;s our member initialization list
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Foo(</span><span>&quot; </span><span style="color:#657b83;">&lt;&lt;</span><span> x </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">, </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt;</span><span> y </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">) constructed</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#268bd2;">void </span><span style="color:#b58900;">print</span><span style="color:#657b83;">() </span><span style="color:#859900;">const
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Foo(</span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_x </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">, </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_y </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">)</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    Foo </span><span style="color:#b58900;">foo</span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">6</span><span>, </span><span style="color:#6c71c4;">7 </span><span style="color:#657b83;">}</span><span>;
</span><span>    foo.</span><span style="color:#b58900;">print</span><span style="color:#657b83;">()</span><span>;
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>成员初始化列表定义在构造函数参数之后。它以冒号（:）开始，然后列出每个要初始化的成员及其对应的初始化值，用逗号分隔。</p>
<p>这里必须使用<strong>直接初始化形式</strong>（最好使用花括号，但圆括号也可以）——使用拷贝初始化（带有等号）在这里不起作用。另外请注意，<strong>成员初始化列表不以分号结尾</strong>。</p>
<p>当 <code>foo</code> 被实例化时，初始化列表中的成员将使用指定的初始化值进行初始化。在这种情况下，成员初始化列表将 <code>m_x</code> 初始化为 <code>x</code> 的值（ <code>x</code> 的值是 <code>6</code> ），并将 <code>m_y</code> 初始化为 <code>y</code> 的值（ <code>y</code> 的值是 <code>7</code> ）。然后构造函数的主体运行。</p>
<p>当调用 <code>print()</code> 成员函数时，你可以看到 <code>m_x</code> 仍然具有值 <code>6</code> ， <code>m_y</code> 仍然具有值 <code>7</code></p>
<hr />
<h2 id="cheng-yuan-chu-shi-hua-lie-biao-ge-shi-hua">成员初始化列表格式化<a class="zola-anchor" href="#cheng-yuan-chu-shi-hua-lie-biao-ge-shi-hua" aria-label="Anchor link for: cheng-yuan-chu-shi-hua-lie-biao-ge-shi-hua">🔗</a></h2>
<p>C++提供类很多自由来格式化你的成员初始化列表,因为它们并不关心你在冒号、逗号或空格位置上做了什么。所以一下样式都是有效的。</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b58900;">Foo</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> x, </span><span style="color:#268bd2;">int</span><span> y</span><span style="color:#657b83;">) </span><span style="color:#859900;">: </span><span style="color:#268bd2;">m_x </span><span style="color:#657b83;">{</span><span> x </span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_y </span><span style="color:#657b83;">{</span><span> y </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">{
</span><span style="color:#657b83;">}
</span></code></pre>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b58900;">Foo</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> x, </span><span style="color:#268bd2;">int</span><span> y</span><span style="color:#657b83;">) </span><span style="color:#859900;">:
</span><span>    </span><span style="color:#268bd2;">m_x </span><span style="color:#657b83;">{</span><span> x </span><span style="color:#657b83;">}</span><span>,
</span><span>    </span><span style="color:#268bd2;">m_y </span><span style="color:#657b83;">{</span><span> y </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">{
</span><span style="color:#657b83;">}
</span></code></pre>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b58900;">Foo</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> x, </span><span style="color:#268bd2;">int</span><span> y</span><span style="color:#657b83;">)
</span><span>    </span><span style="color:#859900;">: </span><span style="color:#268bd2;">m_x </span><span style="color:#657b83;">{</span><span> x </span><span style="color:#657b83;">}
</span><span>    , </span><span style="color:#268bd2;">m_y </span><span style="color:#657b83;">{</span><span> y </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">{
</span><span style="color:#657b83;">}
</span></code></pre>
<p>推荐使用上面第三种格式:</p>
<ul>
<li>构造函数名称后面跟一个冒号,这样可以干净的将成员初始化列表与函数原型分开。</li>
<li>缩进的成员初始化列表以便于更容易看到函数名称。 </li>
</ul>
<p>如果成员初始化列表简短的情况下, 所有的初始化项可以放在一行上:</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b58900;">Foo</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> x, </span><span style="color:#268bd2;">int</span><span> y</span><span style="color:#657b83;">)
</span><span>    </span><span style="color:#859900;">: </span><span style="color:#268bd2;">m_x </span><span style="color:#657b83;">{</span><span> x </span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_y </span><span style="color:#657b83;">{</span><span> y </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">{
</span><span style="color:#657b83;">}
</span></code></pre>
<p>否则（或者如果你更喜欢），每个成员和初始化器可以分别放在单独的行上（以逗号开头以保持对齐）：</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b58900;">Foo</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> x, </span><span style="color:#268bd2;">int</span><span> y</span><span style="color:#657b83;">)
</span><span>    </span><span style="color:#859900;">: </span><span style="color:#268bd2;">m_x </span><span style="color:#657b83;">{</span><span> x </span><span style="color:#657b83;">}
</span><span>    , </span><span style="color:#268bd2;">m_y </span><span style="color:#657b83;">{</span><span> y </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">{
</span><span style="color:#657b83;">}
</span></code></pre>
<hr />
<h2 id="cheng-yuan-chu-shi-hua-shun-xu">成员初始化顺序<a class="zola-anchor" href="#cheng-yuan-chu-shi-hua-shun-xu" aria-label="Anchor link for: cheng-yuan-chu-shi-hua-shun-xu">🔗</a></h2>
<p>因为C++标准规定,成员初始化列表中的成员总是按照类中定义的顺序进行初始化。 在上面的例子中,由于 <code>m_x</code> 在类定义中定义在 <code>m_y</code> 之前， <code>m_x</code> 将首先被初始化（即使它在成员初始化列表中没有被列出在最前面）。</p>
<p><strong>最佳实践</strong></p>
<blockquote>
<p>成员在成员初始化列表中应该按照它们在类中定义的顺序列出。一些编译器会在成员初始化顺序不正确时发出警告。</p>
</blockquote>
<p>另外，最好避免使用其他成员的值来初始化成员（如果可能的话）。这样，即使你在初始化顺序上犯了错误，也不会有太大影响，因为初始化值之间没有依赖关系。</p>
<hr />
<h2 id="cheng-yuan-chu-shi-hua-lie-biao-he-mo-ren-cheng-yuan-chu-shi-hua-qi">成员初始化列表和默认成员初始化器<a class="zola-anchor" href="#cheng-yuan-chu-shi-hua-lie-biao-he-mo-ren-cheng-yuan-chu-shi-hua-qi" aria-label="Anchor link for: cheng-yuan-chu-shi-hua-lie-biao-he-mo-ren-cheng-yuan-chu-shi-hua-qi">🔗</a></h2>
<p>成员可以一下几种不同的方式初始化:</p>
<ul>
<li>如果成员在成员初始化列表中列出,将优先使用该初始化值。</li>
<li>否则,如果成员具有默认的成员初始化器,则使用该默认值进行初始化。</li>
<li>否则该成员将使用默认初始化。</li>
</ul>
<p>这意味着如果成员既有默认成员初始化器，又在构造函数的成员初始化列表中列出，那么成员初始化列表中的值将优先。</p>
<p>看代码:</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Foo
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_x </span><span style="color:#657b83;">{}</span><span>;    </span><span style="color:#586e75;">// 默认成员初始化（将被构造函数初始化列表覆盖）
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_y </span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">2 </span><span style="color:#657b83;">}</span><span>; </span><span style="color:#586e75;">// 默认成员初始化（如果未在构造函数中显式初始化，将使用此值）
</span><span>    </span><span style="color:#268bd2;">int m_z</span><span>;      </span><span style="color:#586e75;">// 没有初始化，值不确定（未定义行为）
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#b58900;">Foo</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int x</span><span style="color:#657b83;">)
</span><span>        : </span><span style="color:#268bd2;">m_x </span><span style="color:#657b83;">{</span><span> x </span><span style="color:#657b83;">} </span><span style="color:#586e75;">// 成员初始化列表，m_x 被初始化为 x（覆盖默认初始化）
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Foo constructed</span><span style="color:#dc322f;">\n</span><span>&quot;; </span><span style="color:#586e75;">// 输出构造函数被调用的提示
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#268bd2;">void </span><span style="color:#b58900;">print</span><span style="color:#657b83;">() </span><span style="color:#859900;">const
</span><span>    </span><span style="color:#657b83;">{
</span><span>        </span><span style="color:#586e75;">// 输出对象的成员变量值
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Foo(</span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_x </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">, </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_y </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">, </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_z </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">)</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    Foo </span><span style="color:#b58900;">foo </span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">6 </span><span style="color:#657b83;">}</span><span>; </span><span style="color:#586e75;">// 创建 Foo 对象，m_x 被初始化为 6，m_y 仍然是 2，m_z 未初始化（值不确定）
</span><span>    foo.</span><span style="color:#b58900;">print</span><span style="color:#657b83;">()</span><span>;   </span><span style="color:#586e75;">// 调用 print() 打印成员变量的值
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<hr />
<h2 id="gou-zao-han-shu-de-han-shu-ti">构造函数的函数体<a class="zola-anchor" href="#gou-zao-han-shu-de-han-shu-ti" aria-label="Anchor link for: gou-zao-han-shu-de-han-shu-ti">🔗</a></h2>
<p>构造函数的函数体通常留空。这是因为我们主要使用构造函数进行初始化,这是通过成员初始化列表完成的。如果仅需要进行这些初始化操作,那么构造函数函数体中就不需要任何语句。</p>
<p>然而,因为构造函数体内语句的执行是在成员初始化列表之后,所以我们可以在其中添加语句来完成任何其他初始化任务。</p>
<p>在上述示例中，我们向控制台打印一些内容以显示构造函数已执行，但我们也可以执行其他操作，例如打开文件或数据库、分配内存等…</p>
<blockquote>
<p>优先在构造函数成员初始化列表中初始化成员，而不是在构造函数体中赋值。</p>
</blockquote>
<h2 id="jian-ce-he-chu-li-gou-zao-han-shu-zhong-de-wu-xiao-can-shu">检测和处理构造函数中的无效参数<a class="zola-anchor" href="#jian-ce-he-chu-li-gou-zao-han-shu-zhong-de-wu-xiao-can-shu" aria-label="Anchor link for: jian-ce-he-chu-li-gou-zao-han-shu-zhong-de-wu-xiao-can-shu">🔗</a></h2>
<p>考虑下面的程序:</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#268bd2;">class </span><span style="color:#b58900;">Fraction
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_numerator </span><span style="color:#657b83;">{}</span><span>;
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_denominator </span><span style="color:#657b83;">{}</span><span>;
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#b58900;">Fraction</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int numerator</span><span>, </span><span style="color:#268bd2;">int denominator</span><span style="color:#657b83;">)</span><span>:
</span><span>        </span><span style="color:#268bd2;">m_numerator </span><span style="color:#657b83;">{</span><span> numerator </span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_denominator </span><span style="color:#657b83;">{</span><span> denominator </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span></code></pre>
<p>因为分数是由分子除以分母得到的，所以分数的分母不能为零（否则会得到除以零，这是数学上未定义的）。换句话说，这个类中 <code>m_denominator</code> 不能为 <code>0</code> 。</p>
<p>当用户尝试创建一个分母为零的分数（例如 <code>Fraction f { 1, 0 };</code> ）时，我们应该怎么做？</p>
<p>在成员初始化列表中，我们检测和处理错误的工具相当有限。我们可以使用条件运算符来检测错误，但接下来呢？</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#268bd2;">class </span><span style="color:#b58900;">Fraction
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_numerator </span><span style="color:#657b83;">{}</span><span>;
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_denominator </span><span style="color:#657b83;">{}</span><span>;
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#b58900;">Fraction</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int numerator</span><span>, </span><span style="color:#268bd2;">int denominator</span><span style="color:#657b83;">)</span><span>:
</span><span>        </span><span style="color:#268bd2;">m_numerator </span><span style="color:#657b83;">{</span><span> numerator </span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_denominator </span><span style="color:#657b83;">{</span><span> denominator </span><span style="color:#657b83;">!= </span><span style="color:#6c71c4;">0.0 </span><span style="color:#859900;">?</span><span> denominator </span><span style="color:#859900;">: ??? </span><span style="color:#657b83;">} </span><span style="color:#586e75;">// 然后呢,接下来怎么做?
</span><span>    </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span></code></pre>
<p>你可能会想到,我们可以将分母改为一个有效的值,但是这样用户得到的结果就不会包含它们要求的值了,而且我们也没有办法通知他们做了非法操作。 </p>
<p>因此,我们通常不会在成员初始化列表中尝试进行任何类型的验证,在大多数情况下,我们没有足够的信息支持我们完全在狗仔函数内部解决这些问题,因此在狗仔构造函数内部修复这些问题显然不是什么好主意。</p>
<blockquote>
<p>对于非成员函数和非特殊成员函数，我们可以将错误传递给调用者处理。但是构造函数没有返回值，所以我们没有好的方法来做这一点。在某些情况下，我们可以添加一个 <code>isValid()</code> 成员函数（或重载转换为 <code>bool</code> ），返回对象当前是否处于有效状态。例如，一个 <code>isValid()</code> 函数对于 <code>Fraction</code> 会返回 <code>true</code> 当 <code>m_denominator != 0.0</code> 。但这意味着调用者必须记住每次创建新的 Fraction 对象时都调用该函数。并且使语义上无效的对象可访问可能会导致错误。</p>
</blockquote>
<ul>
<li>在某些类型的程序中，我们可以直接停止整个程序，并让用户重新运行程序并输入正确的数据……但在大多数情况下，这根本不可接受。</li>
<li>异常会完全终止构造的过程,这意味着用户永远不会获得一个语义上无效的对象。因此,大多数情况下,抛出异常是最好的做法。</li>
</ul>
<p>当然,如果无法或者不想使用异常抛出的方式,我们还有一个合理的选择:</p>
<p>那就是不让用户直接创建类,可以提供一个函数,该函数要么返回一个实例,要么返回一个表示失败的值。</p>
<p>在下面的例子中，我们的 <code>createFraction()</code> 函数返回一个 <code>std::optional&lt;Fraction&gt;</code> ，该 <code>std::optional&lt;Fraction&gt;</code> 可能包含一个有效的 <code>Fraction</code> 。如果包含，则我们可以使用该 <code>Fraction</code>。如果不包含，则调用者可以检测到并处理这种情况。</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">optional</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Fraction
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_numerator </span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">0 </span><span style="color:#657b83;">}</span><span>;   </span><span style="color:#586e75;">// 分子，默认为 0
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_denominator </span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">1 </span><span style="color:#657b83;">}</span><span>; </span><span style="color:#586e75;">// 分母，默认为 1
</span><span>
</span><span>    </span><span style="color:#586e75;">// 私有构造函数，外部无法直接调用
</span><span>    </span><span style="color:#b58900;">Fraction</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int numerator</span><span>, </span><span style="color:#268bd2;">int denominator</span><span style="color:#657b83;">)</span><span>:
</span><span>        </span><span style="color:#268bd2;">m_numerator </span><span style="color:#657b83;">{</span><span> numerator </span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_denominator </span><span style="color:#657b83;">{</span><span> denominator </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#586e75;">// 允许该友元函数访问私有成员
</span><span>    </span><span style="color:#859900;">friend</span><span> std::optional</span><span style="color:#657b83;">&lt;</span><span>Fraction</span><span style="color:#657b83;">&gt;</span><span> createFraction</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> numerator, </span><span style="color:#268bd2;">int</span><span> denominator</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#586e75;">// 负责创建 Fraction 实例的函数，返回 std::optional&lt;Fraction&gt;
</span><span>std::optional</span><span style="color:#657b83;">&lt;</span><span>Fraction</span><span style="color:#657b83;">&gt; </span><span style="color:#b58900;">createFraction</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int numerator</span><span>, </span><span style="color:#268bd2;">int denominator</span><span style="color:#657b83;">)
</span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>denominator </span><span style="color:#657b83;">== </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// 分母不能为 0，否则返回空 optional
</span><span>        </span><span style="color:#859900;">return </span><span style="color:#657b83;">{}</span><span>;
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#b58900;">Fraction</span><span style="color:#657b83;">{</span><span>numerator, denominator</span><span style="color:#657b83;">}</span><span>; </span><span style="color:#586e75;">// 否则返回合法的 Fraction
</span><span style="color:#657b83;">}
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#268bd2;">auto </span><span style="color:#b58900;">f1 </span><span style="color:#657b83;">{ </span><span style="color:#b58900;">createFraction</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">) }</span><span>; </span><span style="color:#586e75;">// 创建合法分数 0/1
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>f1</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// 检查是否成功创建
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Fraction created</span><span style="color:#dc322f;">\n</span><span>&quot;; </span><span style="color:#586e75;">// 输出 &quot;Fraction created&quot;
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#268bd2;">auto </span><span style="color:#b58900;">f2 </span><span style="color:#657b83;">{ </span><span style="color:#b58900;">createFraction</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">) }</span><span>; </span><span style="color:#586e75;">// 试图创建非法分数 0/0
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(!</span><span>f2</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// 检查创建是否失败
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Bad fraction</span><span style="color:#dc322f;">\n</span><span>&quot;; </span><span style="color:#586e75;">// 输出 &quot;Bad fraction&quot;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}
</span></code></pre>
<hr />
<h2 id="mo-ren-gou-zao-han-shu-yi-ji-can-shu">默认构造函数以及参数<a class="zola-anchor" href="#mo-ren-gou-zao-han-shu-yi-ji-can-shu" aria-label="Anchor link for: mo-ren-gou-zao-han-shu-yi-ji-can-shu">🔗</a></h2>
<p>默认构造函数是一个不需要参数的构造函数,通常,这是一个没有参数定义的构造函数。
看个示例:</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Foo
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#b58900;">Foo</span><span style="color:#657b83;">() </span><span style="color:#586e75;">// 默认构造函数
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Foo default constructed</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    Foo </span><span style="color:#b58900;">foo</span><span style="color:#657b83;">{}</span><span>; </span><span style="color:#586e75;">// 没有初始化值，调用foo的默认构造函数
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>如果一个类类型<strong>有默认构造函数</strong>，那么<strong>值初始化（value initialization）</strong> 和 <strong>默认初始化（default initialization）</strong> 都会调用默认构造函数。因此，对于这样的类（比如示例中的 Foo 类），以下两种写法本质上是等价的：</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>Foo </span><span style="color:#b58900;">foo</span><span style="color:#657b83;">{}</span><span>;  </span><span style="color:#586e75;">// 值初始化，调用 Foo() 默认构造函数
</span><span>Foo foo2;   </span><span style="color:#586e75;">// 默认初始化，调用 Foo() 默认构造函数
</span></code></pre>
<blockquote>
<p>对于所有类类型，优先使用值初始化而不是默认初始化。</p>
</blockquote>
<hr />
<h2 id="dai-you-mo-ren-can-shu-de-gou-zao-han-shu">带有默认参数的构造函数<a class="zola-anchor" href="#dai-you-mo-ren-can-shu-de-gou-zao-han-shu" aria-label="Anchor link for: dai-you-mo-ren-can-shu-de-gou-zao-han-shu">🔗</a></h2>
<p>与所有函数一样,构造函数的最右侧参数可以有默认参数。</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include</span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Foo
</span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_x </span><span style="color:#657b83;">{}</span><span>;
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_y </span><span style="color:#657b83;">{}</span><span>;
</span><span>
</span><span>    </span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#b58900;">Foo</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int x</span><span style="color:#657b83;">=</span><span style="color:#6c71c4;">0</span><span>,</span><span style="color:#268bd2;">int y</span><span style="color:#657b83;">=</span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// 带有默认参数的构造函数
</span><span>    : </span><span style="color:#268bd2;">m_x </span><span style="color:#657b83;">{</span><span>x</span><span style="color:#657b83;">}
</span><span>    , </span><span style="color:#268bd2;">m_y </span><span style="color:#657b83;">{</span><span>y</span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt;</span><span>&quot;</span><span style="color:#2aa198;">Foo(</span><span>&quot;</span><span style="color:#657b83;">&lt;&lt;</span><span style="color:#268bd2;">m_x</span><span style="color:#657b83;">&lt;&lt;</span><span>&quot;</span><span style="color:#2aa198;">,</span><span>&quot;</span><span style="color:#657b83;">&lt;&lt;</span><span style="color:#268bd2;">m_y</span><span style="color:#657b83;">&lt;&lt;</span><span>&quot;</span><span style="color:#2aa198;">) constructed</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    Foo </span><span style="color:#b58900;">foo1</span><span style="color:#657b83;">{}</span><span>; </span><span style="color:#586e75;">// 调用Foo(int,int)构造函数并使用默认参数初始化
</span><span>    Foo </span><span style="color:#b58900;">foo2</span><span style="color:#657b83;">{</span><span style="color:#6c71c4;">6</span><span>,</span><span style="color:#6c71c4;">7</span><span style="color:#657b83;">}</span><span>; </span><span style="color:#586e75;">// 调用Foo(int,int) 构造函数
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span><span>
</span></code></pre>
<p><img src="https://images.waer.ltd/notes/202503211803678.png" alt="image-20250321180326324" /></p>
<p>如果一个构造函数<strong>所有参数</strong>都有默认值，那么它就可以像默认构造函数一样工作，<strong>可以在不传递任何参数的情况下调用</strong>，因此它就是一个<strong>默认构造函数</strong>。</p>
<hr />
<h2 id="gou-zao-han-shu-zhong-zai">构造函数重载<a class="zola-anchor" href="#gou-zao-han-shu-zhong-zai" aria-label="Anchor link for: gou-zao-han-shu-zhong-zai">🔗</a></h2>
<p>由于构造函数也是函数,因此也可以被重载。也就是说,我们可以有多个构造函数,以便以不同的方式创建对象。</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include</span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span>
</span><span>    </span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Foo
</span><span>    </span><span style="color:#657b83;">{
</span><span>        </span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>        </span><span style="color:#268bd2;">int</span><span> m_x </span><span style="color:#657b83;">{}</span><span>;
</span><span>        </span><span style="color:#268bd2;">int</span><span> m_y </span><span style="color:#657b83;">{}</span><span>;
</span><span>
</span><span>        </span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>        </span><span style="color:#b58900;">Foo</span><span style="color:#657b83;">() </span><span style="color:#586e75;">// 默认构造函数
</span><span>        </span><span style="color:#657b83;">{
</span><span>            std::cout </span><span style="color:#657b83;">&lt;&lt;</span><span>&quot;</span><span style="color:#2aa198;">Foo() constructed</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>        </span><span style="color:#657b83;">}
</span><span>        </span><span style="color:#b58900;">Foo</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int x</span><span>,</span><span style="color:#268bd2;">int y</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// 非默认构造函数
</span><span>        : </span><span style="color:#268bd2;">m_x </span><span style="color:#657b83;">{</span><span>x</span><span style="color:#657b83;">}
</span><span>        , </span><span style="color:#268bd2;">m_y </span><span style="color:#657b83;">{</span><span>y</span><span style="color:#657b83;">}
</span><span>        </span><span style="color:#657b83;">{
</span><span>            std::cout </span><span style="color:#657b83;">&lt;&lt;</span><span>&quot;</span><span style="color:#2aa198;">Foo(</span><span>&quot;</span><span style="color:#657b83;">&lt;&lt;</span><span style="color:#268bd2;">m_x</span><span style="color:#657b83;">&lt;&lt;</span><span>&quot;</span><span style="color:#2aa198;">,</span><span>&quot;</span><span style="color:#657b83;">&lt;&lt;</span><span style="color:#268bd2;">m_y</span><span style="color:#657b83;">&lt;&lt;</span><span>&quot;</span><span style="color:#2aa198;">) constructed</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>        </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span>    </span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span>    </span><span style="color:#657b83;">{
</span><span>        Foo </span><span style="color:#b58900;">foo1</span><span style="color:#657b83;">{}</span><span>; </span><span style="color:#586e75;">// 调用Foo()构造函数并使用默认参数初始化
</span><span>        Foo </span><span style="color:#b58900;">foo2</span><span style="color:#657b83;">{</span><span style="color:#6c71c4;">6</span><span>,</span><span style="color:#6c71c4;">7</span><span style="color:#657b83;">}</span><span>; </span><span style="color:#586e75;">// 调用Foo(int,int) 构造函数
</span><span>
</span><span>        </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span></code></pre>
<p>以上结论的一个推论是,一个类应该只有一个默认构造函数。如果提供了多个默认构造函数,编译器将无法区分应该选择使用哪个构造函数而报错。</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Foo
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_x </span><span style="color:#657b83;">{}</span><span>;
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_y </span><span style="color:#657b83;">{}</span><span>;
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#b58900;">Foo</span><span style="color:#657b83;">() </span><span style="color:#586e75;">// default constructor
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Foo constructed</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#b58900;">Foo</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int x</span><span style="color:#657b83;">=</span><span style="color:#6c71c4;">1</span><span>, </span><span style="color:#268bd2;">int y</span><span style="color:#657b83;">=</span><span style="color:#6c71c4;">2</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// default constructor
</span><span>        : </span><span style="color:#268bd2;">m_x </span><span style="color:#657b83;">{</span><span> x </span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_y </span><span style="color:#657b83;">{</span><span> y </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Foo(</span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_x </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">, </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_y </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">) constructed</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    Foo </span><span style="color:#b58900;">foo</span><span style="color:#657b83;">{}</span><span>; </span><span style="color:#586e75;">// 编译错误:不知道选用哪个默认构造函数
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>在上述示例中，我们使用无参数的方式实例化 <code>foo</code> ，因此编译器将查找默认构造函数。它会找到两个，并且无法区分应该使用哪个构造函数。这将导致编译错误。</p>
<hr />
<h2 id="yin-shi-mo-ren-gou-zao-han-shu">隐式默认构造函数<a class="zola-anchor" href="#yin-shi-mo-ren-gou-zao-han-shu" aria-label="Anchor link for: yin-shi-mo-ren-gou-zao-han-shu">🔗</a></h2>
<p>如果非聚合类类型的对象没有用户声明的构造函数,编译器会生成一个公共的默认构造函数,这样类可以进行值初始化或默认初始化。这个构造函数就是隐式的默认构造函数。</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Foo
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#268bd2;">int m_x</span><span style="color:#657b83;">{}</span><span>;
</span><span>    </span><span style="color:#268bd2;">int m_y</span><span style="color:#657b83;">{}</span><span>;
</span><span>
</span><span>    </span><span style="color:#586e75;">// 没有声明的构造函数
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    Foo </span><span style="color:#b58900;">foo</span><span style="color:#657b83;">{}</span><span>;
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<ul>
<li>
<p>这个类没有用户声明的构造函数，所以编译器将为我们生成一个隐式默认构造函数。这个构造函数将用于实例化 <code>foo{}</code> 。</p>
</li>
<li>
<p>隐式默认构造函数等同于一个没有参数、没有成员初始化列表且构造函数体内没有语句的构造函数。换句话说，对于上述 <code>Foo</code> 类，编译器生成如下内容：</p>
</li>
</ul>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>public</span><span style="color:#859900;">:
</span><span>    </span><span style="color:#b58900;">Foo</span><span style="color:#657b83;">() </span><span style="color:#586e75;">// 隐式生成默认构造函数
</span><span>    </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#657b83;">}
</span></code></pre>
<p><strong>隐式默认构造函数</strong>（implicit default constructor）在<strong>类没有数据成员</strong>的情况下通常比较有用。但<strong>如果一个类有数据成员</strong>，我们通常希望它们可以用<strong>用户提供的值进行初始化</strong>，而<strong>隐式默认构造函数无法满足这个需求</strong>。</p>
<p>在某些情况下，我们可能会手动编写一个<strong>默认构造函数</strong>，但它的行为实际上和<strong>编译器隐式生成的默认构造函数</strong>完全一样。</p>
<p><strong>在这种情况下，我们可以使用 = default 告诉编译器生成默认构造函数，而不必自己写一个。<strong>这种构造函数被称为</strong>显式默认化的默认构造函数</strong>（explicitly defaulted default constructor）。</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Foo
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_x </span><span style="color:#657b83;">{}</span><span>;
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_y </span><span style="color:#657b83;">{}</span><span>;
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#b58900;">Foo</span><span style="color:#657b83;">() = </span><span style="color:#859900;">default</span><span>; </span><span style="color:#586e75;">// 生成一个显式默认构造函数
</span><span>
</span><span>    </span><span style="color:#b58900;">Foo</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int x</span><span>, </span><span style="color:#268bd2;">int y</span><span style="color:#657b83;">)
</span><span>        : </span><span style="color:#268bd2;">m_x </span><span style="color:#657b83;">{</span><span> x </span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_y </span><span style="color:#657b83;">{</span><span> y </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Foo(</span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_x </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">, </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_y </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">) constructed</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    Foo </span><span style="color:#b58900;">foo</span><span style="color:#657b83;">{}</span><span>; </span><span style="color:#586e75;">// 调用 Foo() 默认构造函数
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>在上述示例中，由于我们声明了一个用户自定义构造函数（ <code>Foo(int, int)</code> ），通常不会生成隐式默认构造函数。然而，因为我们告诉编译器需要为我们生成这样的构造函数，那么它将会生成。这个构造函数随后将被我们对 <code>foo{}</code> 的实例化使用。</p>
<blockquote>
<p>优先使用显式默认构造函数(<code>=default)</code>,而不是空主体的默认构造函数。 </p>
</blockquote>
<hr />
<h2 id="xian-shi-mo-ren-hua-de-mo-ren-gou-zao-han-shu-yu-kong-de-yong-hu-ding-yi-gou-zao-han-shu-qu-bie">显式默认化的默认构造函数与空的用户定义构造函数区别<a class="zola-anchor" href="#xian-shi-mo-ren-hua-de-mo-ren-gou-zao-han-shu-yu-kong-de-yong-hu-ding-yi-gou-zao-han-shu-qu-bie" aria-label="Anchor link for: xian-shi-mo-ren-hua-de-mo-ren-gou-zao-han-shu-yu-kong-de-yong-hu-ding-yi-gou-zao-han-shu-qu-bie">🔗</a></h2>
<ul>
<li>
<p>当使用值初始化一个类时,如果该类具有用户定义的默认构造函数,对象将会进行默认初始化。但是如果该类有一个未由用户提供的默认构造函数即，一个隐式定义的默认构造函数，或者使用 <code>= default</code> 定义的默认构造函数）,那么在默认初始化之前,该对象将被进行零初始化。</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">User
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#268bd2;">int m_a</span><span>; </span><span style="color:#586e75;">// 注意：没有默认初始化值
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_b </span><span style="color:#657b83;">{}</span><span>; </span><span style="color:#586e75;">// 默认初始化为 0
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#b58900;">User</span><span style="color:#657b83;">() {} </span><span style="color:#586e75;">// 用户定义的空构造函数
</span><span>
</span><span>    </span><span style="color:#268bd2;">int </span><span style="color:#b58900;">a</span><span style="color:#657b83;">() </span><span style="color:#859900;">const </span><span style="color:#657b83;">{ </span><span style="color:#859900;">return </span><span style="color:#268bd2;">m_a</span><span>; </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#268bd2;">int </span><span style="color:#b58900;">b</span><span style="color:#657b83;">() </span><span style="color:#859900;">const </span><span style="color:#657b83;">{ </span><span style="color:#859900;">return </span><span style="color:#268bd2;">m_b</span><span>; </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Default
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#268bd2;">int m_a</span><span>; </span><span style="color:#586e75;">// 注意：没有默认初始化值
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_b </span><span style="color:#657b83;">{}</span><span>; </span><span style="color:#586e75;">// 默认初始化为 0
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#b58900;">Default</span><span style="color:#657b83;">() = </span><span style="color:#859900;">default</span><span>; </span><span style="color:#586e75;">// 显式默认化的默认构造函数
</span><span>
</span><span>    </span><span style="color:#268bd2;">int </span><span style="color:#b58900;">a</span><span style="color:#657b83;">() </span><span style="color:#859900;">const </span><span style="color:#657b83;">{ </span><span style="color:#859900;">return </span><span style="color:#268bd2;">m_a</span><span>; </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#268bd2;">int </span><span style="color:#b58900;">b</span><span style="color:#657b83;">() </span><span style="color:#859900;">const </span><span style="color:#657b83;">{ </span><span style="color:#859900;">return </span><span style="color:#268bd2;">m_b</span><span>; </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Implicit
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#268bd2;">int m_a</span><span>; </span><span style="color:#586e75;">// 注意：没有默认初始化值
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_b </span><span style="color:#657b83;">{}</span><span>; </span><span style="color:#586e75;">// 默认初始化为 0
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#586e75;">// 隐式默认构造函数（编译器自动生成）
</span><span>
</span><span>    </span><span style="color:#268bd2;">int </span><span style="color:#b58900;">a</span><span style="color:#657b83;">() </span><span style="color:#859900;">const </span><span style="color:#657b83;">{ </span><span style="color:#859900;">return </span><span style="color:#268bd2;">m_a</span><span>; </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#268bd2;">int </span><span style="color:#b58900;">b</span><span style="color:#657b83;">() </span><span style="color:#859900;">const </span><span style="color:#657b83;">{ </span><span style="color:#859900;">return </span><span style="color:#268bd2;">m_b</span><span>; </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    User </span><span style="color:#b58900;">user</span><span style="color:#657b83;">{}</span><span>; </span><span style="color:#586e75;">// 默认初始化（m_a 未初始化，m_b 初始化为 0）
</span><span>    std::cout </span><span style="color:#657b83;">&lt;&lt;</span><span> user.</span><span style="color:#b58900;">a</span><span style="color:#657b83;">() &lt;&lt; </span><span>&#39; &#39; </span><span style="color:#657b83;">&lt;&lt;</span><span> user.</span><span style="color:#b58900;">b</span><span style="color:#657b83;">() &lt;&lt; </span><span>&#39;</span><span style="color:#dc322f;">\n</span><span>&#39;;
</span><span>
</span><span>    Default </span><span style="color:#b58900;">def</span><span style="color:#657b83;">{}</span><span>; </span><span style="color:#586e75;">// 先零初始化（m_a、m_b 设为 0），然后默认初始化
</span><span>    std::cout </span><span style="color:#657b83;">&lt;&lt;</span><span> def.</span><span style="color:#b58900;">a</span><span style="color:#657b83;">() &lt;&lt; </span><span>&#39; &#39; </span><span style="color:#657b83;">&lt;&lt;</span><span> def.</span><span style="color:#b58900;">b</span><span style="color:#657b83;">() &lt;&lt; </span><span>&#39;</span><span style="color:#dc322f;">\n</span><span>&#39;;
</span><span>
</span><span>    Implicit </span><span style="color:#b58900;">imp</span><span style="color:#657b83;">{}</span><span>; </span><span style="color:#586e75;">// 先零初始化（m_a、m_b 设为 0），然后默认初始化
</span><span>    std::cout </span><span style="color:#657b83;">&lt;&lt;</span><span> imp.</span><span style="color:#b58900;">a</span><span style="color:#657b83;">() &lt;&lt; </span><span>&#39; &#39; </span><span style="color:#657b83;">&lt;&lt;</span><span> imp.</span><span style="color:#b58900;">b</span><span style="color:#657b83;">() &lt;&lt; </span><span>&#39;</span><span style="color:#dc322f;">\n</span><span>&#39;;
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>上面程序在我的电脑上的打印结果:</p>
<p><img src="https://images.waer.ltd/notes/202503211834070.png" alt="image-20250321183413006" /></p>
</li>
<li>
<p>在 C++20 之前，如果一个类具有用户定义的默认构造函数（即使它的函数体为空），那么该类就不再被视为聚合类型（aggregate）。然而，如果使用 = default 语法显式地默认化默认构造函数，则不会影响该类仍然被视为聚合类型。</p>
<p>假设该类在其他方面符合聚合类型的要求，前者（用户定义的默认构造函数）会导致类使用<strong>列表初始化（list initialization）</strong>，而不是<strong>聚合初始化（aggregate initialization）</strong>。</p>
<p>从 C++20 开始，这个不一致性被修正了，使得<strong>无论是用户定义的空默认构造函数，还是显式默认化的默认构造函数，都会使类变为非聚合类型</strong>。</p>
<hr />
<h2 id="chuang-jian-mo-ren-gou-zao-han-shu-de-shi-ji">创建默认构造函数的时机<a class="zola-anchor" href="#chuang-jian-mo-ren-gou-zao-han-shu-de-shi-ji" aria-label="Anchor link for: chuang-jian-mo-ren-gou-zao-han-shu-de-shi-ji">🔗</a></h2>
<p>默认构造函数允许我们在没有提供初始化值的情况下创建<strong>非聚合类</strong>类型的对象。因此，<strong>只有当一个类的对象在默认情况下可以合理地被创建时，才应该提供默认构造函数</strong>。</p>
<p>换句话说，如果一个类的所有成员变量都可以有一个合理的默认值（例如 0、nullptr、空字符串等），那么提供默认构造函数是合适的。否则，类应该要求用户提供必要的初始化值，以确保对象在创建时处于有效的状态。</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Fraction
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#268bd2;">int m_numerator</span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">0 </span><span style="color:#657b83;">}</span><span>;    </span><span style="color:#586e75;">// 分子，默认初始化为 0
</span><span>    </span><span style="color:#268bd2;">int m_denominator</span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">1 </span><span style="color:#657b83;">}</span><span>;  </span><span style="color:#586e75;">// 分母，默认初始化为 1
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#b58900;">Fraction</span><span style="color:#657b83;">() = </span><span style="color:#859900;">default</span><span>;    </span><span style="color:#586e75;">// 显式声明默认构造函数
</span><span>    </span><span style="color:#b58900;">Fraction</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int numerator</span><span>, </span><span style="color:#268bd2;">int denominator</span><span style="color:#657b83;">)
</span><span>        : </span><span style="color:#268bd2;">m_numerator</span><span style="color:#657b83;">{</span><span> numerator </span><span style="color:#657b83;">}
</span><span>        , </span><span style="color:#268bd2;">m_denominator</span><span style="color:#657b83;">{</span><span> denominator </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#268bd2;">void </span><span style="color:#b58900;">print</span><span style="color:#657b83;">() </span><span style="color:#859900;">const
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Fraction(</span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_numerator </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">, </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_denominator </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">)</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    Fraction </span><span style="color:#b58900;">f1 </span><span style="color:#657b83;">{</span><span style="color:#6c71c4;">3</span><span>, </span><span style="color:#6c71c4;">5</span><span style="color:#657b83;">}</span><span>;  </span><span style="color:#586e75;">// 使用带参数的构造函数
</span><span>    f1.</span><span style="color:#b58900;">print</span><span style="color:#657b83;">()</span><span>;
</span><span>
</span><span>    Fraction </span><span style="color:#b58900;">f2 </span><span style="color:#657b83;">{}</span><span>;  </span><span style="color:#586e75;">// 由于 `= default`，使用默认构造函数
</span><span>    f2.</span><span style="color:#b58900;">print</span><span style="color:#657b83;">()</span><span>;
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>对于表示<strong>分数（Fraction）的类来说，允许用户不提供初始化值</strong>来创建 Fraction 对象是合理的。在这种情况下，用户会得到默认的分数 0/1。</p>
<p>现在考虑下面这个类:</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">string</span><span>&gt;
</span><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">string_view</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Employee
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    std::string </span><span style="color:#268bd2;">m_name</span><span style="color:#657b83;">{ }</span><span>;
</span><span>    </span><span style="color:#268bd2;">int m_id</span><span style="color:#657b83;">{ }</span><span>;
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#b58900;">Employee</span><span style="color:#657b83;">(</span><span>std::string_view </span><span style="color:#268bd2;">name</span><span>, </span><span style="color:#268bd2;">int id</span><span style="color:#657b83;">)
</span><span>        : </span><span style="color:#268bd2;">m_name</span><span style="color:#657b83;">{</span><span> name </span><span style="color:#657b83;">}
</span><span>        , </span><span style="color:#268bd2;">m_id</span><span style="color:#657b83;">{</span><span> id </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#268bd2;">void </span><span style="color:#b58900;">print</span><span style="color:#657b83;">() </span><span style="color:#859900;">const
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Employee(</span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_name </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">, </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_id </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">)</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    Employee </span><span style="color:#b58900;">e1 </span><span style="color:#657b83;">{ </span><span>&quot;</span><span style="color:#2aa198;">Joe</span><span>&quot;, </span><span style="color:#6c71c4;">1 </span><span style="color:#657b83;">}</span><span>;
</span><span>    e1.</span><span style="color:#b58900;">print</span><span style="color:#657b83;">()</span><span>;
</span><span>
</span><span>    Employee </span><span style="color:#b58900;">e2 </span><span style="color:#657b83;">{}</span><span>; </span><span style="color:#586e75;">//编译错误：无匹配的构造函数
</span><span>    e2.</span><span style="color:#b58900;">print</span><span style="color:#657b83;">()</span><span>;
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>现实中，一个员工对象<strong>必须有名字</strong>，否则不合理。因此，我们<strong>不应该提供默认构造函数</strong>，这样如果用户尝试创建无名员工，就会<strong>导致编译错误</strong>，提醒用户必须提供参数。</p>
<hr />
<h2 id="wei-tuo-gou-zao-han-shu">委托构造函数<a class="zola-anchor" href="#wei-tuo-gou-zao-han-shu" aria-label="Anchor link for: wei-tuo-gou-zao-han-shu">🔗</a></h2>
<p>在 C++ 中，<strong>委托构造函数</strong>（<strong>Delegating Constructors</strong>）允许一个构造函数<strong>调用同一个类中的另一个构造函数</strong>，以减少代码重复，提高可维护性。</p>
<p>当一个类包含多个构造函数时，每个构造函数中的代码通常非常相似，甚至完全相同，有大量的重复。我们同样希望尽可能去除构造函数中的冗余代码。</p>
<p>看这个例子:</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">string</span><span>&gt;
</span><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">string_view</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Employee
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    std::string m_name </span><span style="color:#657b83;">{ </span><span>&quot;</span><span style="color:#2aa198;">???</span><span>&quot; </span><span style="color:#657b83;">}</span><span>; </span><span style="color:#586e75;">// 默认名称为 &quot;???&quot;
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_id </span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">0 </span><span style="color:#657b83;">}</span><span>;               </span><span style="color:#586e75;">// 默认 ID 为 0
</span><span>    </span><span style="color:#268bd2;">bool</span><span> m_isManager </span><span style="color:#657b83;">{ </span><span style="color:#b58900;">false </span><span style="color:#657b83;">}</span><span>;   </span><span style="color:#586e75;">// 默认不是经理
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#b58900;">Employee</span><span style="color:#657b83;">(</span><span>std::string_view </span><span style="color:#268bd2;">name</span><span>, </span><span style="color:#268bd2;">int id</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// 员工必须要有姓名和 ID
</span><span>        : </span><span style="color:#268bd2;">m_name</span><span style="color:#657b83;">{</span><span> name </span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_id </span><span style="color:#657b83;">{</span><span> id </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Employee </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_name </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;"> created</span><span style="color:#dc322f;">\n</span><span>&quot;; </span><span style="color:#586e75;">// 输出员工创建信息
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#b58900;">Employee</span><span style="color:#657b83;">(</span><span>std::string_view </span><span style="color:#268bd2;">name</span><span>, </span><span style="color:#268bd2;">int id</span><span>, </span><span style="color:#268bd2;">bool isManager</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// 员工可以选择是否是经理
</span><span>        : </span><span style="color:#268bd2;">m_name</span><span style="color:#657b83;">{</span><span> name </span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_id</span><span style="color:#657b83;">{</span><span> id </span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_isManager </span><span style="color:#657b83;">{</span><span> isManager </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Employee </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_name </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;"> created</span><span style="color:#dc322f;">\n</span><span>&quot;; </span><span style="color:#586e75;">// 输出员工创建信息
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    Employee </span><span style="color:#b58900;">e1</span><span style="color:#657b83;">{ </span><span>&quot;</span><span style="color:#2aa198;">James</span><span>&quot;, </span><span style="color:#6c71c4;">7 </span><span style="color:#657b83;">}</span><span>;       </span><span style="color:#586e75;">// 创建普通员工 &quot;James&quot;
</span><span>    Employee </span><span style="color:#b58900;">e2</span><span style="color:#657b83;">{ </span><span>&quot;</span><span style="color:#2aa198;">Dave</span><span>&quot;, </span><span style="color:#6c71c4;">42</span><span>, </span><span style="color:#b58900;">true </span><span style="color:#657b83;">}</span><span>; </span><span style="color:#586e75;">// 创建经理 &quot;Dave&quot;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>你会发现,两个构造函数主体中都打印了完全相同的语句。</p>
<blockquote>
<p>通常来说，让构造函数打印内容（除了用于调试目的外）并不是一个好的做法，我们的文章中经常这样做,目的是为了更好的阐述观点,实际开发中不建议这样做,望悉知!</p>
</blockquote>
</li>
</ul>
<p>由于构造函数允许调用其他函数,包括类的其他成员函数,那么我们可以这样重构:</p>
<p>+++
title = “[C++游戏开发基础]:构造函数浅析(8000字)”
date = 2025-06-19
tags = [“C++”, “游戏开发”, “构造函数”]
description = “深入解析C++构造函数的原理、使用方法及最佳实践”
+++</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">string</span><span>&gt;
</span><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">string_view</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Employee
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    std::string m_name </span><span style="color:#657b83;">{ </span><span>&quot;</span><span style="color:#2aa198;">???</span><span>&quot; </span><span style="color:#657b83;">}</span><span>; </span><span style="color:#586e75;">// 默认名称为 &quot;???&quot;
</span><span>    </span><span style="color:#268bd2;">int m_id</span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">0 </span><span style="color:#657b83;">}</span><span>;               </span><span style="color:#586e75;">// 默认 ID 为 0
</span><span>    </span><span style="color:#268bd2;">bool</span><span> m_isManager </span><span style="color:#657b83;">{ </span><span style="color:#b58900;">false </span><span style="color:#657b83;">}</span><span>;  </span><span style="color:#586e75;">// 默认不是经理
</span><span>
</span><span>    </span><span style="color:#268bd2;">void </span><span style="color:#b58900;">printCreated</span><span style="color:#657b83;">() </span><span style="color:#859900;">const </span><span style="color:#586e75;">// 辅助函数：打印员工创建信息
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Employee </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_name </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;"> created</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#b58900;">Employee</span><span style="color:#657b83;">(</span><span>std::string_view </span><span style="color:#268bd2;">name</span><span>, </span><span style="color:#268bd2;">int id</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// 构造函数：指定姓名和 ID
</span><span>        : </span><span style="color:#268bd2;">m_name</span><span style="color:#657b83;">{</span><span> name </span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_id </span><span style="color:#657b83;">{</span><span> id </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">{
</span><span>        </span><span style="color:#b58900;">printCreated</span><span style="color:#657b83;">()</span><span>; </span><span style="color:#586e75;">// 调用辅助函数
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#b58900;">Employee</span><span style="color:#657b83;">(</span><span>std::string_view </span><span style="color:#268bd2;">name</span><span>, </span><span style="color:#268bd2;">int id</span><span>, </span><span style="color:#268bd2;">bool isManager</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// 构造函数：指定姓名、ID 以及是否为经理
</span><span>        : </span><span style="color:#268bd2;">m_name</span><span style="color:#657b83;">{</span><span> name </span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_id</span><span style="color:#657b83;">{</span><span> id </span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_isManager </span><span style="color:#657b83;">{</span><span> isManager </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">{
</span><span>        </span><span style="color:#b58900;">printCreated</span><span style="color:#657b83;">()</span><span>; </span><span style="color:#586e75;">// 调用辅助函数
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    Employee </span><span style="color:#b58900;">e1</span><span style="color:#657b83;">{ </span><span>&quot;</span><span style="color:#2aa198;">James</span><span>&quot;, </span><span style="color:#6c71c4;">7 </span><span style="color:#657b83;">}</span><span>;       </span><span style="color:#586e75;">// 创建普通员工 &quot;James&quot;
</span><span>    Employee </span><span style="color:#b58900;">e2</span><span style="color:#657b83;">{ </span><span>&quot;</span><span style="color:#2aa198;">Dave</span><span>&quot;, </span><span style="color:#6c71c4;">42</span><span>, </span><span style="color:#b58900;">true </span><span style="color:#657b83;">}</span><span>; </span><span style="color:#586e75;">// 创建经理 &quot;Dave&quot;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>虽然这比之前的版本好（冗余语句被冗余函数调用所取代），但它需要引入一个新的函数。而且，我们的两个构造函数也在初始化 <code>m_name</code> 和 <code>m_id</code> 。理想情况下，我们也希望去除这种冗余。</p>
<p>你可能会想到,在一个构造函数中调用对外一个构造函数来实现,比如下面这样的:</p>
<p>+++
title = “[C++游戏开发基础]:构造函数浅析(8000字)”
date = 2025-06-19
tags = [“C++”, “游戏开发”, “构造函数”]
description = “深入解析C++构造函数的原理、使用方法及最佳实践”
+++</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">string</span><span>&gt;
</span><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">string_view</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Employee
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    std::string m_name </span><span style="color:#657b83;">{ </span><span>&quot;</span><span style="color:#2aa198;">???</span><span>&quot; </span><span style="color:#657b83;">}</span><span>;
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_id </span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">0 </span><span style="color:#657b83;">}</span><span>;
</span><span>    </span><span style="color:#268bd2;">bool</span><span> m_isManager </span><span style="color:#657b83;">{ </span><span style="color:#b58900;">false </span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#b58900;">Employee</span><span style="color:#657b83;">(</span><span>std::string_view </span><span style="color:#268bd2;">name</span><span>, </span><span style="color:#268bd2;">int id</span><span style="color:#657b83;">)
</span><span>        : </span><span style="color:#268bd2;">m_name</span><span style="color:#657b83;">{</span><span> name </span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_id </span><span style="color:#657b83;">{</span><span> id </span><span style="color:#657b83;">} </span><span style="color:#586e75;">// 此构造函数用于初始化 m_name 和 m_id
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Employee </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_name </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;"> created</span><span style="color:#dc322f;">\n</span><span>&quot;; </span><span style="color:#586e75;">// 这里重新加入了打印语句
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#b58900;">Employee</span><span style="color:#657b83;">(</span><span>std::string_view </span><span style="color:#268bd2;">name</span><span>, </span><span style="color:#268bd2;">int id</span><span>, </span><span style="color:#268bd2;">bool isManager</span><span style="color:#657b83;">)
</span><span>        : </span><span style="color:#268bd2;">m_isManager </span><span style="color:#657b83;">{</span><span> isManager </span><span style="color:#657b83;">} </span><span style="color:#586e75;">// 此构造函数仅初始化 m_isManager
</span><span>    </span><span style="color:#657b83;">{
</span><span>        </span><span style="color:#586e75;">// 试图调用 Employee(std::string_view, int) 来初始化 m_name 和 m_id
</span><span>        </span><span style="color:#b58900;">Employee</span><span style="color:#657b83;">(</span><span>name, id</span><span style="color:#657b83;">)</span><span>; </span><span style="color:#586e75;">// 这段代码不会按预期工作！
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#859900;">const</span><span> std::string</span><span style="color:#859900;">&amp; </span><span style="color:#b58900;">getName</span><span style="color:#657b83;">() </span><span style="color:#859900;">const </span><span style="color:#657b83;">{ </span><span style="color:#859900;">return </span><span style="color:#268bd2;">m_name</span><span>; </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    Employee </span><span style="color:#b58900;">e2</span><span style="color:#657b83;">{ </span><span>&quot;</span><span style="color:#2aa198;">Dave</span><span>&quot;, </span><span style="color:#6c71c4;">42</span><span>, </span><span style="color:#b58900;">true </span><span style="color:#657b83;">}</span><span>;
</span><span>    std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">e2 has name: </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt;</span><span> e2.</span><span style="color:#b58900;">getName</span><span style="color:#657b83;">() &lt;&lt; </span><span>&quot;</span><span style="color:#dc322f;">\n</span><span>&quot;; </span><span style="color:#586e75;">// 打印 e2.m_name
</span><span style="color:#657b83;">}
</span></code></pre>
<p>遗憾的是,类似这样的调用不会正常运行,你可以自己运行看看。</p>
<blockquote>
<p>不应在另一个函数的主体中直接调用构造函数。这样做要么会导致编译错误，要么会直接初始化一个临时对象。</p>
</blockquote>
<p>那么如果不能在另一个构造函数的主体中调用构造函数，我们该如何解决这个问题？</p>
<p>这就引出了 <strong>委托构造函数</strong>的概念。</p>
<p>构造函数允许将初始化责任(委托)转移给同一个类类型的另一个构造函数。这个过程有时候也称为构造函数链式调用,这样的构造函数称为委托构造函数。</p>
<p>要使一个构造函数委托初始化给另一个构造函数,只需要在成员初始化列表中调用构造函数即可:</p>
<p>+++
title = “[C++游戏开发基础]:构造函数浅析(8000字)”
date = 2025-06-19
tags = [“C++”, “游戏开发”, “构造函数”]
description = “深入解析C++构造函数的原理、使用方法及最佳实践”
+++</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">string</span><span>&gt;
</span><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">string_view</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Employee
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    std::string m_name </span><span style="color:#657b83;">{ </span><span>&quot;</span><span style="color:#2aa198;">???</span><span>&quot; </span><span style="color:#657b83;">}</span><span>;
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_id </span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">0 </span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#b58900;">Employee</span><span style="color:#657b83;">(</span><span>std::string_view </span><span style="color:#268bd2;">name</span><span style="color:#657b83;">)
</span><span>        : </span><span style="color:#268bd2;">Employee</span><span style="color:#657b83;">{</span><span> name, </span><span style="color:#6c71c4;">0 </span><span style="color:#657b83;">} </span><span style="color:#586e75;">// 将初始化委托给 Employee(std::string_view, int) 构造函数
</span><span>    </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#b58900;">Employee</span><span style="color:#657b83;">(</span><span>std::string_view </span><span style="color:#268bd2;">name</span><span>, </span><span style="color:#268bd2;">int id</span><span style="color:#657b83;">)
</span><span>        : </span><span style="color:#268bd2;">m_name</span><span style="color:#657b83;">{</span><span> name </span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_id </span><span style="color:#657b83;">{</span><span> id </span><span style="color:#657b83;">} </span><span style="color:#586e75;">// 实际上初始化成员变量
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Employee </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_name </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;"> created</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    Employee </span><span style="color:#b58900;">e1</span><span style="color:#657b83;">{ </span><span>&quot;</span><span style="color:#2aa198;">James</span><span>&quot; </span><span style="color:#657b83;">}</span><span>;
</span><span>    Employee </span><span style="color:#b58900;">e2</span><span style="color:#657b83;">{ </span><span>&quot;</span><span style="color:#2aa198;">Dave</span><span>&quot;, </span><span style="color:#6c71c4;">42 </span><span style="color:#657b83;">}</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>针对中这个示例,简单看一下初始化的流程:</p>
<ul>
<li>当 <code>e1 { &quot;James&quot; }</code> 被初始化时，匹配的构造函数 <code>Employee(std::string_view)</code> 将被调用，其中参数 <code>name</code> 设置为 <code>&quot;James&quot;</code> 。</li>
<li>这个构造函数的成员初始化列表委托初始化给另一个构造函数，因此 <code>Employee(std::string_view, int)</code> 随后被调用。</li>
<li><code>name</code> （ <code>&quot;James&quot;</code> ）的值作为第一个参数传递，字面量 <code>0</code> 作为第二个参数传递。被委托构造函数的成员初始化列表初始化成员，然后被委托构造函数的主体运行。</li>
<li>然后控制权返回到初始构造函数，其（空）主体运行。</li>
<li>最后,控制权返回给调用者。</li>
</ul>
<p>这种方法的缺点是有时候需要重复初始化值。在委托给<code>mployee(std::string_view, int)</code> 构造函数时，我们需要为 <code>int</code> 参数提供一个初始化值。我们不得不<strong>硬编码</strong>字面量 <code>0</code> ，因为没有方法可以引用默认成员初始化器。</p>
<blockquote>
<p>记住,硬编码不是什么好习惯!</p>
</blockquote>
<p>关于委托构造函数的几点额外说明。首先，委托给另一个构造函数的构造函数不允许自己进行任何成员初始化。所以你的构造函数可以委托或初始化，但不能两者都做。</p>
<p>换句话说就是,你既然委托了别人进行初始化的操作,那么你自己就别再做同样的初始化操作了。</p>
<blockquote>
<p>请注意，我们让 <code>Employee(std::string_view)</code>（参数较少的构造函数）委托（delegate）给 <code>Employee(std::string_view name, int id)</code>（参数较多的构造函数）。通常，参数较少的构造函数会委托给参数较多的构造函数。</p>
<hr />
<p>如果反过来,让<code>Employee(std::string_view name, int id)</code>委托给 <code>Employee(std::string_view)</code>，那么我们将无法使用 <code>id</code> 来初始化<code> m_id</code>，因为构造函数只能<strong>要么委托给另一个构造函数，要么自己进行初始化</strong>，但不能同时执行这两种操作。</p>
</blockquote>
<p><strong>警告⚠️</strong></p>
<blockquote>
<p>如果一个构造函数委托给另一个构造函数,而那个被委托的构造函数又委托回第一个构造函数。这样会形成一个无限循环,从而导致程序耗尽栈空间而崩溃。</p>
</blockquote>
<hr />
<h2 id="shi-yong-mo-ren-can-shu-lai-jian-shao-gou-zao-han-shu">使用默认参数来减少构造函数<a class="zola-anchor" href="#shi-yong-mo-ren-can-shu-lai-jian-shao-gou-zao-han-shu" aria-label="Anchor link for: shi-yong-mo-ren-can-shu-lai-jian-shao-gou-zao-han-shu">🔗</a></h2>
<p>默认值有时也可以将多个构造函数减少到一定数量。例如,就上面的例子来说,通过在<code>id</code>参数上设置一个默认值,我们可以创建一个单个<code>Employee</code>构造函数,该构造函数只需要一个名称参数,此时<code>id</code>参数就是可选而非必须的。</p>
<p>+++
title = “[C++游戏开发基础]:构造函数浅析(8000字)”
date = 2025-06-19
tags = [“C++”, “游戏开发”, “构造函数”]
description = “深入解析C++构造函数的原理、使用方法及最佳实践”
+++</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">string</span><span>&gt;
</span><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">string_view</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Employee
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    std::string </span><span style="color:#268bd2;">m_name</span><span style="color:#657b83;">{}</span><span>;
</span><span>    </span><span style="color:#268bd2;">int m_id</span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">0 </span><span style="color:#657b83;">}</span><span>; </span><span style="color:#586e75;">// 默认成员初始化（default member initializer）
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>
</span><span>    </span><span style="color:#b58900;">Employee</span><span style="color:#657b83;">(</span><span>std::string_view </span><span style="color:#268bd2;">name</span><span>, </span><span style="color:#268bd2;">int id </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// 为 id 提供默认参数（default argument）
</span><span>        : </span><span style="color:#268bd2;">m_name</span><span style="color:#657b83;">{</span><span> name </span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_id</span><span style="color:#657b83;">{</span><span> id </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Employee </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_name </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;"> created</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    Employee </span><span style="color:#b58900;">e1</span><span style="color:#657b83;">{ </span><span>&quot;</span><span style="color:#2aa198;">James</span><span>&quot; </span><span style="color:#657b83;">}</span><span>; </span><span style="color:#586e75;">// 由于 id 没有提供，使用默认值 0
</span><span>    Employee </span><span style="color:#b58900;">e2</span><span style="color:#657b83;">{ </span><span>&quot;</span><span style="color:#2aa198;">Dave</span><span>&quot;, </span><span style="color:#6c71c4;">42 </span><span style="color:#657b83;">}</span><span>; </span><span style="color:#586e75;">// 提供了 id，使用 42 进行初始化
</span><span style="color:#657b83;">}
</span></code></pre>
<p><strong>最佳实践</strong></p>
<blockquote>
<ul>
<li>
<p>用户必须提供初始化值的成员应该首先定义(并且作为构造函数的左侧参数)。</p>
</li>
<li>
<p>用户可以提供初始化值的成员应该第二定义(且作为构造函数的右侧参数)。</p>
</li>
</ul>
</blockquote>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#268bd2;">class </span><span style="color:#b58900;">Employee
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    std::string </span><span style="color:#268bd2;">m_name</span><span>; </span><span style="color:#586e75;">// 必须提供
</span><span>    </span><span style="color:#268bd2;">int m_id</span><span>; </span><span style="color:#586e75;">// 必须提供
</span><span>    </span><span style="color:#268bd2;">bool m_isManager</span><span>; </span><span style="color:#586e75;">// 可选（有默认值）
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#b58900;">Employee</span><span style="color:#657b83;">(</span><span>std::string_view </span><span style="color:#268bd2;">name</span><span>, </span><span style="color:#268bd2;">int id</span><span>, </span><span style="color:#268bd2;">bool isManager </span><span style="color:#657b83;">= </span><span style="color:#b58900;">false</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// isManager 在最右侧
</span><span>        : </span><span style="color:#268bd2;">m_name</span><span style="color:#657b83;">{</span><span> name </span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_id</span><span style="color:#657b83;">{</span><span> id </span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_isManager</span><span style="color:#657b83;">{</span><span> isManager </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span></code></pre>
<hr />
<p>当<strong>某个初始化值</strong>（例如默认成员初始化值和构造函数参数的默认值）在<strong>多个地方被使用</strong>时，<strong>建议定义一个命名常量</strong>，并在需要的地方使用它。</p>
<p>这样做的好处是：</p>
<ul>
<li>
<p><strong>统一管理初始化值</strong>，只需在一个地方修改，就能影响所有使用该值的地方。</p>
</li>
<li>
<p><strong>避免魔法数字（magic numbers）</strong>，提高代码的可读性和可维护性。</p>
</li>
</ul>
<p>尽管可以使用 <strong>constexpr 全局变量</strong> 来存储这些默认值，但更好的做法是<strong>在类中使用 static constexpr 成员变量</strong>。</p>
<p>+++
title = “[C++游戏开发基础]:构造函数浅析(8000字)”
date = 2025-06-19
tags = [“C++”, “游戏开发”, “构造函数”]
description = “深入解析C++构造函数的原理、使用方法及最佳实践”
+++</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">string</span><span>&gt;
</span><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">string_view</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Employee
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#859900;">static constexpr </span><span style="color:#268bd2;">int</span><span> default_id </span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">0 </span><span style="color:#657b83;">}</span><span>; </span><span style="color:#586e75;">// 定义一个命名常量，表示默认的 ID 值
</span><span>
</span><span>    std::string m_name </span><span style="color:#657b83;">{}</span><span>;
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_id </span><span style="color:#657b83;">{</span><span> default_id </span><span style="color:#657b83;">}</span><span>; </span><span style="color:#586e75;">// 在这里使用命名常量进行默认初始化
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>
</span><span>    </span><span style="color:#b58900;">Employee</span><span style="color:#657b83;">(</span><span>std::string_view </span><span style="color:#268bd2;">name</span><span>, </span><span style="color:#268bd2;">int id </span><span style="color:#657b83;">=</span><span> default_id</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// 在构造函数的默认参数中也使用该命名常量
</span><span>        : </span><span style="color:#268bd2;">m_name </span><span style="color:#657b83;">{</span><span> name </span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_id </span><span style="color:#657b83;">{</span><span> id </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Employee </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_name </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;"> created</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    Employee </span><span style="color:#b58900;">e1 </span><span style="color:#657b83;">{ </span><span>&quot;</span><span style="color:#2aa198;">James</span><span>&quot; </span><span style="color:#657b83;">}</span><span>;     </span><span style="color:#586e75;">// ID 默认使用 default_id（即 0）
</span><span>    Employee </span><span style="color:#b58900;">e2 </span><span style="color:#657b83;">{ </span><span>&quot;</span><span style="color:#2aa198;">Dave</span><span>&quot;, </span><span style="color:#6c71c4;">42 </span><span style="color:#657b83;">}</span><span>;  </span><span style="color:#586e75;">// ID 显式指定为 42
</span><span style="color:#657b83;">}
</span></code></pre>
<p><strong>为什么 static constexpr 更优？</strong></p>
<p>使用 static 关键字，使 default_id 成为<strong>所有 Employee 对象共享的静态成员</strong>。如果不使用<code>static</code>,每个 Employee 对象都会有<strong>自己独立的 default_id 成员</strong>，这虽然不会影响功能，但会<strong>浪费内存</strong>，因为所有 default_id 变量的值都是相同的。</p>
<p>使用这种方式,<code>default_id </code><strong>存储在类的静态区域</strong>，而不是每个对象都存一份。这样所有 <code>Employee</code> 对象都能<strong>共享一个 default_id</strong>，提高效率并减少内存浪费</p>
<p><strong>这种方式的缺点</strong></p>
<ul>
<li>
<p><strong>增加类的复杂度</strong>：每增加一个<strong>命名常量</strong>，都会给类添加一个额外的名称，可能会使类变得稍微复杂。</p>
<p><strong>是否值得使用取决于场景</strong>：</p>
<ul>
<li>如果默认值只在一个地方使用，<strong>直接写死</strong>即可（比如 m_id { 0 }）。</li>
<li><strong>如果默认值在多个地方使用</strong>，则使用 <strong>static constexpr</strong> 更合适。</li>
</ul>
</li>
</ul>
<hr />

      
    </div><!--./card-body-->

    <div class="card-footer">
      <div class="columns">
        <div class="column col-9 col-sm-7">
          <div class="taxonomies text-left">
            

    
          </div>
        </div><!--./col-6-->
        
        </div><!--./columns-->
    </div><!--./card-footer-->
</div><!--./card-->
</div>
              <div id="sidebar" class="column col-4 col-md-12">
                <div class="sidebar-content">
                  
                  
<div class="sidebar-widget">
  <div class="tile">
    <div class="tile-icon">
      <figure class="avatar avatar-xl">
        <img src="https://ilikexff.cn/avatar.png" alt="author avatar image">
      </figure>
    </div>
    <div class="tile-content">
      <p class="tile-title" style="font-weight: 600;">八尺妖剑</p>
      <p class="tile-subtitle">热爱编程，专注于技术分享和学习</p>
    </div>
</div><!--./tile-->
</div>

                  
                  
<div class="sidebar-widget">
  欢迎来到<strong>八尺妖剑</strong>！这里分享技术文章和编程心得。
</div><!-- end text widget -->

                  

                  </div><!--./sidebar-content-->
              </div>
            </div>
            
          </section>
        </section></section>
<section class="container grid-xl">
<ul class="pagination paginator">
  
  
</ul>
</section>
</div><!-- ./page-wrapper -->

    
<div class="mobile-container">
        <div class="overlay" id="overlay">
            <div style="padding: 1rem;">
              
<a class="site-logo" href="https:&#x2F;&#x2F;ilikexff.cn">
  
  <div class="col-mx-auto">
    <figure style="margin: 8px">
      <img class="img-responsive"
           style="max-height: 45px"
           alt="frontmatter image"
           src="https://ilikexff.cn/./assets/logo.png">
    </figure>
  </div>
  
</a>

            </div>
            <nav class="overlay-menu">
              

<ul class="tree treemenu treemenu-root"><li class="tree-empty">
      <span class="toggler"></span>
      <a href="https://ilikexff.cn/tags">标签</a>
    </li><li class="tree-empty">
      <span class="toggler"></span>
      <a href="https://ilikexff.cn/categories">分类</a>
    </li><li class="tree-empty">
      <span class="toggler"></span>
      <a href="https://ilikexff.cn/about">关于</a>
    </li></ul>


              </nav>
        </div>
    </div>

<script type="text/javascript">
  var overlay = document.getElementById('overlay');
  var toggle = document.getElementById('toggle');

  function openOverlay(){
      // Open overlay
      if (overlay.classList.contains("open")) {
          overlay.classList.remove("open");
      }
      else {
          overlay.classList.add("open");
      }

      // Button transition
      if (toggle.classList.contains("active")) {
          toggle.classList.remove("active");
      }
      else {
          toggle.classList.add("active");
      }
    }
</script>

<section id="footer" class="bg-gray">
  <div class="container grid-xl">
    


    <div class="columns">
      
      <div class="column col-8 col-lg-12 col-mx-auto" style="text-align: center;">
        简单是效率的灵魂 | <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer">黔ICP备2021010295号</a>
      </div>
      
      
    </div>
  </div>
</section>
</body>
</html>
