<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>慕予博客</title>
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"
    integrity="sha256-WCzAhd2P6gRJF9Hv3oOOd+hFJi/QJbv+Azn4CGB8gfY=" crossorigin="anonymous" defer></script>
  <script src="/js/index.js" defer></script>
  <script src="/js/prompt.js" defer></script>
  <script src="/js/keyboard.js" defer></script>
  <script src="/js/tab.js" defer></script>
  <script src="/js/commands.js" defer></script>
  <script src="/js/config.js" defer></script><script src="/config.js"></script><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="style.css"><link rel="stylesheet" href="/css/page.css"></head><body onkeydown="exec(event)" style="background-image: url(&quot;&#x2F;assets&#x2F;bg.jpg&quot;); "><main>
      <div class="files" id="files" tabindex="0">
<ul>

  <li class="file">
    <span><a href='https://ilikexff.cn/8-kuan-rang-ni-kai-fa-qi-fei-de-intellijidea-cha-jian/'
      tabindex="-2">  8款让你开发起飞的IntellijIDEA插件</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/aop-jie-mi-qie-mian-bian-cheng-de-zong-he-zhi-nan/'
      tabindex="-3">  AOP揭秘：切面编程的综合指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-mei-ju-pian-yi-wu-fan-wei-mei-ju/'
      tabindex="-4">  C++游戏开发基础-枚举篇一：无范围枚举</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-std-optional/'
      tabindex="-5">  C++游戏开发基础-深入解析std::optional</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shen-ru-jie-xi-thiszhi-zhen-de-ying-yong-yu-ji-qiao/'
      tabindex="-6">  C++游戏开发基础-深入解析this指针的应用与技巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-fu-zhi-gou-zao-han-shu/'
      tabindex="-7">  C++游戏开发基础-深入解析复制构造函数</a></span>
  </li><li class="file">
    <span><a class="selected"href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-mo-ban-he-can-shu-tui-dao-zhi-nan/'
      tabindex="-8">  C++游戏开发基础-类模版和参数推导指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/dockerbi-zhi-bi-hui/'
      tabindex="-9">  Docker必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/githithub-xiao-ce/'
      tabindex="-10">  GitGitHub小册</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/google-hacking/'
      tabindex="-11">  Google Hacking</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/googleguan-fang-ti-shi-gong-cheng-bai-pi-shu-zhong-wen-yi-ben/'
      tabindex="-12">  Google官方《提示工程白皮书（中文译本）》</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-dai-ma-bu-quan-ti-shi-gong-neng-xiao-shi-de-ji-chong-jie-jue-fang-an-re-geng-ban/'
      tabindex="-13">  IDEA代码补全&amp;提示功能消失的几种解决方案(热更版)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-chen-jin-shi-bian-cheng-ti-yan/'
      tabindex="-14">  IDEA沉浸式编程体验</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-han-shu-shi-bian-cheng/'
      tabindex="-15">  Java函数式编程</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-ji-he-yuan-ma-qian-xi/'
      tabindex="-16">  Java集合源码浅析</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mysql-shi-wu-te-xing-yu-ge-chi-ji-bie-xiang-jie/'
      tabindex="-17">  MySQL_事务特性与隔离级别详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ocao-zuo-fu-shi-xian-mei-ju-de-shu-ru-shu-chu/'
      tabindex="-18">  O操作符,实现枚举的输入输出</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/prdsuan-fa-ting-shuo-ni-xiang-ping-yun-qi-chou-yi-ke-rong-yao-shui-jing/'
      tabindex="-19">  PRD算法：听说你想凭运气抽一颗荣耀水晶?</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/picgo-pei-zhi-ge-chong-tu-chuang/'
      tabindex="-20">  PicGo配置各种图床</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/redis-bi-zhi-bi-hui/'
      tabindex="-21">  Redis必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-zhong-de-move-yu-yi-sui-bi/'
      tabindex="-22">  Rust中的move语义随笔</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ssm-kuang-jia-shi-xian-ji-cheng-duan-xin-yan-zheng-ma-gong-neng/'
      tabindex="-23">  SSM框架实现集成短信验证码功能</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/slf4jyu-logbackshi-yong-zhi-nan-ji-yu-gradle/'
      tabindex="-24">  Slf4j与Logback实用指南(基于Gradle)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/spring-security5-xdao-spring-security6-xde-qian-yi/'
      tabindex="-25">  Spring Security5.x到Spring Security6.x的迁移</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springboot-webkai-fa-jing-jie/'
      tabindex="-26">  SpringBoot Web开发精解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springsecurity/'
      tabindex="-27">  SpringSecurity</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/unity6xia-jia-zhong-guo-qu-tuan-jie-yin-qing-jie-bang-zhe-shi-fen-lie-huan-shi-ben-di-hua-de-kai-shi/'
      tabindex="-28">  Unity6下架中国区，团结引擎接棒：这是分裂，还是本地化的开始？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-cong-0-dao-1-da-zao-quan-yu-yan-zhi-chi-de-mo-neng-bian-ji-qi-yu-fa-pian/'
      tabindex="-29">  Vim从0到1打造全语言支持的万能编辑器-语法篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-tiao-tou-powershell-pian/'
      tabindex="-30">  Vim折腾之 PowerShell篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-di-zhi-chuan-di-xiang-jie/'
      tabindex="-31">  [C++游戏开发基础]:地址传递详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-yin-yong-fan-hui-he-di-zhi-fan-hui/'
      tabindex="-32">  [C++游戏开发基础]:引用返回和地址返回</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-he-const/'
      tabindex="-33">  [C++游戏开发基础]:指针和const</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shu-ju-feng-zhuang-yin-cang-de-hao-chu/'
      tabindex="-34">  [C++游戏开发基础]:数据封装(隐藏)的好处</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-gou-zao-han-shu-qian-xi-8000zi/'
      tabindex="-35">  [C++游戏开发基础]:构造函数浅析(8000字)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-li-jie-kong-zhi-zhen/'
      tabindex="-36">  [C++游戏开发基础]:理解空指针</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-zhong-de-fang-wen-han-shu/'
      tabindex="-37">  [C++游戏开发基础]:类中的访问函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-de-ji-ben-gai-nian-li-jie/'
      tabindex="-38">  [C++游戏开发基础]指针的基本概念理解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/fanatical-wu-yue-feng-kuang-te-hui-wei-ni-de-steam-ku-jia-dian-liao/'
      tabindex="-39">  _Fanatical 五月疯狂特惠：为你的 Steam 库加点料！</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-kai-yuan-mi-ma-gong-ju-xpwd-zhong-wen-ban-bian-geng-ri-zhi/'
      tabindex="-40">  _Rust开源密码工具xpwd中文版变更日志</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/readme/'
      tabindex="-41">  readme</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wblog-bo-ke-xian-shang-bu-shu/'
      tabindex="-42">  wblog博客线上部署</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/shang-gu-shen-qi-vim-su-cheng-bei-wang-lu/'
      tabindex="-43">  上古神器_Vim速成备忘录</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mian-fei-ji-huo-quan-ban-ben-typora-zui-xin-ban-wei-li/'
      tabindex="-44">  免费激活全版本Typora，最新版为例</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-lombokxian-wei-ren-zhi-de-ji-ge-qi-ji-yin-qiao/'
      tabindex="-45">  关于Lombok鲜为人知的几个奇技淫巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-jie-kou-xian-liu-de-yi-ci-jian-dan-shi-jian/'
      tabindex="-46">  关于接口限流的一次简单实践</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/tu-jie-er-jin-zhi/'
      tabindex="-47">  图解二进制</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ru-he-xie-de-yi-shou-you-ya-gui-fan-de-springboot-jie-kou/'
      tabindex="-48">  如何写得一手优雅规范的SpringBoot 接口？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/kai-fa-bi-hui-xi-lie-jwtqian-tan/'
      tabindex="-49">  开发必会系列_JWT浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ji-qiao-jiu-shi-xiao-lu-chatgpt-diao-jiao-zhi-bei/'
      tabindex="-50">  技巧就是效率，ChatGPT调教指北</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-sheng-intellij-kai-fa-xiao-lu-zhe-kuan-dai-ma-tu-ding-cha-jian-codepins-zhi-de-yi-shi/'
      tabindex="-51">  提升 IntelliJ 开发效率？这款代码图钉插件 CodePins 值得一试</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-wen-de-zhi-hui-zhuan-zai/'
      tabindex="-52">  提问的智慧转载</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiao-lu-gong-ju-markdown/'
      tabindex="-53">  效率工具Markdown</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wu-wei-bing-fa-rust-sheng-ming-zhou-qi-qian-tan/'
      tabindex="-54">  无畏并发_Rust 生命周期浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-yu-de-bei-sai-er-qu-xian-gan-shou-si-hua-de-shu-xue-zhi-mei/'
      tabindex="-55">  游戏开发与的贝塞尔曲线_感受丝滑的数学之美</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-bi-bei-gao-xiao-de-aabb-qiu-ti-he-obb-peng-zhuang-jian-ce-suan-fa/'
      tabindex="-56">  游戏开发必备：高效的 AABB、球体和 OBB 碰撞检测算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-suan-fa-ji-chu-a-xun-lu-suan-fa-chi-xu-wei-hu/'
      tabindex="-57">  游戏算法基础-深入解析A*寻路算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/du-li-you-xi-kai-fa-zhe-gong-ju-xiang-2025jing-xuan-tui-jian-yu-shi-yong-zhi-nan/'
      tabindex="-58">  独立游戏开发者工具箱：2025精选推荐与实用指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xu-huan-yin-qing-you-xi-kai-fa-xi-lie-zhuan-ti-guan-fang-bian-ma-biao-zhun-huo-gui-yue/'
      tabindex="-59">  虚幻引擎游戏开发系列专题-官方编码标准或规约</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiang-jie-she-ji-mo-shi-dan-li-de-jin-hua-zhi-lu/'
      tabindex="-60">  详解设计模式_单例的进化之路</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xie-e-de-fei-chang-liang-quan-ju-bian-liang/'
      tabindex="-61">  邪恶的非常量全局变量</a></span>
  </li>
</ul>
</div>
      <div class="viewer page" id="viewer" tabindex="0">
        <div class="tab">
<div class="file-manager" onclick='document.getElementById("files").classList.toggle("open"); document.getElementById("content").classList.toggle("close")'> </div>
<ul id="tabs">
</ul>


</div>
        <div class="content" id="content"><p>考虑下面这样一个问题,假设我们正在编写一个程序,需要处理成对的<code>int</code>值.并且需要确定两个数字中的最大值。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include</span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">struct </span><span>Pair
</span><span>{
</span><span>  </span><span style="color:#b48ead;">int</span><span> first {};
</span><span>  </span><span style="color:#b48ead;">int</span><span> second {};
</span><span>
</span><span>};
</span><span>
</span><span style="color:#b48ead;">constexpr int </span><span style="color:#8fa1b3;">max</span><span>(Pair </span><span style="color:#bf616a;">p</span><span>)
</span><span>{
</span><span>  </span><span style="color:#b48ead;">return </span><span>(p.</span><span style="color:#bf616a;">first </span><span>&lt; p.</span><span style="color:#bf616a;">second </span><span>? p.</span><span style="color:#bf616a;">second </span><span>: p.</span><span style="color:#bf616a;">first</span><span>);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Pair </span><span style="color:#bf616a;">p1 </span><span>{</span><span style="color:#d08770;">2</span><span>,</span><span style="color:#d08770;">4</span><span>};
</span><span>    std::cout &lt;&lt;</span><span style="color:#bf616a;">max</span><span>(p1) &lt;&lt;&quot;</span><span style="color:#a3be8c;">is larger</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>后来.你那尊贵的狗策划需求一变,需要新增一个<code>double</code>类型的Pair,所以你的程序又改成下面这样;</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">struct </span><span>Pair
</span><span>{
</span><span>    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">first</span><span>{};
</span><span>    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">second</span><span>{};
</span><span>};
</span><span>
</span><span style="color:#b48ead;">struct </span><span>Pair 
</span><span>{
</span><span>    </span><span style="color:#b48ead;">double </span><span style="color:#bf616a;">first</span><span>{};
</span><span>    </span><span style="color:#b48ead;">double </span><span style="color:#bf616a;">second</span><span>{};
</span><span>};
</span><span>
</span><span style="color:#b48ead;">constexpr int </span><span style="color:#8fa1b3;">max</span><span>(Pair </span><span style="color:#bf616a;">p</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">return </span><span>(p.</span><span style="color:#bf616a;">first </span><span>&lt; p.</span><span style="color:#bf616a;">second </span><span>? p.</span><span style="color:#bf616a;">second </span><span>: p.</span><span style="color:#bf616a;">first</span><span>);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">constexpr double </span><span style="color:#8fa1b3;">max</span><span>(Pair </span><span style="color:#bf616a;">p</span><span>) 
</span><span>{
</span><span>    </span><span style="color:#b48ead;">return </span><span>(p.</span><span style="color:#bf616a;">first </span><span>&lt; p.</span><span style="color:#bf616a;">second </span><span>? p.</span><span style="color:#bf616a;">second </span><span>: p.</span><span style="color:#bf616a;">first</span><span>);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Pair </span><span style="color:#bf616a;">p1</span><span>{ </span><span style="color:#d08770;">5</span><span>, </span><span style="color:#d08770;">6 </span><span>};
</span><span>    std::cout &lt;&lt; </span><span style="color:#bf616a;">max</span><span>(p1) &lt;&lt; &quot;</span><span style="color:#a3be8c;"> is larger</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>
</span><span>    Pair </span><span style="color:#bf616a;">p2</span><span>{ </span><span style="color:#d08770;">1.2</span><span>, </span><span style="color:#d08770;">3.4 </span><span>};
</span><span>    std::cout &lt;&lt; </span><span style="color:#bf616a;">max</span><span>(p2) &lt;&lt; &quot;</span><span style="color:#a3be8c;"> is larger</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>这些代码看起来人畜无害,但其实存在问题:</p>
<ul>
<li>
<p>首先，与函数不同，类型定义不能被重载。编译器会将 Pair 的第二个定义视为对第一个 Pair 定义的错误性重新声明。</p>
</li>
<li>
<p>其次，尽管函数可以被重载，但这里的<code> max(Pair)</code> 函数仅在返回类型上有所不同，而函数重载不能仅通过返回类型来区分。</p>
</li>
<li>
<p>第三，这里存在大量的冗余。每个 <code>Pair</code> 结构体都是相同的（除了数据类型不同），而 <code>max(Pair)</code> 函数也是如此（除了返回类型不同）。</p>
</li>
</ul>
<p>基于这个问题,引出了本文的主题,类模版。</p>
<hr />
<h2 id="lei-mo-ban-ji-ben-ding-yi">类模版基本定义</h2>
<p>就像函数模板是用于实例化函数的模板定义一样，类模板是用于实例化类类型的模板定义。</p>
<blockquote>
<p>“类类型”指的是<code> struct、class</code> 或<code> union</code> 类型。尽管我们为了简单起见会在 <code>struct</code> 上演示“类模板”，但这里的内容同样适用于 <code>class</code>。</p>
</blockquote>
<p>现在我们将上面第一个示例代码改写为类模版的形式:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include</span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">template</span><span>&lt;</span><span style="color:#b48ead;">typename</span><span> T&gt;
</span><span style="color:#b48ead;">struct </span><span>Pair
</span><span>{
</span><span>    T first {};
</span><span>    T second {};
</span><span>};
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Pair&lt;</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">p1 </span><span>{</span><span style="color:#d08770;">4</span><span>,</span><span style="color:#d08770;">6</span><span>};
</span><span>    std::cout &lt;&lt;p1.</span><span style="color:#bf616a;">first </span><span>&lt;&lt;&#39; &#39; &lt;&lt; p1.</span><span style="color:#bf616a;">second </span><span>&lt;&lt;&#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>    Pair&lt;</span><span style="color:#b48ead;">double</span><span>&gt; </span><span style="color:#bf616a;">p2 </span><span>{</span><span style="color:#d08770;">3.2</span><span>,</span><span style="color:#d08770;">5.4</span><span>};
</span><span>    std::cout &lt;&lt;p2.</span><span style="color:#bf616a;">first </span><span>&lt;&lt;&#39; &#39; &lt;&lt; p2.</span><span style="color:#bf616a;">second </span><span>&lt;&lt;&#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span><span>
</span></code></pre>
<p>就像函数模版一样,我们用以模版参数声明开始类模版的定义。接下来在<code>&lt;&gt;</code>内指定模版将使用的所有模版类型。对于我们需要的每个模板类型，使用关键字 <code>typename</code>（首选）或 <code>class</code>，后跟模板类型的名称（例如 <code>T</code>）。在这种情况下，由于我们的两个成员将是相同的类型，我们只需要一个模板类型。”</p>
<p>在<code>main</code>中，我们可以使用我们想要的任何类型来实例化<code>Pair</code>对象。首先，实例化一<code>个Pair&lt;int&gt;</code>类型的对象。由于<code>Pair&lt;int&gt;</code>的类型定义尚不存在，因此编译器使用类模板实例化名为<code>Pair&lt;int&gt;</code>的结构类型定义，其中模板类型<code>T</code>的所有出现都被类型<code>int</code>替换。其他类型同理。</p>
<hr />
<h2 id="zai-han-shu-zhong-shi-yong-lei-mo-ban">在函数中使用类模版</h2>
<p>对于之前的<code>max</code>函数,由于编译器会将<code>Pair&lt;int&gt;</code>,<code>Pair&lt;double&gt;</code>视为单独的类型,因此我们可以按照参数类型的区分,对该函数进行重载。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">constexpr int </span><span style="color:#8fa1b3;">max</span><span>(Pair&lt;</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">p</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">return </span><span>(p.</span><span style="color:#bf616a;">first </span><span>&lt; p.</span><span style="color:#bf616a;">second</span><span>) ? p.</span><span style="color:#bf616a;">second </span><span>: p.</span><span style="color:#bf616a;">first</span><span style="background-color:#bf616a;color:#2b303b;">)</span><span>;
</span><span>}
</span><span>
</span><span style="color:#b48ead;">constexpr double </span><span style="color:#8fa1b3;">max</span><span>(Pair&lt;</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">p</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">return </span><span>(p.</span><span style="color:#bf616a;">first </span><span>&lt; p.</span><span style="color:#bf616a;">second</span><span>) ? p.</span><span style="color:#bf616a;">second </span><span>: p.</span><span style="color:#bf616a;">first</span><span style="background-color:#bf616a;color:#2b303b;">)</span><span>;
</span><span>}
</span></code></pre>
<p>虽然可以正常编译,但是这样并没有解决代码冗余的问题。我们真正想要的是一个可以接受任何类型的函数。换句话说,我们需要一个接受<code>Pair&lt;T&gt;</code>类型参数的函数。其中的<code>T</code>是模版类型参数。所以暗示的够明显了吧,我们需要一个函数模版来解决这个问题。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include</span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">template</span><span>&lt;</span><span style="color:#b48ead;">typename</span><span> T&gt;
</span><span style="color:#b48ead;">struct </span><span>Pair
</span><span>{
</span><span>    T first {};
</span><span>    T second {};
</span><span>};
</span><span>
</span><span style="color:#b48ead;">template </span><span>&lt;</span><span style="color:#b48ead;">typename</span><span> T&gt;
</span><span style="color:#b48ead;">constexpr</span><span> T </span><span style="color:#8fa1b3;">max</span><span>(Pair&lt;T&gt; </span><span style="color:#bf616a;">p</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">return </span><span>(p.</span><span style="color:#bf616a;">first </span><span>&lt; p.</span><span style="color:#bf616a;">second </span><span>? p.</span><span style="color:#bf616a;">second </span><span>: p.</span><span style="color:#bf616a;">first</span><span>);
</span><span>}
</span><span>
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Pair&lt;</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">p1 </span><span>{</span><span style="color:#d08770;">2</span><span>,</span><span style="color:#d08770;">4</span><span>};
</span><span>    std::cout &lt;&lt; </span><span style="color:#bf616a;">max</span><span>&lt;</span><span style="color:#b48ead;">int</span><span>&gt;(p1) &lt;&lt;&quot;</span><span style="color:#a3be8c;">is larger</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>
</span><span>    Pair&lt;</span><span style="color:#b48ead;">double</span><span>&gt; </span><span style="color:#bf616a;">p2 </span><span>{</span><span style="color:#d08770;">3.5</span><span>, </span><span style="color:#d08770;">2.5</span><span>};
</span><span>    std::cout &lt;&lt; </span><span style="color:#bf616a;">max</span><span>(p2) &lt;&lt; &quot;</span><span style="color:#a3be8c;">is larger</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p><code>max()</code> 函数模板的逻辑非常直观。由于我们希望传入一个 <code>Pair&lt;T&gt;</code>，我们需要让编译器知道 T 的具体类型。因此，我们需要在函数前面添加 <strong>模板参数声明</strong>，用于定义模板类型 T。</p>
<p>这样，我们就可以在返回类型和 <code>Pair&lt;T&gt;</code> 的模板类型中使用 <code>T</code>，从而使 <code>max()</code> 适用于不同的数据类型。</p>
<p>当<code>max（）</code>函数用<code>Pair&lt;int&gt;</code>参数调用时，编译器将从函数模板实例化函数<code>int max&lt;int&gt;（Pair&lt;int&gt;）</code>，其中模板类型<code>T</code>被替换为<code>int</code>。下面的代码片段显示了在这种情况下编译器实际实例化的内容：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">template </span><span>&lt;&gt;
</span><span style="color:#b48ead;">constexpr int </span><span style="color:#8fa1b3;">max</span><span>(Pair&lt;</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">p</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">return </span><span>(p.</span><span style="color:#bf616a;">first </span><span>&lt; p.</span><span style="color:#bf616a;">second </span><span>? p.</span><span style="color:#bf616a;">second </span><span>: p.</span><span style="color:#bf616a;">first</span><span>);
</span><span>}
</span></code></pre>
<blockquote>
<p>与所有对函数模板的调用一样，我们可以显式地使用模板类型参数（例如<code>max&lt;int&gt;（p1）</code>），也可以隐式地使用（例如<code>max（p2）</code>），让编译器使用模板参数推导来确定模板类型参数应该是什么。</p>
</blockquote>
<hr />
<h2 id="ju-you-mo-ban-lei-xing-cheng-yuan-he-fei-mo-ban-lei-xing-cheng-yuan-de-lei-mo-ban">具有模板类型成员和非模板类型成员的类模板</h2>
<p>在 <strong>类模板（class templates）</strong> 中，我们不仅可以使用<strong>模板类型参数（template type parameter）</strong>，还可以包含<strong>非模板类型成员（non-template type members）</strong>。这意味着，类中的某些成员可以是通用类型（由模板参数决定），而其他成员可以是固定类型（例如 int、double 等）。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">template</span><span>&lt;</span><span style="color:#b48ead;">typename</span><span> T&gt;
</span><span style="color:#b48ead;">struct </span><span>Foo
</span><span>{
</span><span>  T first {}; </span><span style="color:#65737e;">// 模版类型
</span><span>  </span><span style="color:#b48ead;">int</span><span> second {}; </span><span style="color:#65737e;">// 非模版类型
</span><span>}
</span></code></pre>
<p>类模版也可以有多个模版类型,例如,如果我们希望<code>Pair</code>类的两个成员能够有不同的类型,我们可以用脸肿莫办类型来定义这个类模版。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">template </span><span>&lt;</span><span style="color:#b48ead;">typename</span><span> T, </span><span style="color:#b48ead;">typename</span><span> U&gt;
</span><span style="color:#b48ead;">struct </span><span>Pair
</span><span>{
</span><span>    T </span><span style="color:#bf616a;">first</span><span>{};
</span><span>    U </span><span style="color:#bf616a;">second</span><span>{};
</span><span>};
</span><span>
</span><span style="color:#b48ead;">template </span><span>&lt;</span><span style="color:#b48ead;">typename</span><span> T, </span><span style="color:#b48ead;">typename</span><span> U&gt;
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span>(Pair&lt;T, U&gt; </span><span style="color:#bf616a;">p</span><span>)
</span><span>{
</span><span>    std::cout &lt;&lt; &#39;</span><span style="color:#a3be8c;">[</span><span>&#39; &lt;&lt; p.</span><span style="color:#bf616a;">first </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">, </span><span>&quot; &lt;&lt; p.</span><span style="color:#bf616a;">second </span><span>&lt;&lt; &#39;</span><span style="color:#a3be8c;">]</span><span>&#39;;
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Pair&lt;</span><span style="color:#b48ead;">int</span><span>, </span><span style="color:#b48ead;">double</span><span>&gt; </span><span style="color:#bf616a;">p1</span><span>{ </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2.3 </span><span>}; 
</span><span>    Pair&lt;</span><span style="color:#b48ead;">double</span><span>, </span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">p2</span><span>{ </span><span style="color:#d08770;">4.5</span><span>, </span><span style="color:#d08770;">6 </span><span>}; 
</span><span>    Pair&lt;</span><span style="color:#b48ead;">int</span><span>, </span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">p3</span><span>{ </span><span style="color:#d08770;">7</span><span>, </span><span style="color:#d08770;">8 </span><span>};      
</span><span>
</span><span>    </span><span style="color:#bf616a;">print</span><span>(p2);
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>为了定义多个模版类型,在模版参数声明中,我们用逗号分隔每一个所需类型。在上面的例子中,定义了两个不同的模版类型,分别为<code>T</code>和<code>U</code>,在实际使用时,两个模版类型我们可以随意安排,比如两个不同类型或者两个相同类型都是被允许的。</p>
<hr />
<h2 id="mo-ban-han-shu-he-duo-ge-lei-lei-xing">模版函数和多个类类型</h2>
<p>对于上面的例子,因为我们已经将函数参数显式定义为<code>Pair&lt;T，U&gt;</code>，所以只有<code>Pair&lt;T，U&gt;</code>类型的参数（或那些可以转换为<code>Pair&lt;T，U&gt;的</code>参数）才会匹配。如果我们只希望能够使用<code>Pair&lt;T，U&gt;</code>参数调用函数，这是没问题的。</p>
<p>但是在某些情况下,我们希望可以编写一个可以与任何类型一起使用的函数模版,只需要使用类型模版参数作为函数参数即可。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include</span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">template</span><span>&lt;</span><span style="color:#b48ead;">typename</span><span> T,</span><span style="color:#b48ead;">typename</span><span> U&gt;
</span><span style="color:#b48ead;">struct </span><span>Pair
</span><span>{
</span><span>    T first {};
</span><span>    U second {};
</span><span>};
</span><span>
</span><span style="color:#b48ead;">struct </span><span>Point
</span><span>{
</span><span>    </span><span style="color:#b48ead;">int</span><span> first {};
</span><span>    </span><span style="color:#b48ead;">int</span><span> second {};
</span><span>};
</span><span>
</span><span>
</span><span style="color:#b48ead;">template</span><span>&lt;</span><span style="color:#b48ead;">typename</span><span> T&gt;
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span>(T </span><span style="color:#bf616a;">p</span><span>)
</span><span>{
</span><span>    std::cout &lt;&lt; p.</span><span style="color:#bf616a;">first </span><span>&lt;&lt;&quot;</span><span style="color:#a3be8c;">, </span><span>&quot; &lt;&lt; p.</span><span style="color:#bf616a;">second </span><span>&lt;&lt; &quot;</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>}
</span><span>
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>
</span><span>    Pair&lt;</span><span style="color:#b48ead;">double</span><span>, </span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">p1</span><span>{ </span><span style="color:#d08770;">4.5</span><span>, </span><span style="color:#d08770;">6 </span><span>};
</span><span>    </span><span style="color:#bf616a;">print</span><span>(p1); </span><span style="color:#65737e;">// 匹配 print(Pair&lt;double, int&gt;)
</span><span>    std::cout &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>    Point </span><span style="color:#bf616a;">p2 </span><span>{ </span><span style="color:#d08770;">7</span><span>, </span><span style="color:#d08770;">8 </span><span>};
</span><span>    </span><span style="color:#bf616a;">print</span><span>(p2); </span><span style="color:#65737e;">// 匹配 print(Point)
</span><span>    std::cout &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span><span>
</span></code></pre>
<p>在上面的例子中，我们重写了<code>print（）</code>，使它只有一个类型模板参数（<code>T</code>），它将匹配任何类型。对于任何具有<code>第一</code>个和<code>第二个</code>成员的类类型，函数体都将成功编译。</p>
<hr />
<h2 id="biao-zhun-ku-zhong-de-std-pair">标准库中的std::pair</h2>
<p>在C++标准库中包含了一个名为<code>std::pair</code>的类模版,它的定义与上面我们自己实现的原理相似,所以我们完全可以使用标准库提供的方法替换掉我们自己的实现。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">utility</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">template </span><span>&lt;</span><span style="color:#b48ead;">typename</span><span> T,</span><span style="color:#b48ead;">typename</span><span> U&gt;
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span>(std::pair&lt;T,U&gt; </span><span style="color:#bf616a;">p</span><span>)
</span><span>{
</span><span>    std::cout &lt;&lt;&#39;</span><span style="color:#a3be8c;">[</span><span>&#39; &lt;&lt; p.</span><span style="color:#bf616a;">first </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">, </span><span>&quot; &lt;&lt; p.</span><span style="color:#bf616a;">second </span><span>&lt;&lt; &#39;</span><span style="color:#a3be8c;">]</span><span>&#39;;
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    std::pair&lt;</span><span style="color:#b48ead;">int</span><span>,</span><span style="color:#b48ead;">double</span><span>&gt; </span><span style="color:#bf616a;">p1 </span><span>{</span><span style="color:#d08770;">1</span><span>,</span><span style="color:#d08770;">3.0</span><span>};
</span><span>    std::pair&lt;</span><span style="color:#b48ead;">double</span><span>,</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">p2 </span><span>{</span><span style="color:#d08770;">4.3</span><span>,</span><span style="color:#d08770;">2</span><span>};
</span><span>    std::pair&lt;</span><span style="color:#b48ead;">int</span><span>,</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">p3 </span><span>{</span><span style="color:#d08770;">2</span><span>,</span><span style="color:#d08770;">2</span><span>};
</span><span>    std::pair&lt;</span><span style="color:#b48ead;">float</span><span>,</span><span style="color:#b48ead;">double</span><span>&gt; </span><span style="color:#bf616a;">p4 </span><span>{</span><span style="color:#d08770;">3.14</span><span>,</span><span style="color:#d08770;">2.71</span><span>};
</span><span>
</span><span>    </span><span style="color:#bf616a;">print</span><span>(p1);
</span><span>    </span><span style="color:#bf616a;">print</span><span>(p2);
</span><span>    </span><span style="color:#bf616a;">print</span><span>(p3);
</span><span>    </span><span style="color:#bf616a;">print</span><span>(p4);
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span><span>
</span></code></pre>
<blockquote>
<p>在实际开发中,一般建议直接使用标准库定义的<code>pair</code>而不是自己重新实现,除非标准库的实现无法满足需求。</p>
</blockquote>
<hr />
<h2 id="zai-duo-ge-wen-jian-zhong-shi-yong-lei-mo-ban">在多个文件中使用类模版</h2>
<p>就像函数模版一样,类模版通常定义在头文件中,因此他们可以在任何需要他们的代码文件中,模版定义和类型定义都不受 <strong>ORD</strong>原则的限制。</p>
<ul>
<li>pair.h</li>
</ul>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#ifndef</span><span> PAIR_H
</span><span style="color:#b48ead;">#define </span><span>PAIR_H
</span><span>
</span><span style="color:#b48ead;">template </span><span>&lt;</span><span style="color:#b48ead;">typename</span><span> T&gt;
</span><span style="color:#b48ead;">struct </span><span>Pair 
</span><span>{
</span><span>    T first;
</span><span>    T second;
</span><span>};
</span><span style="color:#b48ead;">template </span><span>&lt;</span><span style="color:#b48ead;">typename</span><span> T&gt;
</span><span style="color:#b48ead;">constexpr</span><span> T  </span><span style="color:#8fa1b3;">max</span><span>(Pair&lt;T&gt; </span><span style="color:#bf616a;">p</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">return</span><span> p.</span><span style="color:#bf616a;">first </span><span>&gt; p.</span><span style="color:#bf616a;">second </span><span>? p.</span><span style="color:#bf616a;">first </span><span>: p.</span><span style="color:#bf616a;">second</span><span>;
</span><span>}
</span><span>
</span><span style="color:#b48ead;">#endif </span><span style="color:#65737e;">// PAIR_H
</span></code></pre>
<ul>
<li>foo.cpp</li>
</ul>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&quot;</span><span style="color:#a3be8c;">pair.h</span><span>&quot;
</span><span style="color:#b48ead;">#include</span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">foo</span><span>()
</span><span>{
</span><span>    Pair&lt;</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">p1</span><span>{</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>};
</span><span>    std::cout &lt;&lt; </span><span style="color:#bf616a;">max</span><span>(p1) &lt;&lt; &quot;</span><span style="color:#a3be8c;">is large</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>}
</span><span>
</span></code></pre>
<ul>
<li>main.cpp</li>
</ul>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include</span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&quot;</span><span style="color:#a3be8c;">pair.h</span><span>&quot;
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">foo</span><span>();
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Pair&lt;</span><span style="color:#b48ead;">double</span><span>&gt; </span><span style="color:#bf616a;">p2 </span><span>{</span><span style="color:#d08770;">1.0</span><span>, </span><span style="color:#d08770;">2.0</span><span>};
</span><span>    std::cout &lt;&lt;</span><span style="color:#bf616a;">max</span><span>(p2)&lt;&lt;&quot;</span><span style="color:#a3be8c;">is larger</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>    
</span><span>    </span><span style="color:#bf616a;">foo</span><span>();
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>对于上面的程序,如果你是使用命令单独编译的情况下,在编译<code>main.cpp</code>的同时务必记得编译<code>foo.cpp</code></p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>g++ -std=c++</span><span style="color:#d08770;">17 </span><span>-o main main.</span><span style="color:#bf616a;">cpp</span><span> foo.</span><span style="color:#bf616a;">cpp
</span></code></pre>
<hr />
<h2 id="mo-ban-can-shu-tui-dao">模版参数推导</h2>
<p>从C++17开始,当从类模版实例化一个对象时,编译器可以从对象的初始化器的类型推导出模版类型,这称为 <strong>模版类型推导</strong>或者简称<code>CTAD.</code></p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include</span><span>&lt;</span><span style="color:#a3be8c;">utility</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>  std::pair&lt;</span><span style="color:#b48ead;">int</span><span>,</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">p1 </span><span>{</span><span style="color:#d08770;">1</span><span>,</span><span style="color:#d08770;">2</span><span>};
</span><span>  std::pair </span><span style="color:#bf616a;">p2 </span><span>{</span><span style="color:#d08770;">1</span><span>,</span><span style="color:#d08770;">2</span><span>}; </span><span style="color:#65737e;">// 这里用到了C++17的自动模版类型推导,不需要显式的声明
</span><span>  
</span><span>  </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>值得注意的是,这样的推导是有条件的,只有在没有显式声明模版参数的情况下才会执行。所以,下面两种方式是错误示范:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include</span><span>&lt;</span><span style="color:#a3be8c;">utility</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>  std::pair&lt;&gt; </span><span style="color:#bf616a;">p1 </span><span>{</span><span style="color:#d08770;">1</span><span>,</span><span style="color:#d08770;">2</span><span>};  </span><span style="color:#65737e;">// 模板参数太少，两个参数均未推导
</span><span>  std::pair&lt;</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">p2 </span><span>{</span><span style="color:#d08770;">3</span><span>,</span><span style="color:#d08770;">4</span><span>}; </span><span style="color:#65737e;">// 模板参数太少，第二个参数未推导
</span><span>  
</span><span>  </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>由于 CTAD（类模板参数推导）是一种类型推导的形式，我们可以使用 <strong>字面量后缀</strong> 来改变推导出的类型：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">utility</span><span>&gt; 
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    std::pair </span><span style="color:#bf616a;">p1 </span><span>{ </span><span style="color:#d08770;">3.4</span><span style="color:#b48ead;">f</span><span>, </span><span style="color:#d08770;">5.6</span><span style="color:#b48ead;">f </span><span>}; </span><span style="color:#65737e;">// 推导为 pair&lt;float, float&gt;
</span><span>    std::pair </span><span style="color:#bf616a;">p2 </span><span>{ </span><span style="color:#d08770;">1</span><span style="color:#b48ead;">u</span><span>, </span><span style="color:#d08770;">2</span><span style="color:#b48ead;">u </span><span>};     </span><span style="color:#65737e;">// 推导为 pair&lt;unsigned int, unsigned int&gt;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>大多数情况下,<code>CTAD</code>可以开箱即用,但是在某些情况下,编译器可能需要一些额外的帮助来理解如何正确推导模版参数。</p>
<p>比如下面的程序,如果你在C++17环境下编译,是无法正常编译成功的。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include</span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include</span><span>&lt;</span><span style="color:#a3be8c;">utility</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">template</span><span>&lt;</span><span style="color:#b48ead;">typename</span><span> T,</span><span style="color:#b48ead;">typename</span><span> U&gt;
</span><span style="color:#b48ead;">struct </span><span>Pair
</span><span>{
</span><span>    T first {};
</span><span>    U second {};
</span><span>};
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Pair&lt;</span><span style="color:#b48ead;">int</span><span>,</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">p1 </span><span>{</span><span style="color:#d08770;">1</span><span>,</span><span style="color:#d08770;">2</span><span>};
</span><span>    Pair </span><span style="color:#bf616a;">p2 </span><span>{</span><span style="color:#d08770;">2</span><span>,</span><span style="color:#d08770;">3</span><span>};
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>比如,我尝试编译这段代码时,就遇到了下面这样的错误提示:</p>
<p><img src="https://images.waer.ltd/notes/202503161556985.png" alt="image-20250316155611729" loading="lazy" decoding="async" /></p>
<p>这是因为在C++17中,它不知道如何推导聚合类型的类模版参数,为了解决这个问题,我们需要手动的给编译器提供一个推导指南,它会告诉编译器如何推导给定类模版的模版参数:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include</span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include</span><span>&lt;</span><span style="color:#a3be8c;">utility</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">template</span><span>&lt;</span><span style="color:#b48ead;">typename</span><span> T,</span><span style="color:#b48ead;">typename</span><span> U&gt;
</span><span style="color:#b48ead;">struct </span><span>Pair
</span><span>{
</span><span>    T first {};
</span><span>    U second {};
</span><span>};
</span><span>
</span><span style="color:#65737e;">// 推导指南
</span><span style="color:#b48ead;">template</span><span>&lt;</span><span style="color:#b48ead;">typename</span><span> T,</span><span style="color:#b48ead;">typename</span><span> U&gt;
</span><span style="color:#bf616a;">Pair</span><span>(T,U) -&gt; </span><span style="color:#bf616a;">Pair</span><span>&lt;T,U&gt;;
</span><span>
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Pair&lt;</span><span style="color:#b48ead;">int</span><span>,</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">p1 </span><span>{</span><span style="color:#d08770;">1</span><span>,</span><span style="color:#d08770;">2</span><span>};
</span><span>    Pair </span><span style="color:#bf616a;">p2 </span><span>{</span><span style="color:#d08770;">2</span><span>,</span><span style="color:#d08770;">3</span><span>};
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span><span>
</span></code></pre>
<p>关键的代码就两行:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">template</span><span>&lt;</span><span style="color:#b48ead;">typename</span><span> T,</span><span style="color:#b48ead;">typename</span><span> U&gt;
</span><span style="color:#bf616a;">Pair</span><span>(T,U) -&gt; </span><span style="color:#bf616a;">Pair</span><span>&lt;T,U&gt;;
</span></code></pre>
<ul>
<li>
<p>首先，我们使用与 <code>Pair</code> 类中相同的模板类型定义。这是合理的，因为如果我们的 <strong>推导指引（deduction guide）</strong> 要告诉编译器如何为 <code>Pair&lt;T, U&gt;</code> 推导类型，我们必须定义 <code>T</code> 和<code> U</code>（即模板类型）。</p>
</li>
<li>
<p>其次，在箭头 <code>-&gt;</code> 右侧，我们指定了希望帮助编译器推导出的类型。在本例中，我们希望编译器能够推导出 <code>Pair&lt;T, U&gt;</code> 类型的模板参数，因此这里直接写 <code>Pair&lt;T, U&gt;</code>。</p>
</li>
<li>
<p>最后，在箭头<code> -&gt;</code> 左侧，我们告诉编译器要寻找哪种形式的声明。在本例中，我们指定了 <code>Pair</code> 对象的声明，且它接受两个参数（一个是 <code>T</code> 类型，另一个是 <code>U</code> 类型）。我们也可以写成 <code>Pair(T t, U u)</code>，其中 <code>t</code> 和<code> u</code> 是参数的名称，但由于在推导过程中不需要使用它们，因此可以省略名称。</p>
</li>
</ul>
<p>把所有这些放在一起，我们告诉编译器，如果它看到一个带有两个参数（分别是<code>T</code>和<code>U</code>类型）的<code>Pair</code>声明，它应该推断类型为<code>Pair&lt;T，U&gt;</code>。</p>
<p>再看一个类似的例子:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#65737e;">// 定义一个模板结构体 Pair，表示一对数据
</span><span style="color:#b48ead;">template </span><span>&lt;</span><span style="color:#b48ead;">typename</span><span> T&gt;
</span><span style="color:#b48ead;">struct </span><span>Pair
</span><span>{
</span><span>    T </span><span style="color:#bf616a;">first</span><span>{};  </span><span style="color:#65737e;">// 第一个值
</span><span>    T </span><span style="color:#bf616a;">second</span><span>{}; </span><span style="color:#65737e;">// 第二个值
</span><span>};
</span><span>
</span><span style="color:#65737e;">// 这是 `Pair` 的一个推导指引（仅在 C++17 及以上版本需要）
</span><span style="color:#65737e;">// 当 `Pair` 对象用两个 `T` 类型的参数初始化时，推导结果应为 `Pair&lt;T&gt;`
</span><span style="color:#b48ead;">template </span><span>&lt;</span><span style="color:#b48ead;">typename</span><span> T&gt;
</span><span style="color:#bf616a;">Pair</span><span>(T, T) -&gt; </span><span style="color:#bf616a;">Pair</span><span>&lt;T&gt;;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Pair&lt;</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">p1</span><span>{ </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2 </span><span>}; </span><span style="color:#65737e;">// 显式指定类模板 `Pair&lt;int&gt;`（适用于 C++11 及更高版本）
</span><span>    Pair </span><span style="color:#bf616a;">p2</span><span>{ </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2 </span><span>};      </span><span style="color:#65737e;">// 使用类模板参数推导（CTAD），从初始化参数推导 `Pair&lt;int&gt;`（C++17）
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p><code>Pair(T, T) -&gt; Pair&lt;T&gt;;</code>告诉编译器，当 <code>Pair</code> 通过两个相同类型 T 的参数初始化时，<code>Pair&lt;T&gt;</code> 应该被推导出来。</p>
<p>例如 <code>Pair p2{1, 2}</code>;，编译器会自动推导 <code>T=int</code>，最终等价于<code> Pair&lt;int&gt; p2{1, 2};</code>。</p>
<hr />
<h2 id="">带默认值的类型模板参数</h2>
<p>就像函数参数可以有默认参数一样，模板参数也可以有默认值。当模板参数没有明确指定并且无法推导时，将使用这些参数。</p>
<p>下面是对上面的<code>Pair&lt;T，U&gt;</code>类模板程序的修改，类型模板参数<code>T</code>和<code>U</code>默认为<code>int</code>类型：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#65737e;">// 定义一个模板结构体 Pair，T 和 U 默认类型为 int
</span><span style="color:#b48ead;">template </span><span>&lt;</span><span style="color:#b48ead;">typename</span><span> T = </span><span style="color:#b48ead;">int</span><span>, </span><span style="color:#b48ead;">typename</span><span> U = </span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#65737e;">// 默认 T 和 U 都是 int 类型
</span><span style="color:#b48ead;">struct </span><span>Pair
</span><span>{
</span><span>    T </span><span style="color:#bf616a;">first</span><span>{};  </span><span style="color:#65737e;">// 第一个值
</span><span>    U </span><span style="color:#bf616a;">second</span><span>{}; </span><span style="color:#65737e;">// 第二个值
</span><span>};
</span><span>
</span><span style="color:#65737e;">// 推导指引，帮助编译器推导 Pair(T, U) -&gt; Pair&lt;T, U&gt;
</span><span style="color:#b48ead;">template </span><span>&lt;</span><span style="color:#b48ead;">typename</span><span> T, </span><span style="color:#b48ead;">typename</span><span> U&gt;
</span><span style="color:#bf616a;">Pair</span><span>(T, U) -&gt; </span><span style="color:#bf616a;">Pair</span><span>&lt;T, U&gt;;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Pair&lt;</span><span style="color:#b48ead;">int</span><span>, </span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">p1</span><span>{ </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2 </span><span>}; </span><span style="color:#65737e;">// 显式指定类模板 `Pair&lt;int, int&gt;`（C++11 及以上）
</span><span>    Pair </span><span style="color:#bf616a;">p2</span><span>{ </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2 </span><span>};           </span><span style="color:#65737e;">// 使用 CTAD 推导 `Pair&lt;int, int&gt;`（C++17）
</span><span>
</span><span>    Pair p3;                   </span><span style="color:#65737e;">// 使用默认模板参数 `Pair&lt;int, int&gt;`
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>我们对<code>p3的</code>定义没有显式地指定类型模板参数的类型，也没有从这些类型推导出的初始化器。因此，编译器将使用默认值中指定的类型，这意味<code>着p3</code>将是<code>Pair&lt;int，int&gt;</code>类型。</p>
<hr />
<p>当使用<strong>非静态成员初始化</strong>（non-static member initialization）来初始化类类型的成员时，<strong>类模板参数推导（CTAD）</strong> 在这种情况下不会生效。所有的模板参数必须<strong>显式指定</strong>。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">utility</span><span>&gt; </span><span style="color:#65737e;">// for std::pair
</span><span>
</span><span style="color:#b48ead;">struct </span><span>Foo
</span><span>{
</span><span>    std::pair&lt;</span><span style="color:#b48ead;">int</span><span>, </span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">p1</span><span>{ </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2 </span><span>}; </span><span style="color:#65737e;">// ✅ OK，显式指定模板参数
</span><span>    std::pair </span><span style="color:#bf616a;">p2</span><span>{ </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2 </span><span>};           </span><span style="color:#65737e;">// ❌ 编译错误，CTAD 在非静态成员初始化时不可用
</span><span>};
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    std::pair </span><span style="color:#bf616a;">p3</span><span>{ </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2 </span><span>};           </span><span style="color:#65737e;">// ✅ OK，CTAD 在此处可以使用
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p><strong>为什么 CTAD 不能用于非静态成员初始化？</strong></p>
<ul>
<li>非静态成员初始化是在<strong>类定义时</strong>解析的，而 <code>CTAD</code> 需要在对象实际创建时推导类型，两者的时机不同。</li>
<li>在 <code>Foo</code> 定义时，编译器必须确定 <code>p2</code> 的完整类型（包括模板参数）。如果没有显式指定模板参数，编译器无法在类定义阶段进行推导。</li>
<li><code>CTAD</code> 主要用于变量初始化（如 <code>std::pair p{1, 2};</code>），而非静态成员初始化并不会直接调用 <code>CTAD</code> 规则。</li>
</ul>
<hr />
<blockquote>
<p><code>CTAD</code> 代表“类模板实参推导”（<code>Class Template Argument Deduction</code>），而不是“类模板参数推导”（<code>Class Template Parameter Deduction</code>），因此它只会推导模板的实参类型，而不会推导模板的参数。</p>
</blockquote>
<p><strong>CTAD 只能在变量定义时生效</strong>，但不能用于函数参数类型推导。因此,不能在函数中使用<code>CTAD</code>:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">utility</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span>(std::pair </span><span style="color:#bf616a;">p</span><span>) </span><span style="color:#65737e;">// ❌ 编译错误：CTAD 不能用于函数参数
</span><span>{
</span><span>    std::cout &lt;&lt; p.</span><span style="color:#bf616a;">first </span><span>&lt;&lt; &#39; &#39; &lt;&lt; p.</span><span style="color:#bf616a;">second </span><span>&lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    std::pair </span><span style="color:#bf616a;">p </span><span>{ </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2 </span><span>}; </span><span style="color:#65737e;">// ✅ CTAD 在变量声明时有效，推导为 std::pair&lt;int, int&gt;
</span><span>    </span><span style="color:#bf616a;">print</span><span>(p); </span><span style="color:#65737e;">// ❌ 编译错误
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>在这种情况下，应该使用模板来实现:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">utility</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">template </span><span>&lt;</span><span style="color:#b48ead;">typename</span><span> T, </span><span style="color:#b48ead;">typename</span><span> U&gt;
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span>(std::pair&lt;T, U&gt; </span><span style="color:#bf616a;">p</span><span>)
</span><span>{
</span><span>    std::cout &lt;&lt; p.</span><span style="color:#bf616a;">first </span><span>&lt;&lt; &#39; &#39; &lt;&lt; p.</span><span style="color:#bf616a;">second </span><span>&lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    std::pair </span><span style="color:#bf616a;">p </span><span>{ </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2 </span><span>}; </span><span style="color:#65737e;">// 推导为 std::pair&lt;int, int&gt;
</span><span>    </span><span style="color:#bf616a;">print</span><span>(p);
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>

        </div>
      </div>
      <div class="prompt" id="terminal"><input
    type="text"
    id="setter"
    onkeydown="writeit(this, event);moveIt(this.value.length, event)"
    onchange="writeit(this, event)"
    onkeyup="writeit(this, event)"
    onkeypress="writeit(this, event);"
    >
<label for="setter" id="writer"> </label><b class="cursor" id="cursor"></b></div>
      <footer class="footer">
        <div class="footer-content">
          <p class="icp-info">
            <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer">黔ICP备2021010295号</a>
          </p>
        </div>
      </footer>
    </main>
  </body>

</html>
