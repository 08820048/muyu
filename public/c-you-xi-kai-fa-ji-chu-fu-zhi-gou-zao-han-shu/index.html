<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>慕予博客</title>
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"
    integrity="sha256-WCzAhd2P6gRJF9Hv3oOOd+hFJi/QJbv+Azn4CGB8gfY=" crossorigin="anonymous" defer></script>
  <script src="/js/index.js" defer></script>
  <script src="/js/prompt.js" defer></script>
  <script src="/js/keyboard.js" defer></script>
  <script src="/js/tab.js" defer></script>
  <script src="/js/commands.js" defer></script>
  <script src="/js/config.js" defer></script><script src="/config.js"></script><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="style.css"><link rel="stylesheet" href="/css/page.css"></head><body onkeydown='exec(event)' style='background-image: url("/assets/background.jpg");'><main>
      <div class="files" id="files" tabindex="0">
<ul>

  <li class="file">
    <span><a href='https://ilikexff.cn/8-kuan-rang-ni-kai-fa-qi-fei-de-intellijidea-cha-jian/'
      tabindex="-2">  8款让你开发起飞的IntellijIDEA插件</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/aop-jie-mi-qie-mian-bian-cheng-de-zong-he-zhi-nan/'
      tabindex="-3">  AOP揭秘：切面编程的综合指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-mei-ju-pian-yi-wu-fan-wei-mei-ju/'
      tabindex="-4">  C++游戏开发基础-枚举篇一：无范围枚举</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-std-optional/'
      tabindex="-5">  C++游戏开发基础-深入解析std::optional</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shen-ru-jie-xi-thiszhi-zhen-de-ying-yong-yu-ji-qiao/'
      tabindex="-6">  C++游戏开发基础-深入解析this指针的应用与技巧</a></span>
  </li><li class="file">
    <span><a class="selected"href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-fu-zhi-gou-zao-han-shu/'
      tabindex="-7">  C++游戏开发基础-深入解析复制构造函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-mo-ban-he-can-shu-tui-dao-zhi-nan/'
      tabindex="-8">  C++游戏开发基础-类模版和参数推导指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/dockerbi-zhi-bi-hui/'
      tabindex="-9">  Docker必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/githithub-xiao-ce/'
      tabindex="-10">  GitGitHub小册</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/google-hacking/'
      tabindex="-11">  Google Hacking</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/googleguan-fang-ti-shi-gong-cheng-bai-pi-shu-zhong-wen-yi-ben/'
      tabindex="-12">  Google官方《提示工程白皮书（中文译本）》</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-dai-ma-bu-quan-ti-shi-gong-neng-xiao-shi-de-ji-chong-jie-jue-fang-an-re-geng-ban/'
      tabindex="-13">  IDEA代码补全&amp;提示功能消失的几种解决方案(热更版)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-chen-jin-shi-bian-cheng-ti-yan/'
      tabindex="-14">  IDEA沉浸式编程体验</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-han-shu-shi-bian-cheng/'
      tabindex="-15">  Java函数式编程</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-ji-he-yuan-ma-qian-xi/'
      tabindex="-16">  Java集合源码浅析</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mysql-shi-wu-te-xing-yu-ge-chi-ji-bie-xiang-jie/'
      tabindex="-17">  MySQL_事务特性与隔离级别详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ocao-zuo-fu-shi-xian-mei-ju-de-shu-ru-shu-chu/'
      tabindex="-18">  O操作符,实现枚举的输入输出</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/prdsuan-fa-ting-shuo-ni-xiang-ping-yun-qi-chou-yi-ke-rong-yao-shui-jing/'
      tabindex="-19">  PRD算法：听说你想凭运气抽一颗荣耀水晶?</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/picgo-pei-zhi-ge-chong-tu-chuang/'
      tabindex="-20">  PicGo配置各种图床</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/redis-bi-zhi-bi-hui/'
      tabindex="-21">  Redis必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-zhong-de-move-yu-yi-sui-bi/'
      tabindex="-22">  Rust中的move语义随笔</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ssm-kuang-jia-shi-xian-ji-cheng-duan-xin-yan-zheng-ma-gong-neng/'
      tabindex="-23">  SSM框架实现集成短信验证码功能</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/slf4jyu-logbackshi-yong-zhi-nan-ji-yu-gradle/'
      tabindex="-24">  Slf4j与Logback实用指南(基于Gradle)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/spring-security5-xdao-spring-security6-xde-qian-yi/'
      tabindex="-25">  Spring Security5.x到Spring Security6.x的迁移</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springboot-webkai-fa-jing-jie/'
      tabindex="-26">  SpringBoot Web开发精解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springsecurity/'
      tabindex="-27">  SpringSecurity</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/unity6xia-jia-zhong-guo-qu-tuan-jie-yin-qing-jie-bang-zhe-shi-fen-lie-huan-shi-ben-di-hua-de-kai-shi/'
      tabindex="-28">  Unity6下架中国区，团结引擎接棒：这是分裂，还是本地化的开始？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-cong-0-dao-1-da-zao-quan-yu-yan-zhi-chi-de-mo-neng-bian-ji-qi-yu-fa-pian/'
      tabindex="-29">  Vim从0到1打造全语言支持的万能编辑器-语法篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-tiao-tou-powershell-pian/'
      tabindex="-30">  Vim折腾之 PowerShell篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-di-zhi-chuan-di-xiang-jie/'
      tabindex="-31">  [C++游戏开发基础]:地址传递详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-yin-yong-fan-hui-he-di-zhi-fan-hui/'
      tabindex="-32">  [C++游戏开发基础]:引用返回和地址返回</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-he-const/'
      tabindex="-33">  [C++游戏开发基础]:指针和const</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shu-ju-feng-zhuang-yin-cang-de-hao-chu/'
      tabindex="-34">  [C++游戏开发基础]:数据封装(隐藏)的好处</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-gou-zao-han-shu-qian-xi-8000zi/'
      tabindex="-35">  [C++游戏开发基础]:构造函数浅析(8000字)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-li-jie-kong-zhi-zhen/'
      tabindex="-36">  [C++游戏开发基础]:理解空指针</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-zhong-de-fang-wen-han-shu/'
      tabindex="-37">  [C++游戏开发基础]:类中的访问函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-de-ji-ben-gai-nian-li-jie/'
      tabindex="-38">  [C++游戏开发基础]指针的基本概念理解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/fanatical-wu-yue-feng-kuang-te-hui-wei-ni-de-steam-ku-jia-dian-liao/'
      tabindex="-39">  _Fanatical 五月疯狂特惠：为你的 Steam 库加点料！</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-kai-yuan-mi-ma-gong-ju-xpwd-zhong-wen-ban-bian-geng-ri-zhi/'
      tabindex="-40">  _Rust开源密码工具xpwd中文版变更日志</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/readme/'
      tabindex="-41">  readme</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wblog-bo-ke-xian-shang-bu-shu/'
      tabindex="-42">  wblog博客线上部署</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/shang-gu-shen-qi-vim-su-cheng-bei-wang-lu/'
      tabindex="-43">  上古神器_Vim速成备忘录</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mian-fei-ji-huo-quan-ban-ben-typora-zui-xin-ban-wei-li/'
      tabindex="-44">  免费激活全版本Typora，最新版为例</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-lombokxian-wei-ren-zhi-de-ji-ge-qi-ji-yin-qiao/'
      tabindex="-45">  关于Lombok鲜为人知的几个奇技淫巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-jie-kou-xian-liu-de-yi-ci-jian-dan-shi-jian/'
      tabindex="-46">  关于接口限流的一次简单实践</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/tu-jie-er-jin-zhi/'
      tabindex="-47">  图解二进制</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ru-he-xie-de-yi-shou-you-ya-gui-fan-de-springboot-jie-kou/'
      tabindex="-48">  如何写得一手优雅规范的SpringBoot 接口？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/kai-fa-bi-hui-xi-lie-jwtqian-tan/'
      tabindex="-49">  开发必会系列_JWT浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ji-qiao-jiu-shi-xiao-lu-chatgpt-diao-jiao-zhi-bei/'
      tabindex="-50">  技巧就是效率，ChatGPT调教指北</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-sheng-intellij-kai-fa-xiao-lu-zhe-kuan-dai-ma-tu-ding-cha-jian-codepins-zhi-de-yi-shi/'
      tabindex="-51">  提升 IntelliJ 开发效率？这款代码图钉插件 CodePins 值得一试</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-wen-de-zhi-hui-zhuan-zai/'
      tabindex="-52">  提问的智慧转载</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiao-lu-gong-ju-markdown/'
      tabindex="-53">  效率工具Markdown</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wu-wei-bing-fa-rust-sheng-ming-zhou-qi-qian-tan/'
      tabindex="-54">  无畏并发_Rust 生命周期浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-yu-de-bei-sai-er-qu-xian-gan-shou-si-hua-de-shu-xue-zhi-mei/'
      tabindex="-55">  游戏开发与的贝塞尔曲线_感受丝滑的数学之美</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-bi-bei-gao-xiao-de-aabb-qiu-ti-he-obb-peng-zhuang-jian-ce-suan-fa/'
      tabindex="-56">  游戏开发必备：高效的 AABB、球体和 OBB 碰撞检测算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-suan-fa-ji-chu-a-xun-lu-suan-fa-chi-xu-wei-hu/'
      tabindex="-57">  游戏算法基础-深入解析A*寻路算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/du-li-you-xi-kai-fa-zhe-gong-ju-xiang-2025jing-xuan-tui-jian-yu-shi-yong-zhi-nan/'
      tabindex="-58">  独立游戏开发者工具箱：2025精选推荐与实用指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xu-huan-yin-qing-you-xi-kai-fa-xi-lie-zhuan-ti-guan-fang-bian-ma-biao-zhun-huo-gui-yue/'
      tabindex="-59">  虚幻引擎游戏开发系列专题-官方编码标准或规约</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiang-jie-she-ji-mo-shi-dan-li-de-jin-hua-zhi-lu/'
      tabindex="-60">  详解设计模式_单例的进化之路</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xie-e-de-fei-chang-liang-quan-ju-bian-liang/'
      tabindex="-61">  邪恶的非常量全局变量</a></span>
  </li>
</ul>
</div>
      <div class="viewer page" id="viewer" tabindex="0">
        <div class="tab">
<div class="file-manager" onclick='document.getElementById("files").classList.toggle("open"); document.getElementById("content").classList.toggle("close")'> </div>
<ul id="tabs">
</ul>


</div>
        <div class="content" id="content"><p>考虑下面程序:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Fraction
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_numerator</span><span style="color:#eff1f5;">{ </span><span style="color:#d08770;">0 </span><span style="color:#eff1f5;">};
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_denominator</span><span style="color:#eff1f5;">{ </span><span style="color:#d08770;">1 </span><span style="color:#eff1f5;">};
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// Default constructor
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Fraction</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">numerator</span><span>=</span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">denominator</span><span>=</span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">        : </span><span style="color:#bf616a;">m_numerator</span><span style="color:#eff1f5;">{numerator}, </span><span style="color:#bf616a;">m_denominator</span><span style="color:#eff1f5;">{denominator}
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Fraction(</span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_numerator </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">, </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_denominator </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">)</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Fraction </span><span style="color:#bf616a;">f </span><span>{ </span><span style="color:#d08770;">5</span><span>, </span><span style="color:#d08770;">3 </span><span>};  </span><span style="color:#65737e;">// 1
</span><span>    Fraction </span><span style="color:#bf616a;">fCopy </span><span>{ f }; </span><span style="color:#65737e;">// 2
</span><span>
</span><span>    f.</span><span style="color:#bf616a;">print</span><span>();
</span><span>    </span><span style="color:#bf616a;">fCopy</span><span>.</span><span style="color:#bf616a;">print</span><span>();
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>在上面的代码中,除了一系列熟悉的配方之外,我们还发现在25行有一行之前没见过的代码,就是你想的那样,这个就是本文的主角-复制构造函数。</p>
<p>复制构造函数也是一种构造函数(有一种听君一席话的感觉😊)。用于使用相同类型的现有对象初始化对象,在复制构造函数执行之后,在复制构造函数执行完后，新对象应该是传入的已有对象的副本（拷贝）。</p>
<hr />
<h2 id="yin-shi-fu-zhi-gou-zao-han-shu">隐式复制构造函数</h2>
<p>如果你没有为你的类提供复制构造函数，C++将为你创建一个公共<strong>隐式复制构造函数</strong> 。在上面的示例中，语句 <code>Fraction fCopy { f };</code> 调用隐式复制构造函数来用 <code>f</code> 初始化 <code>fCopy</code>。</p>
<p>默认情况下，隐式复制构造函数将进行成员初始化。这意味着每个成员都将使用传入的类的相应成员作为初始化器进行初始化。在上例中，<code>fCopy.m_numerator</code> 使用 <code>f.m_numerator</code>（值为 <code>5</code>）初始化，<code>fCopy.m_denominator</code> 使用 <code>f.m_denominator</code>（值为 <code>3</code>）初始化。</p>
<p>在执行复制构造函数之后，<code>f</code> 和 <code>fCopy</code> 的成员具有相同的值，因此 <code>fCopy</code> 是 <code>f</code> 的副本。因此，调用 <code>print（）在</code>任何一个上都有相同的结果。</p>
<hr />
<h2 id="xian-shi-ding-yi-zi-ji-de-fu-zhi-gou-zao-han-shu">显式定义自己的复制构造函数</h2>
<p>我们也可以显式的定义自己的复制构造函数。比如下面的示例中,我们将在自己定义的复制构造函数中打印一条消息,以便于提示我们,自己定义的复制构造函数被成功调用。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include</span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Fraction
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_numberator {</span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">};
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_denominator {</span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">};
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Fraction</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">numerator </span><span>= </span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">denominator </span><span>= </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">    :</span><span style="color:#bf616a;">m_numberator</span><span style="color:#eff1f5;">{numerator}
</span><span style="color:#eff1f5;">    ,</span><span style="color:#bf616a;">m_denominator</span><span style="color:#eff1f5;">{denominator}
</span><span style="color:#eff1f5;">    {}
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// 复制构造函数
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Fraction</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">const</span><span style="color:#eff1f5;"> Fraction</span><span>&amp; </span><span style="color:#bf616a;">fraction</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">    :</span><span style="color:#bf616a;">m_numberator</span><span style="color:#eff1f5;">{fraction.</span><span style="color:#bf616a;">m_numberator</span><span style="color:#eff1f5;">}
</span><span style="color:#eff1f5;">    ,</span><span style="color:#bf616a;">m_denominator</span><span style="color:#eff1f5;">{fraction.</span><span style="color:#bf616a;">m_denominator</span><span style="color:#eff1f5;">}
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt;&quot;</span><span style="color:#a3be8c;">Copy constructor called</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span style="color:#eff1f5;">()
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt;&quot;</span><span style="color:#a3be8c;">Fraction(</span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_numberator </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">,</span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_denominator </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">)</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Fraction </span><span style="color:#bf616a;">f </span><span>{</span><span style="color:#d08770;">5</span><span>,</span><span style="color:#d08770;">3</span><span>};
</span><span>    Fraction </span><span style="color:#bf616a;">fCopy</span><span>{f}; </span><span style="color:#65737e;">// 复制构造函数
</span><span>
</span><span>    f.</span><span style="color:#bf616a;">print</span><span>();
</span><span>    </span><span style="color:#bf616a;">fCopy</span><span>.</span><span style="color:#bf616a;">print</span><span>();
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span><span>
</span></code></pre>
<p><img src="https://images.waer.ltd/notes/202503241659794.png" alt="image-20250324165906674" loading="lazy" decoding="async" /></p>
<p><strong>提醒⏰</strong></p>
<blockquote>
<p>访问控制是 <strong>基于类</strong>而不是 <strong>基于对象</strong>的。这意味着,同一个类的成员函数可以访问任意该类对象的私有成员（不仅仅是当前对象 this 的私有成员）。</p>
<p>在上面的 Fraction 复制构造函数中，我们利用了这一特性，直接访问了 fraction 参数的私有成员。否则，我们将无法直接访问这些成员（除非添加访问函数，但这里显然没那个必要）。</p>
</blockquote>
<p><strong>最佳实践</strong></p>
<blockquote>
<ul>
<li>复制构造函数不应该做除了复制以外的其他工作。</li>
<li>除非你有特定必要的理由创建自己的复制构造函数,否则请首选使用隐式复制构造函数。</li>
</ul>
</blockquote>
<hr />
<h2 id="">复制构造函数的参数必须是引用类型</h2>
<ul>
<li>当一个对象 <strong>按值传递（pass by value）</strong> 时，函数参数会接收到 <strong>原始对象的副本</strong>，而不是直接操作原对象。如果传递的对象与参数是 <strong>相同的类类型</strong>，那么<strong>复制过程</strong>是通过 <strong>隐式调用拷贝构造函数（copy constructor）</strong> 来完成的。</li>
</ul>
<p>看个例子:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Fraction
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_numerator</span><span style="color:#eff1f5;">{ </span><span style="color:#d08770;">0 </span><span style="color:#eff1f5;">};   </span><span style="color:#65737e;">// 分子，默认为 0
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_denominator</span><span style="color:#eff1f5;">{ </span><span style="color:#d08770;">1 </span><span style="color:#eff1f5;">}; </span><span style="color:#65737e;">// 分母，默认为 1
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// 默认构造函数（带默认参数）
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Fraction</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">numerator </span><span>= </span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">denominator </span><span>= </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">        : </span><span style="color:#bf616a;">m_numerator</span><span style="color:#eff1f5;">{ numerator }, </span><span style="color:#bf616a;">m_denominator</span><span style="color:#eff1f5;">{ denominator }
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// 拷贝构造函数
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Fraction</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">const</span><span style="color:#eff1f5;"> Fraction</span><span>&amp; </span><span style="color:#bf616a;">fraction</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">        : </span><span style="color:#bf616a;">m_numerator</span><span style="color:#eff1f5;">{ fraction.</span><span style="color:#bf616a;">m_numerator </span><span style="color:#eff1f5;">}  </span><span style="color:#65737e;">// 复制分子
</span><span style="color:#eff1f5;">        , </span><span style="color:#bf616a;">m_denominator</span><span style="color:#eff1f5;">{ fraction.</span><span style="color:#bf616a;">m_denominator </span><span style="color:#eff1f5;">}  </span><span style="color:#65737e;">// 复制分母
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">复制构造函数被调用</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;  </span><span style="color:#65737e;">// 输出信息，确认拷贝构造函数被调用
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// 打印分数
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Fraction(</span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_numerator </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">, </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_denominator </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">)</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#65737e;">// 按值传递 Fraction 对象（会调用拷贝构造函数）
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">printFraction</span><span>(Fraction </span><span style="color:#bf616a;">f</span><span>) </span><span style="color:#65737e;">// f 按值传递，会创建副本
</span><span>{
</span><span>    f.</span><span style="color:#bf616a;">print</span><span>(); </span><span style="color:#65737e;">// 调用 Fraction 类的 print() 方法
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Fraction </span><span style="color:#bf616a;">f</span><span>{ </span><span style="color:#d08770;">5</span><span>, </span><span style="color:#d08770;">3 </span><span>}; </span><span style="color:#65737e;">// 创建 Fraction 对象 f，调用普通构造函数
</span><span>
</span><span>    </span><span style="color:#bf616a;">printFraction</span><span>(f); </span><span style="color:#65737e;">// 传递 f 到 printFraction 函数，按值传递，会调用拷贝构造函数
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span><span>
</span></code></pre>
<p>在上面的例子中，对 <code>printFraction（f）</code> 的调用是通过值传递 <code>f</code>。调用复制构造函数将 <code>f</code> 从 <code>main</code> 复制到函数 <code>printFraction（）</code> 的 <code>f</code> 参数中。</p>
<p>在 C++ 中，<strong>拷贝构造函数（Copy Constructor）的参数必须是</strong> const <strong>引用</strong>，不能按值传递，否则会导致 <strong>无限递归</strong>，最终导致 <strong>栈溢出（stack overflow）</strong>。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">MyClass
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">MyClass</span><span style="color:#eff1f5;">(MyClass </span><span style="color:#bf616a;">obj</span><span style="color:#eff1f5;">) </span><span style="color:#65737e;">// ❌ 错误：按值传递拷贝构造函数
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Copy Constructor Called</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span></code></pre>
<blockquote>
<p>当你尝试创建一个新对象（例如 MyClass obj2 = obj1;），编译器会这样做：</p>
<ol>
<li>obj1 需要被<strong>复制</strong>到 obj 这个参数中（因为按值传递）。</li>
<li>但 obj 也是一个 MyClass 类型的对象，所以需要调用 <strong>拷贝构造函数</strong> 来复制 obj1。</li>
<li><strong>调用拷贝构造函数时，又要传递 obj 这个参数（按值传递）</strong>，因此：
<ol>
<li><strong>又会调用拷贝构造函数</strong></li>
<li><strong>拷贝构造函数又需要传递 obj</strong></li>
<li><strong>进入无限递归的调用链</strong></li>
</ol>
</li>
<li>最终 <strong>栈溢出（Stack Overflow）</strong>，程序崩溃。</li>
</ol>
</blockquote>
<hr />
<p>如果一个类没有复制构造函数，编译器将隐式地为我们生成一个。如果我们愿意，我们可以显式地告诉编译器使用 <code>= default</code> 语法为我们创建一个默认的复制构造函数：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Fraction
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_numerator</span><span style="color:#eff1f5;">{ </span><span style="color:#d08770;">0 </span><span style="color:#eff1f5;">};
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_denominator</span><span style="color:#eff1f5;">{ </span><span style="color:#d08770;">1 </span><span style="color:#eff1f5;">};
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// 默认构造函数
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Fraction</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">numerator</span><span>=</span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">denominator</span><span>=</span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">        : </span><span style="color:#bf616a;">m_numerator</span><span style="color:#eff1f5;">{numerator}, </span><span style="color:#bf616a;">m_denominator</span><span style="color:#eff1f5;">{denominator}
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Fraction</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">const</span><span style="color:#eff1f5;"> Fraction</span><span>&amp; </span><span style="color:#bf616a;">fraction</span><span style="color:#eff1f5;">) </span><span>= </span><span style="color:#b48ead;">default</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Fraction(</span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_numerator </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">, </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_denominator </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">)</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Fraction </span><span style="color:#bf616a;">f </span><span>{ </span><span style="color:#d08770;">5</span><span>, </span><span style="color:#d08770;">3 </span><span>};
</span><span>    Fraction </span><span style="color:#bf616a;">fCopy </span><span>{ f };
</span><span>
</span><span>    f.</span><span style="color:#bf616a;">print</span><span>();
</span><span>    </span><span style="color:#bf616a;">fCopy</span><span>.</span><span style="color:#bf616a;">print</span><span>();
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<hr />
<h2 id="delete">使用 <code>=delete</code>防止复制</h2>
<p>有时候我们会遇到这样的需求,我们不希望某个类的对象是可以复制的,我们可以通过使用<code>=delete</code>来将复制构造函数标记为删除以实现该需求。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Fraction
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_numerator</span><span style="color:#eff1f5;">{ </span><span style="color:#d08770;">0 </span><span style="color:#eff1f5;">};
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_denominator</span><span style="color:#eff1f5;">{ </span><span style="color:#d08770;">1 </span><span style="color:#eff1f5;">};
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// Default constructor
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Fraction</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">numerator</span><span>=</span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">denominator</span><span>=</span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">        : </span><span style="color:#bf616a;">m_numerator</span><span style="color:#eff1f5;">{numerator}, </span><span style="color:#bf616a;">m_denominator</span><span style="color:#eff1f5;">{denominator}
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// 删除复制构造函数 无法再复制
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Fraction</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">const</span><span style="color:#eff1f5;"> Fraction</span><span>&amp; </span><span style="color:#bf616a;">fraction</span><span style="color:#eff1f5;">) </span><span>= </span><span style="color:#b48ead;">delete</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Fraction(</span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_numerator </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">, </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_denominator </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">)</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Fraction </span><span style="color:#bf616a;">f </span><span>{ </span><span style="color:#d08770;">5</span><span>, </span><span style="color:#d08770;">3 </span><span>};
</span><span>    Fraction </span><span style="color:#bf616a;">fCopy </span><span>{ f }; </span><span style="color:#65737e;">//编译错误
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>在这个例子中，当编译器去寻找一个构造函数来用 <code>f</code> 初始化 <code>fCopy</code> 时，它会发现复制构造函数已经被删除了。这将导致它发出编译错误。</p>
<blockquote>
<p>通常，C++ 类的 <strong>拷贝构造函数</strong> 是 public 的，这样外部代码（例如按值传递对象、对象赋值等）可以正常复制对象。但如果你 <strong>不希望对象被随意复制</strong>，可以将拷贝构造函数设为 private，这样就无法在类外部进行复制。</p>
<p>然而，这样做有一个例外：<strong>类的成员函数仍然可以访问私有拷贝构造函数</strong>，所以如果你的类内部有某些代码仍然需要复制对象，这个方法就不适合。</p>
</blockquote>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">NonCopyable
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// 私有拷贝构造函数，防止外部复制
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">NonCopyable</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">const</span><span style="color:#eff1f5;"> NonCopyable</span><span>&amp; </span><span style="color:#bf616a;">other</span><span style="color:#eff1f5;">) 
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">拷贝构造函数被调用</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// 默认构造函数
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">NonCopyable</span><span style="color:#eff1f5;">() 
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">默认构造函数被调用</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">show</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const 
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">我是一个 NonCopyable 对象</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    NonCopyable obj1; </span><span style="color:#65737e;">// ✅ 调用默认构造函数
</span><span>
</span><span>    </span><span style="color:#65737e;">// NonCopyable obj2 = obj1; // ❌ 这里会报错，因为拷贝构造函数是 private 的
</span><span>    </span><span style="color:#65737e;">// printNonCopyable(obj1);  // ❌ 这里也会报错，按值传递需要拷贝
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<hr />
<h2 id="-1">类初始化和复制省略</h2>
<p>先回顾一下具有基本数据类型的对象的6种基本初始化方式:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">int</span><span> a;         </span><span style="color:#65737e;">// 没有初始化器（默认初始化）  
</span><span style="color:#b48ead;">int</span><span> b = </span><span style="color:#d08770;">5</span><span>;     </span><span style="color:#65737e;">// 在等号后使用初始化器（拷贝初始化）  
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">c</span><span>(</span><span style="color:#d08770;">6</span><span>);      </span><span style="color:#65737e;">// 使用括号内的初始化器（直接初始化）  
</span><span>
</span><span style="color:#65737e;">// 列表初始化方法（C++11）  
</span><span style="color:#b48ead;">int</span><span> d { </span><span style="color:#d08770;">7 </span><span>};   </span><span style="color:#65737e;">// 使用大括号的初始化器（直接列表初始化）  
</span><span style="color:#b48ead;">int</span><span> e = { </span><span style="color:#d08770;">8 </span><span>}; </span><span style="color:#65737e;">// 在等号后使用大括号的初始化器（拷贝列表初始化）  
</span><span style="color:#b48ead;">int</span><span> f {};      </span><span style="color:#65737e;">// 初始化器为空的大括号（值初始化）  
</span></code></pre>
<p>所有这些初始化类型对于具有类类型的对象都是有效的：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Foo
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// 默认构造函数（无参数）
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Foo</span><span style="color:#eff1f5;">()
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Foo()</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// 普通构造函数（带一个 int 参数）
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Foo</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Foo(int) </span><span>&quot; &lt;&lt;</span><span style="color:#eff1f5;"> x </span><span>&lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// 拷贝构造函数（用于复制已有对象）
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Foo</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">const</span><span style="color:#eff1f5;"> Foo</span><span>&amp;</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Foo(const Foo&amp;)</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#65737e;">// 调用 Foo() 默认构造函数
</span><span>    Foo f1;           </span><span style="color:#65737e;">// 默认初始化
</span><span>    Foo </span><span style="color:#bf616a;">f2</span><span>{};         </span><span style="color:#65737e;">// 值初始化（推荐）
</span><span>
</span><span>    </span><span style="color:#65737e;">// 调用 Foo(int) 普通构造函数
</span><span>    Foo f3 = </span><span style="color:#d08770;">3</span><span>;       </span><span style="color:#65737e;">// 拷贝初始化（仅适用于非 explicit 构造函数）
</span><span>    Foo </span><span style="color:#bf616a;">f4</span><span>(</span><span style="color:#d08770;">4</span><span>);        </span><span style="color:#65737e;">// 直接初始化
</span><span>    Foo </span><span style="color:#bf616a;">f5</span><span>{ </span><span style="color:#d08770;">5 </span><span>};      </span><span style="color:#65737e;">// 直接列表初始化（推荐）
</span><span>    Foo f6 = { </span><span style="color:#d08770;">6 </span><span>};   </span><span style="color:#65737e;">// 拷贝列表初始化（仅适用于非 explicit 构造函数）
</span><span>
</span><span>    </span><span style="color:#65737e;">// 调用 Foo(const Foo&amp;) 拷贝构造函数
</span><span>    Foo f7 = f3;      </span><span style="color:#65737e;">// 拷贝初始化
</span><span>    Foo </span><span style="color:#bf616a;">f8</span><span>(f3);       </span><span style="color:#65737e;">// 直接初始化
</span><span>    Foo </span><span style="color:#bf616a;">f9</span><span>{ f3 };     </span><span style="color:#65737e;">// 直接列表初始化（推荐）
</span><span>    Foo f10 = { f3 }; </span><span style="color:#65737e;">// 拷贝列表初始化
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>在现代C++中,复制初始化、直接初始化和列表初始化的本质做的都是同一件事: <strong>初始化一个对象</strong>。</p>
<p>对于所有类型的初始化:</p>
<ul>
<li>初始化类类型时,将检查该类的构造函数集,并使用重载解析来确定最佳匹配的构造函数。这可能涉及参数的隐式转换。</li>
<li>初始化非类类型时,编译器会使用<strong>隐式转换规则</strong>来检查是否可以将提供的值转换为目标类型。</li>
</ul>
<blockquote>
<p>同样值得注意的是，在某些情况下，某些形式的初始化是不允许的（例如，在构造函数成员初始化列表中，我们只能使用直接形式的初始化，而不能复制初始化）。</p>
</blockquote>
<hr />
<h2 id="-2">不必要的复制</h2>
<p>考虑下面的程序:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include</span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Something
</span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_x {};
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Something</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span style="color:#eff1f5;">) : </span><span style="color:#bf616a;">m_x</span><span style="color:#eff1f5;">{x}
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt;&quot;</span><span style="color:#a3be8c;">Normal constructor called</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Something</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">const</span><span style="color:#eff1f5;"> Something</span><span>&amp; </span><span style="color:#bf616a;">s</span><span style="color:#eff1f5;">):</span><span style="color:#bf616a;">m_x </span><span style="color:#eff1f5;">{s.</span><span style="color:#bf616a;">m_x</span><span style="color:#eff1f5;">}
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Copy constructor</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Something(</span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_x </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">)</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Something </span><span style="color:#bf616a;">s </span><span>{</span><span style="color:#bf616a;">Something </span><span>{</span><span style="color:#d08770;">6</span><span>}};
</span><span>    s.</span><span style="color:#bf616a;">print</span><span>();
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span><span>
</span></code></pre>
<p>在上面的变量<code>s</code>的初始化中,我们首先构造一个临时的<code>Something</code>,初始化值为<code>6</code>. 然后使用这个临时变量来初始化<code>s</code>  ,因为临时对象和 <code>s</code> 具有相同的类型（它们都是 <code>Something</code> 对象），所以这里通常会调用 <code>Something（const Something）</code> 复制构造函数来将临时对象中的值复制到 <code>s</code> 中。最终结果是 <code>s</code> 被初始化为值 <code>6</code>。</p>
<p>在<strong>没有任何优化</strong>的情况下,上面的程序将会打印:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>Normal </span><span style="color:#8fa1b3;">constructor
</span><span style="color:#8fa1b3;">Copy constructor
</span><span style="color:#8fa1b3;">Something</span><span>(</span><span style="color:#d08770;">5</span><span>)
</span></code></pre>
<p>然而，这个程序是不必要的低效率，因为我们必须进行两次构造函数调用：一次是对 Something（int），另一次是对 <code>Something（const Something&amp;）</code>。请注意，上面的最终结果与我们编写以下代码的结果相同：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>Something s { </span><span style="color:#d08770;">5 </span><span>}; 
</span></code></pre>
<hr />
<h2 id="-3">复制消除</h2>
<p>由于编译器可以自由地重写语句来优化它们，人们可能会想，编译器是否可以优化掉不必要的副本，并将 <code>Something s { Something{5} }</code> 视为我们最终的写法。</p>
<p>答案是肯定的，这样做的过程被称为<em>复制省略</em> 。 <strong>复制省略</strong>是一种编译器优化技术，它允许编译器删除不必要的对象复制。</p>
<p>换句话说，在编译器通常会调用复制构造函数的情况下，编译器可以自由地重写代码以完全避免对复制构造函数的调用。当编译器优化掉对复制构造函数的调用时，我们说该构造函数已被<strong>省略</strong> 。</p>
<p>与其他类型的优化不同，复制省略不受“as-if”规则的约束。也就是说，允许复制省略来省略复制构造函数，即使复制构造函数还会执行其他任务。</p>
<p>这就是前面为什么说 <strong>复制构造函数不应该存在除复制功能之外其他操作</strong>的原因。</p>
<p>所以上面的程序如果在C++17环境下编译,那么你的打印将和我一样:</p>
<p><img src="https://images.waer.ltd/notes/202503241758804.png" alt="image-20250324175809736" loading="lazy" decoding="async" /></p>
<hr />
<h2 id="-4"><strong>C++17 中的强制复制省略</strong></h2>
<p>在 <code>C++</code>17 之前，复制省略是编译器可以进行的严格的可选优化。在 <code>C++17</code> 中，复制省略在某些情况下是强制性的。在这些情况下，复制省略将自动执行（即使您告诉编译器不要执行复制省略）。</p>
<ul>
<li>在可选的省略情况下，可访问的复制构造函数必须可用（例如未删除），即使对复制构造函数的实际调用被省略。</li>
<li>在强制省略的情况下，可访问的复制构造函数不需要可用（换句话说，即使删除了复制构造函数，也会发生强制省略）。</li>
</ul>
<hr />
<h2 id="-5">提一嘴explict</h2>
<p>在 <code>C++</code> 中，<code>explicit</code> 关键字用于修饰<strong>构造函数</strong>和<strong>转换运算符</strong>，它的主要作用是<strong>防止隐式转换</strong>，确保类的对象不会被意外地从其他类型的值隐式构造。</p>
<ul>
<li><strong>默认情况下，应该将所有接受单个参数的构造函数声明为 explicit。</strong>
<ul>
<li>这样可以防止<strong>隐式类型转换</strong>，避免意外的类型转换导致的错误。</li>
</ul>
</li>
<li><strong>如果某种类型转换在语义上是合理的，并且性能上没有问题，则可以考虑不使用 explicit，允许隐式转换。</strong>
<ul>
<li>例如，如果类 <code>String</code> 有一个接受 <code>const char*</code> 的构造函数，并且允许从 <code>const char*</code> 隐式转换为 <code>String</code> 是合理的，可以去掉 <code>explicit</code>。</li>
</ul>
</li>
<li><strong>不要将拷贝构造函数或移动构造函数声明为 explicit，因为它们并不会进行类型转换。</strong>
<ul>
<li>拷贝构造<code>（T(const T&amp;)）</code>和移动构造（<code>T(T&amp;&amp;)）</code>的作用是复制或移动相同类型的对象，而不是进行类型转换，因此不应该加 <code>explicit</code>，否则会影响对象的正常复制和移动操作。</li>
</ul>
</li>
</ul>
<p>示例:</p>
<p><strong>✅ 正确：使用 explicit 防止隐式转换</strong></p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Foo
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">explicit </span><span style="color:#8fa1b3;">Foo</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span style="color:#eff1f5;">) </span><span style="color:#65737e;">// ✅ 默认加 explicit，防止隐式转换
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Foo(int) called with </span><span>&quot; &lt;&lt;</span><span style="color:#eff1f5;"> x </span><span>&lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">printFoo</span><span>(Foo </span><span style="color:#bf616a;">f</span><span>) {}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Foo f1 = </span><span style="color:#d08770;">10</span><span>; </span><span style="color:#65737e;">// ❌ 编译错误：explicit 禁止了隐式转换
</span><span>    Foo </span><span style="color:#bf616a;">f2</span><span>(</span><span style="color:#d08770;">10</span><span>);  </span><span style="color:#65737e;">// ✅ 直接初始化可以
</span><span>    </span><span style="color:#bf616a;">printFoo</span><span>(</span><span style="color:#d08770;">10</span><span>); </span><span style="color:#65737e;">// ❌ 编译错误，无法从 int 隐式转换为 Foo
</span><span>}
</span></code></pre>
<p><strong>✅ 合理去掉 explicit 允许隐式转换</strong></p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">String
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">String</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">const char</span><span>* </span><span style="color:#bf616a;">str</span><span style="color:#eff1f5;">) </span><span style="color:#65737e;">// ✅ 允许从 const char* 隐式转换为 String
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">String constructor called</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">printString</span><span>(String </span><span style="color:#bf616a;">s</span><span>) {}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#bf616a;">printString</span><span>(&quot;</span><span style="color:#a3be8c;">Hello</span><span>&quot;); </span><span style="color:#65737e;">// ✅ 允许隐式转换
</span><span>}
</span></code></pre>
<p><strong>❌ 不要给拷贝/移动构造函数加 explicit</strong></p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Bar
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Bar</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">const</span><span style="color:#eff1f5;"> Bar</span><span>&amp;</span><span style="color:#eff1f5;">) </span><span>= </span><span style="color:#b48ead;">default</span><span style="color:#eff1f5;">; </span><span style="color:#65737e;">// ✅ 正确，拷贝构造函数不应 explicit
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Bar</span><span style="color:#eff1f5;">(Bar</span><span>&amp;&amp;</span><span style="color:#eff1f5;">) </span><span>= </span><span style="color:#b48ead;">default</span><span style="color:#eff1f5;">;      </span><span style="color:#65737e;">// ✅ 正确，移动构造函数不应 explicit
</span><span style="color:#eff1f5;">}</span><span>;
</span></code></pre>
<blockquote>
<p>如果加上 <code>explicit</code>，将会导致 <code>Bar b2 = b1</code>; 无法编译。</p>
</blockquote>
<table><thead><tr><th><strong>规则</strong></th><th><strong>解释</strong></th></tr></thead><tbody>
<tr><td><strong>单参数构造函数默认 explicit</strong></td><td>防止意外的隐式转换</td></tr>
<tr><td><strong>如果隐式转换合理且高效，可去掉 explicit</strong></td><td>例如 String(const char*)</td></tr>
<tr><td><strong>拷贝/移动构造函数不要 explicit</strong></td><td>这些构造函数不会执行类型转换，避免影响正常复制/移动</td></tr>
</tbody></table>

        </div>
      </div>
      <div class="prompt" id="terminal"><input
    type="text"
    id="setter"
    onkeydown="writeit(this, event);moveIt(this.value.length, event)"
    onchange="writeit(this, event)"
    onkeyup="writeit(this, event)"
    onkeypress="writeit(this, event);"
    >
<label for="setter" id="writer"> </label><b class="cursor" id="cursor"></b></div>
      <footer class="footer">
        <div class="footer-content">
          <p class="icp-info">
            <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer">黔ICP备2021010295号</a>
          </p>
        </div>
      </footer>
    </main>
  </body>

</html>
