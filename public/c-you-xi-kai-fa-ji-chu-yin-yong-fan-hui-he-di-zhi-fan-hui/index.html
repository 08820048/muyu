<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>慕予博客</title>
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"
    integrity="sha256-WCzAhd2P6gRJF9Hv3oOOd+hFJi/QJbv+Azn4CGB8gfY=" crossorigin="anonymous" defer></script>
  <script src="/js/index.js" defer></script>
  <script src="/js/prompt.js" defer></script>
  <script src="/js/keyboard.js" defer></script>
  <script src="/js/tab.js" defer></script>
  <script src="/js/commands.js" defer></script>
  <script src="/js/config.js" defer></script><script src="/config.js"></script><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="style.css"><link rel="stylesheet" href="/css/page.css"></head><body onkeydown="exec(event)" style="background-image: url(&quot;&#x2F;assets&#x2F;bg.jpg&quot;); "><main>
      <div class="files" id="files" tabindex="0">
<ul>

  <li class="file">
    <span><a href='https://ilikexff.cn/8-kuan-rang-ni-kai-fa-qi-fei-de-intellijidea-cha-jian/'
      tabindex="-2">  8款让你开发起飞的IntellijIDEA插件</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/aop-jie-mi-qie-mian-bian-cheng-de-zong-he-zhi-nan/'
      tabindex="-3">  AOP揭秘：切面编程的综合指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-mei-ju-pian-yi-wu-fan-wei-mei-ju/'
      tabindex="-4">  C++游戏开发基础-枚举篇一：无范围枚举</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-std-optional/'
      tabindex="-5">  C++游戏开发基础-深入解析std::optional</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shen-ru-jie-xi-thiszhi-zhen-de-ying-yong-yu-ji-qiao/'
      tabindex="-6">  C++游戏开发基础-深入解析this指针的应用与技巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-fu-zhi-gou-zao-han-shu/'
      tabindex="-7">  C++游戏开发基础-深入解析复制构造函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-mo-ban-he-can-shu-tui-dao-zhi-nan/'
      tabindex="-8">  C++游戏开发基础-类模版和参数推导指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/dockerbi-zhi-bi-hui/'
      tabindex="-9">  Docker必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/githithub-xiao-ce/'
      tabindex="-10">  GitGitHub小册</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/google-hacking/'
      tabindex="-11">  Google Hacking</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/googleguan-fang-ti-shi-gong-cheng-bai-pi-shu-zhong-wen-yi-ben/'
      tabindex="-12">  Google官方《提示工程白皮书（中文译本）》</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-dai-ma-bu-quan-ti-shi-gong-neng-xiao-shi-de-ji-chong-jie-jue-fang-an-re-geng-ban/'
      tabindex="-13">  IDEA代码补全&amp;提示功能消失的几种解决方案(热更版)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-chen-jin-shi-bian-cheng-ti-yan/'
      tabindex="-14">  IDEA沉浸式编程体验</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-han-shu-shi-bian-cheng/'
      tabindex="-15">  Java函数式编程</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-ji-he-yuan-ma-qian-xi/'
      tabindex="-16">  Java集合源码浅析</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mysql-shi-wu-te-xing-yu-ge-chi-ji-bie-xiang-jie/'
      tabindex="-17">  MySQL_事务特性与隔离级别详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ocao-zuo-fu-shi-xian-mei-ju-de-shu-ru-shu-chu/'
      tabindex="-18">  O操作符,实现枚举的输入输出</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/prdsuan-fa-ting-shuo-ni-xiang-ping-yun-qi-chou-yi-ke-rong-yao-shui-jing/'
      tabindex="-19">  PRD算法：听说你想凭运气抽一颗荣耀水晶?</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/picgo-pei-zhi-ge-chong-tu-chuang/'
      tabindex="-20">  PicGo配置各种图床</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/redis-bi-zhi-bi-hui/'
      tabindex="-21">  Redis必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-zhong-de-move-yu-yi-sui-bi/'
      tabindex="-22">  Rust中的move语义随笔</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ssm-kuang-jia-shi-xian-ji-cheng-duan-xin-yan-zheng-ma-gong-neng/'
      tabindex="-23">  SSM框架实现集成短信验证码功能</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/slf4jyu-logbackshi-yong-zhi-nan-ji-yu-gradle/'
      tabindex="-24">  Slf4j与Logback实用指南(基于Gradle)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/spring-security5-xdao-spring-security6-xde-qian-yi/'
      tabindex="-25">  Spring Security5.x到Spring Security6.x的迁移</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springboot-webkai-fa-jing-jie/'
      tabindex="-26">  SpringBoot Web开发精解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springsecurity/'
      tabindex="-27">  SpringSecurity</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/unity6xia-jia-zhong-guo-qu-tuan-jie-yin-qing-jie-bang-zhe-shi-fen-lie-huan-shi-ben-di-hua-de-kai-shi/'
      tabindex="-28">  Unity6下架中国区，团结引擎接棒：这是分裂，还是本地化的开始？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-cong-0-dao-1-da-zao-quan-yu-yan-zhi-chi-de-mo-neng-bian-ji-qi-yu-fa-pian/'
      tabindex="-29">  Vim从0到1打造全语言支持的万能编辑器-语法篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-tiao-tou-powershell-pian/'
      tabindex="-30">  Vim折腾之 PowerShell篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-di-zhi-chuan-di-xiang-jie/'
      tabindex="-31">  [C++游戏开发基础]:地址传递详解</a></span>
  </li><li class="file">
    <span><a class="selected"href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-yin-yong-fan-hui-he-di-zhi-fan-hui/'
      tabindex="-32">  [C++游戏开发基础]:引用返回和地址返回</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-he-const/'
      tabindex="-33">  [C++游戏开发基础]:指针和const</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shu-ju-feng-zhuang-yin-cang-de-hao-chu/'
      tabindex="-34">  [C++游戏开发基础]:数据封装(隐藏)的好处</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-gou-zao-han-shu-qian-xi-8000zi/'
      tabindex="-35">  [C++游戏开发基础]:构造函数浅析(8000字)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-li-jie-kong-zhi-zhen/'
      tabindex="-36">  [C++游戏开发基础]:理解空指针</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-zhong-de-fang-wen-han-shu/'
      tabindex="-37">  [C++游戏开发基础]:类中的访问函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-de-ji-ben-gai-nian-li-jie/'
      tabindex="-38">  [C++游戏开发基础]指针的基本概念理解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/fanatical-wu-yue-feng-kuang-te-hui-wei-ni-de-steam-ku-jia-dian-liao/'
      tabindex="-39">  _Fanatical 五月疯狂特惠：为你的 Steam 库加点料！</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-kai-yuan-mi-ma-gong-ju-xpwd-zhong-wen-ban-bian-geng-ri-zhi/'
      tabindex="-40">  _Rust开源密码工具xpwd中文版变更日志</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/readme/'
      tabindex="-41">  readme</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wblog-bo-ke-xian-shang-bu-shu/'
      tabindex="-42">  wblog博客线上部署</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/shang-gu-shen-qi-vim-su-cheng-bei-wang-lu/'
      tabindex="-43">  上古神器_Vim速成备忘录</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mian-fei-ji-huo-quan-ban-ben-typora-zui-xin-ban-wei-li/'
      tabindex="-44">  免费激活全版本Typora，最新版为例</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-lombokxian-wei-ren-zhi-de-ji-ge-qi-ji-yin-qiao/'
      tabindex="-45">  关于Lombok鲜为人知的几个奇技淫巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-jie-kou-xian-liu-de-yi-ci-jian-dan-shi-jian/'
      tabindex="-46">  关于接口限流的一次简单实践</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/tu-jie-er-jin-zhi/'
      tabindex="-47">  图解二进制</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ru-he-xie-de-yi-shou-you-ya-gui-fan-de-springboot-jie-kou/'
      tabindex="-48">  如何写得一手优雅规范的SpringBoot 接口？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/kai-fa-bi-hui-xi-lie-jwtqian-tan/'
      tabindex="-49">  开发必会系列_JWT浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ji-qiao-jiu-shi-xiao-lu-chatgpt-diao-jiao-zhi-bei/'
      tabindex="-50">  技巧就是效率，ChatGPT调教指北</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-sheng-intellij-kai-fa-xiao-lu-zhe-kuan-dai-ma-tu-ding-cha-jian-codepins-zhi-de-yi-shi/'
      tabindex="-51">  提升 IntelliJ 开发效率？这款代码图钉插件 CodePins 值得一试</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-wen-de-zhi-hui-zhuan-zai/'
      tabindex="-52">  提问的智慧转载</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiao-lu-gong-ju-markdown/'
      tabindex="-53">  效率工具Markdown</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wu-wei-bing-fa-rust-sheng-ming-zhou-qi-qian-tan/'
      tabindex="-54">  无畏并发_Rust 生命周期浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-yu-de-bei-sai-er-qu-xian-gan-shou-si-hua-de-shu-xue-zhi-mei/'
      tabindex="-55">  游戏开发与的贝塞尔曲线_感受丝滑的数学之美</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-bi-bei-gao-xiao-de-aabb-qiu-ti-he-obb-peng-zhuang-jian-ce-suan-fa/'
      tabindex="-56">  游戏开发必备：高效的 AABB、球体和 OBB 碰撞检测算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-suan-fa-ji-chu-a-xun-lu-suan-fa-chi-xu-wei-hu/'
      tabindex="-57">  游戏算法基础-深入解析A*寻路算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/du-li-you-xi-kai-fa-zhe-gong-ju-xiang-2025jing-xuan-tui-jian-yu-shi-yong-zhi-nan/'
      tabindex="-58">  独立游戏开发者工具箱：2025精选推荐与实用指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xu-huan-yin-qing-you-xi-kai-fa-xi-lie-zhuan-ti-guan-fang-bian-ma-biao-zhun-huo-gui-yue/'
      tabindex="-59">  虚幻引擎游戏开发系列专题-官方编码标准或规约</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiang-jie-she-ji-mo-shi-dan-li-de-jin-hua-zhi-lu/'
      tabindex="-60">  详解设计模式_单例的进化之路</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xie-e-de-fei-chang-liang-quan-ju-bian-liang/'
      tabindex="-61">  邪恶的非常量全局变量</a></span>
  </li>
</ul>
</div>
      <div class="viewer page" id="viewer" tabindex="0">
        <div class="tab">
<div class="file-manager" onclick='document.getElementById("files").classList.toggle("open"); document.getElementById("content").classList.toggle("close")'> </div>
<ul id="tabs">
</ul>


</div>
        <div class="content" id="content"><p>在之前的文章中已经提到过,当使用按值传递时会创建参数的一个副本到函数中。对于基本类型（复制成本较低），这是可以的。但对于类类型（如 <code>std::string</code> ），复制通常成本较高。我们可以通过使用（const）引用传递（或按地址传递）来避免进行昂贵的复制。</p>
<p>这篇文章主要介绍一些在关于使用引用返回和地址返回的基础知识。</p>
<p>下面是一个使用引用返回的程序:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">const</span><span> std::string&amp; </span><span style="color:#8fa1b3;">getProgramName</span><span>() </span><span style="color:#65737e;">// 返回一个常量引用
</span><span>{
</span><span>    </span><span style="color:#b48ead;">static const</span><span> std::string </span><span style="color:#bf616a;">s_programName </span><span>{ &quot;</span><span style="color:#a3be8c;">Calculator</span><span>&quot; }; </span><span style="color:#65737e;">// 具有静态存储期，在程序结束时销毁
</span><span>
</span><span>    </span><span style="color:#b48ead;">return</span><span> s_programName;
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">This program is named </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">getProgramName</span><span>();
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<hr />
<h2 id="fan-hui-yin-yong-de-dui-xiang-bi-xu-zai-han-shu-fan-hui-hou-cun-zai">返回引用的对象必须在函数返回后存在</h2>
<p>使用引用返回有一个重要的注意事项:程序员必须确保被引用的对象在返回引用的函数之后仍然存在,否则将会出现返回的引用悬空的情况(引用一个已被销毁的对象),使用该引用会导致为定义行为。</p>
<p>在上面的程序中,因为 <code>s_programName</code> 使用了<code>static</code>关键字修饰,具有静态持续时间，它的生命周期 <code>s_programName</code> 将存在到程序结束。当 <code>main()</code> 访问返回的引用时，它实际上是在访问 <code>s_programName</code> ，这是可以的，因为 <code>s_programName</code> 不会在之后被销毁。</p>
<p>现在让我们修改上述程序，以展示当我们的函数返回一个悬垂引用时会发生什么：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">const</span><span> std::string&amp; </span><span style="color:#8fa1b3;">getProgramName</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">const</span><span> std::string </span><span style="color:#bf616a;">programName </span><span>{ &quot;</span><span style="color:#a3be8c;">Calculator</span><span>&quot; }; </span><span style="color:#65737e;">// 现在是一个非静态局部变量，在函数结束时销毁
</span><span>
</span><span>    </span><span style="color:#b48ead;">return</span><span> programName;
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">这个程序的名称是 </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">getProgramName</span><span>(); </span><span style="color:#65737e;">// 未定义行为
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>程序的结果未定义。当 <code>getProgramName()</code> 返回时，返回一个绑定到局部变量 <code>programName</code> 的引用。然后，因为 <code>programName</code> 是一个具有自动持续时间的局部变量，所以在函数结束时销毁 <code>programName</code> 。这意味着返回的引用现在是悬垂的，在 <code>main()</code> 函数中使用 <code>programName</code> 会导致未定义的行为。</p>
<blockquote>
<p>对象通过引用返回时必须超出返回引用的函数的作用域,否则将会产生悬空引用。不要通过引用返回非静态的局部变量或者临时变量。</p>
</blockquote>
<hr />
<h2 id="lin-shi-dui-xiang-de-sheng-ming-zhou-qi-yan-chang-lifetime-extension-ji-zhi-bu-neng-kua-yue-han-shu-bian-jie-sheng-xiao">临时对象的生命周期延长（lifetime extension）机制，不能跨越函数边界生效。</h2>
<p><strong>临时对象:</strong></p>
<ul>
<li>临时对象是在表达式求值过程中创建的，但没有名字的对象。</li>
<li>例如，<code>std::string("Hello")</code> 会创建一个临时的 <code>std::string</code> 对象。</li>
</ul>
<p><strong>lifetime extension:</strong></p>
<ul>
<li>在某些特定情况下,C++编译器会延长临时对象的生命周期,以避免悬空引用;</li>
</ul>
<p>考虑下面这个返回临时变量的引用的例子:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">const int</span><span>&amp; </span><span style="color:#8fa1b3;">returnByConstReference</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">5</span><span>; </span><span style="color:#65737e;">// 返回临时对象的常量引用
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">const int</span><span>&amp; </span><span style="color:#bf616a;">ref </span><span>{ </span><span style="color:#bf616a;">returnByConstReference</span><span>() };
</span><span>
</span><span>    std::cout &lt;&lt; ref; </span><span style="color:#65737e;">// 未定义行为
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>在上述程序中， <code>returnByConstReference()</code> 返回一个整型字面量，但函数的返回类型是 <code>const int&amp;</code> 。这导致创建并返回一个绑定到包含值 5 的临时对象的临时引用。</p>
<p>由于 <code>returnByConstReference()</code> 返回的是临时对象的引用，而临时对象在函数返回后立即被销毁，因此 <code>ref</code> 变成了一个悬空引用（dangling reference）。</p>
<blockquote>
<p>当你在一个函数内部创建一个临时对象，并返回该临时对象的引用时，这个引用在函数外部使用时，其引用的对象可能已经被销毁，从而导致未定义行为。</p>
</blockquote>
<p>所谓的函数边界指的是函数的开始和结束。在函数内部创建的局部变量和临时对象，在函数结束时通常会被销毁。换句话说,如果你在一个函数中创建了一个临时对象，并返回了对它的引用，那么不要期望这个引用在函数外部仍然有效。因为临时对象的生命周期在函数结束时就结束了。</p>
<hr />
<h2 id="bu-yao-tong-guo-yin-yong-fan-hui-fei-constjing-tai-ju-bu-bian-liang">不要通过引用返回非<code>const</code>静态局部变量</h2>
<p>在第一个实例中,通过引用返回一个 const 静态局部变量，以简单的方式说明通过引用返回的机制。然而，通过引用返回非 const 静态局部变量相当不规范，通常应避免。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">const int</span><span>&amp; </span><span style="color:#8fa1b3;">getNextId</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">static int </span><span style="color:#bf616a;">s_x</span><span>{ </span><span style="color:#d08770;">0 </span><span>}; </span><span style="color:#65737e;">// 注意：变量是非 const 的
</span><span>    ++s_x; </span><span style="color:#65737e;">// 生成下一个 id
</span><span>    </span><span style="color:#b48ead;">return</span><span> s_x; </span><span style="color:#65737e;">// 并返回它的引用
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">const int</span><span>&amp; </span><span style="color:#bf616a;">id1 </span><span>{ </span><span style="color:#bf616a;">getNextId</span><span>() }; </span><span style="color:#65737e;">// id1 是一个引用
</span><span>    </span><span style="color:#b48ead;">const int</span><span>&amp; </span><span style="color:#bf616a;">id2 </span><span>{ </span><span style="color:#bf616a;">getNextId</span><span>() }; </span><span style="color:#65737e;">// id2 是一个引用
</span><span>
</span><span>    std::cout &lt;&lt; id1 &lt;&lt; id2 &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<blockquote>
<p>22</p>
</blockquote>
<p>程序之后后打印22,这是因为id1和id2引用的是同一个对象静态变量 <code>s_x</code> ），所以当任何内容（例如 <code>getNextId()</code> ）修改该值时，所有引用现在都访问的是修改后的值。</p>
<p>此示例可以通过将 <code>id1</code> 和 <code>id2</code> 设置为普通变量（而不是引用）来修复，这样它们将保存返回值的副本而不是 <code>s_x</code> 的引用。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">const int</span><span>&amp; </span><span style="color:#8fa1b3;">getNextId</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">static int </span><span style="color:#bf616a;">s_x</span><span>{ </span><span style="color:#d08770;">0 </span><span>};
</span><span>    ++s_x;
</span><span>    </span><span style="color:#b48ead;">return</span><span> s_x;
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">const int </span><span style="color:#bf616a;">id1 </span><span>{ </span><span style="color:#bf616a;">getNextId</span><span>() }; </span><span style="color:#65737e;">// id1 现在是一个普通变量，并接收 getNextId() 通过引用返回的值的拷贝
</span><span>    </span><span style="color:#b48ead;">const int </span><span style="color:#bf616a;">id2 </span><span>{ </span><span style="color:#bf616a;">getNextId</span><span>() }; </span><span style="color:#65737e;">// id1 现在是一个普通变量，并接收 getNextId() 通过引用返回的值的拷贝
</span><span>
</span><span>    std::cout &lt;&lt; id1 &lt;&lt; id2 &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>在上面的示例中， <code>getNextId()</code> 返回一个引用，但 <code>id1</code> 和 <code>id2</code> 是非引用变量。在这种情况下，返回的引用的值被复制到普通变量中。因此，这个程序打印：</p>
<blockquote>
<p>12</p>
</blockquote>
<hr />
<h2 id="tong-guo-yin-yong-fan-hui-yin-yong-can-shu">通过引用返回引用参数</h2>
<p>如果一个参数是通过引用传递给函数的，那么安全地通过引用返回该参数是没什么问题的,但是为了将一个参数传递给函数，该参数必须在调用者的作用域中存在。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string</span><span>&gt;
</span><span>
</span><span style="color:#65737e;">// 接受两个 std::string 对象，返回按字母顺序排列时较小的那个
</span><span style="color:#b48ead;">const</span><span> std::string&amp; </span><span style="color:#8fa1b3;">firstAlphabetical</span><span>(</span><span style="color:#b48ead;">const</span><span> std::string&amp; </span><span style="color:#bf616a;">a</span><span>, </span><span style="color:#b48ead;">const</span><span> std::string&amp; </span><span style="color:#bf616a;">b</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">return </span><span>(a &lt; b) ? a : b; </span><span style="color:#65737e;">// 使用 operator&lt; 进行字典序比较，确定哪个字符串在前
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    std::string </span><span style="color:#bf616a;">hello </span><span>{ &quot;</span><span style="color:#a3be8c;">Hello</span><span>&quot; };
</span><span>    std::string </span><span style="color:#bf616a;">world </span><span>{ &quot;</span><span style="color:#a3be8c;">World</span><span>&quot; };
</span><span>
</span><span>    std::cout &lt;&lt; </span><span style="color:#bf616a;">firstAlphabetical</span><span>(hello, world) &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;; </span><span style="color:#65737e;">// 输出按字母顺序排列时较小的字符串
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<blockquote>
<p>Hello</p>
</blockquote>
<p>如果我们使用按值传递和按值返回，我们将为 std::string 创建多达 3 个副本（每个参数一个，返回值一个）。通过使用按引用传递/按引用返回，我们可以避免这些副本。</p>
<hr />
<h2 id="ke-yi-jiang-tong-guo-const-yin-yong-chuan-di-de-you-zhi-yi-const-yin-yong-fan-hui">可以将通过 const 引用传递的右值以 const 引用返回。</h2>
<p>当一个 const 引用的参数是一个 rvalue 时，仍然可以通过 const 引用返回该参数。这是因为右值直到它们被创建的表达式结束才会被销毁。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string</span><span>&gt;
</span><span>
</span><span>std::string </span><span style="color:#8fa1b3;">getHello</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">Hello</span><span>&quot;;
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">const</span><span> std::string </span><span style="color:#bf616a;">s</span><span>{ </span><span style="color:#bf616a;">getHello</span><span>() };
</span><span>
</span><span>    std::cout &lt;&lt; s;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>在这种情况下， <code>getHello()</code> 返回一个 <code>std::string</code> 的值，这是一个右值。然后使用这个右值来初始化 <code>s</code> 。在初始化 <code>s</code> 之后右值被销毁。</p>
<hr />
<h2 id="diao-yong-zhe-tong-guo-yin-yong-xiu-gai-zhi">调用者通过引用修改值</h2>
<p>当一个参数通过非const引用传递给函数时,函数可以使用该引用来修改参数的值。同样,当从函数返回一个非const引用时,调用者可以使用该引用来修改返回的值。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">int</span><span>&amp; </span><span style="color:#8fa1b3;">max </span><span>(</span><span style="color:#b48ead;">int</span><span>&amp; </span><span style="color:#bf616a;">a</span><span>,</span><span style="color:#b48ead;">int</span><span>&amp; </span><span style="color:#bf616a;">b</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">return </span><span>(a &gt; b) ? a : b;
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">a</span><span>{ </span><span style="color:#d08770;">4 </span><span>};
</span><span>    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">b</span><span>{ </span><span style="color:#d08770;">10 </span><span>};
</span><span>
</span><span>    </span><span style="color:#bf616a;">max</span><span>(a, b) = </span><span style="color:#d08770;">7</span><span>; 
</span><span>
</span><span>    std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>函数最后将会打印:4 7</p>
<hr />
<h2 id="fan-hui-di-zhi">返回地址</h2>
<p>地址返回几乎与引用返回相同，只是返回的是对象的指针而不是对象的引用。返回地址的方式与通过引用返回有相同的注意事项——通过地址返回的对象必须比返回地址的函数的作用域长，否则调用者将收到一个悬空指针。</p>
<p>地址返回比引用返回的主要优势是，如果没有有效的对象返回，我们可以让函数返回 <code>nullptr</code> 。例如，假设我们有一个学生列表，我们想要在列表中搜索。如果我们找到了我们正在寻找的学生，我们可以返回一个指向表示匹配学生的对象的指针。如果没有找到匹配的学生，我们可以返回 <code>nullptr</code> 来表示未找到匹配的学生对象。</p>
<blockquote>
<p>感谢阅读,欢迎指正!</p>
</blockquote>

        </div>
      </div>
      <div class="prompt" id="terminal"><input
    type="text"
    id="setter"
    onkeydown="writeit(this, event);moveIt(this.value.length, event)"
    onchange="writeit(this, event)"
    onkeyup="writeit(this, event)"
    onkeypress="writeit(this, event);"
    >
<label for="setter" id="writer"> </label><b class="cursor" id="cursor"></b></div>
      <footer class="footer">
        <div class="footer-content">
          <p class="icp-info">
            <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer">黔ICP备2021010295号</a>
          </p>
        </div>
      </footer>
    </main>
  </body>

</html>
