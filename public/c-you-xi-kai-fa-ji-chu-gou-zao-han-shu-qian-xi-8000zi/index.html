<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>慕予博客</title>
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"
    integrity="sha256-WCzAhd2P6gRJF9Hv3oOOd+hFJi/QJbv+Azn4CGB8gfY=" crossorigin="anonymous" defer></script>
  <script src="/js/index.js" defer></script>
  <script src="/js/prompt.js" defer></script>
  <script src="/js/keyboard.js" defer></script>
  <script src="/js/tab.js" defer></script>
  <script src="/js/commands.js" defer></script>
  <script src="/js/config.js" defer></script><script src="/config.js"></script><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="style.css"><link rel="stylesheet" href="/css/page.css"></head><body onkeydown="exec(event)" style="background-image: url(&#x27;&#x2F;assets&#x2F;bg.jpg&#x27;); "><main>
      <div class="files" id="files" tabindex="0">
<ul>

  <li class="file">
    <span><a href='https://ilikexff.cn/8-kuan-rang-ni-kai-fa-qi-fei-de-intellijidea-cha-jian/'
      tabindex="-2">  8款让你开发起飞的IntellijIDEA插件</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/aop-jie-mi-qie-mian-bian-cheng-de-zong-he-zhi-nan/'
      tabindex="-3">  AOP揭秘：切面编程的综合指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-mei-ju-pian-yi-wu-fan-wei-mei-ju/'
      tabindex="-4">  C++游戏开发基础-枚举篇一：无范围枚举</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-std-optional/'
      tabindex="-5">  C++游戏开发基础-深入解析std::optional</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shen-ru-jie-xi-thiszhi-zhen-de-ying-yong-yu-ji-qiao/'
      tabindex="-6">  C++游戏开发基础-深入解析this指针的应用与技巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-fu-zhi-gou-zao-han-shu/'
      tabindex="-7">  C++游戏开发基础-深入解析复制构造函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-mo-ban-he-can-shu-tui-dao-zhi-nan/'
      tabindex="-8">  C++游戏开发基础-类模版和参数推导指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/dockerbi-zhi-bi-hui/'
      tabindex="-9">  Docker必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/githithub-xiao-ce/'
      tabindex="-10">  GitGitHub小册</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/google-hacking/'
      tabindex="-11">  Google Hacking</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/googleguan-fang-ti-shi-gong-cheng-bai-pi-shu-zhong-wen-yi-ben/'
      tabindex="-12">  Google官方《提示工程白皮书（中文译本）》</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-dai-ma-bu-quan-ti-shi-gong-neng-xiao-shi-de-ji-chong-jie-jue-fang-an-re-geng-ban/'
      tabindex="-13">  IDEA代码补全&amp;提示功能消失的几种解决方案(热更版)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-chen-jin-shi-bian-cheng-ti-yan/'
      tabindex="-14">  IDEA沉浸式编程体验</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-han-shu-shi-bian-cheng/'
      tabindex="-15">  Java函数式编程</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-ji-he-yuan-ma-qian-xi/'
      tabindex="-16">  Java集合源码浅析</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mysql-shi-wu-te-xing-yu-ge-chi-ji-bie-xiang-jie/'
      tabindex="-17">  MySQL_事务特性与隔离级别详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ocao-zuo-fu-shi-xian-mei-ju-de-shu-ru-shu-chu/'
      tabindex="-18">  O操作符,实现枚举的输入输出</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/prdsuan-fa-ting-shuo-ni-xiang-ping-yun-qi-chou-yi-ke-rong-yao-shui-jing/'
      tabindex="-19">  PRD算法：听说你想凭运气抽一颗荣耀水晶?</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/picgo-pei-zhi-ge-chong-tu-chuang/'
      tabindex="-20">  PicGo配置各种图床</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/redis-bi-zhi-bi-hui/'
      tabindex="-21">  Redis必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-zhong-de-move-yu-yi-sui-bi/'
      tabindex="-22">  Rust中的move语义随笔</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ssm-kuang-jia-shi-xian-ji-cheng-duan-xin-yan-zheng-ma-gong-neng/'
      tabindex="-23">  SSM框架实现集成短信验证码功能</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/slf4jyu-logbackshi-yong-zhi-nan-ji-yu-gradle/'
      tabindex="-24">  Slf4j与Logback实用指南(基于Gradle)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/spring-security5-xdao-spring-security6-xde-qian-yi/'
      tabindex="-25">  Spring Security5.x到Spring Security6.x的迁移</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springboot-webkai-fa-jing-jie/'
      tabindex="-26">  SpringBoot Web开发精解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springsecurity/'
      tabindex="-27">  SpringSecurity</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/unity6xia-jia-zhong-guo-qu-tuan-jie-yin-qing-jie-bang-zhe-shi-fen-lie-huan-shi-ben-di-hua-de-kai-shi/'
      tabindex="-28">  Unity6下架中国区，团结引擎接棒：这是分裂，还是本地化的开始？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-cong-0-dao-1-da-zao-quan-yu-yan-zhi-chi-de-mo-neng-bian-ji-qi-yu-fa-pian/'
      tabindex="-29">  Vim从0到1打造全语言支持的万能编辑器-语法篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-tiao-tou-powershell-pian/'
      tabindex="-30">  Vim折腾之 PowerShell篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-di-zhi-chuan-di-xiang-jie/'
      tabindex="-31">  [C++游戏开发基础]:地址传递详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-yin-yong-fan-hui-he-di-zhi-fan-hui/'
      tabindex="-32">  [C++游戏开发基础]:引用返回和地址返回</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-he-const/'
      tabindex="-33">  [C++游戏开发基础]:指针和const</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shu-ju-feng-zhuang-yin-cang-de-hao-chu/'
      tabindex="-34">  [C++游戏开发基础]:数据封装(隐藏)的好处</a></span>
  </li><li class="file">
    <span><a class="selected"href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-gou-zao-han-shu-qian-xi-8000zi/'
      tabindex="-35">  [C++游戏开发基础]:构造函数浅析(8000字)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-li-jie-kong-zhi-zhen/'
      tabindex="-36">  [C++游戏开发基础]:理解空指针</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-zhong-de-fang-wen-han-shu/'
      tabindex="-37">  [C++游戏开发基础]:类中的访问函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-de-ji-ben-gai-nian-li-jie/'
      tabindex="-38">  [C++游戏开发基础]指针的基本概念理解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/fanatical-wu-yue-feng-kuang-te-hui-wei-ni-de-steam-ku-jia-dian-liao/'
      tabindex="-39">  _Fanatical 五月疯狂特惠：为你的 Steam 库加点料！</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-kai-yuan-mi-ma-gong-ju-xpwd-zhong-wen-ban-bian-geng-ri-zhi/'
      tabindex="-40">  _Rust开源密码工具xpwd中文版变更日志</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/readme/'
      tabindex="-41">  readme</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wblog-bo-ke-xian-shang-bu-shu/'
      tabindex="-42">  wblog博客线上部署</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/shang-gu-shen-qi-vim-su-cheng-bei-wang-lu/'
      tabindex="-43">  上古神器_Vim速成备忘录</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mian-fei-ji-huo-quan-ban-ben-typora-zui-xin-ban-wei-li/'
      tabindex="-44">  免费激活全版本Typora，最新版为例</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-lombokxian-wei-ren-zhi-de-ji-ge-qi-ji-yin-qiao/'
      tabindex="-45">  关于Lombok鲜为人知的几个奇技淫巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-jie-kou-xian-liu-de-yi-ci-jian-dan-shi-jian/'
      tabindex="-46">  关于接口限流的一次简单实践</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/tu-jie-er-jin-zhi/'
      tabindex="-47">  图解二进制</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ru-he-xie-de-yi-shou-you-ya-gui-fan-de-springboot-jie-kou/'
      tabindex="-48">  如何写得一手优雅规范的SpringBoot 接口？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/kai-fa-bi-hui-xi-lie-jwtqian-tan/'
      tabindex="-49">  开发必会系列_JWT浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ji-qiao-jiu-shi-xiao-lu-chatgpt-diao-jiao-zhi-bei/'
      tabindex="-50">  技巧就是效率，ChatGPT调教指北</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-sheng-intellij-kai-fa-xiao-lu-zhe-kuan-dai-ma-tu-ding-cha-jian-codepins-zhi-de-yi-shi/'
      tabindex="-51">  提升 IntelliJ 开发效率？这款代码图钉插件 CodePins 值得一试</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-wen-de-zhi-hui-zhuan-zai/'
      tabindex="-52">  提问的智慧转载</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiao-lu-gong-ju-markdown/'
      tabindex="-53">  效率工具Markdown</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wu-wei-bing-fa-rust-sheng-ming-zhou-qi-qian-tan/'
      tabindex="-54">  无畏并发_Rust 生命周期浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-yu-de-bei-sai-er-qu-xian-gan-shou-si-hua-de-shu-xue-zhi-mei/'
      tabindex="-55">  游戏开发与的贝塞尔曲线_感受丝滑的数学之美</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-bi-bei-gao-xiao-de-aabb-qiu-ti-he-obb-peng-zhuang-jian-ce-suan-fa/'
      tabindex="-56">  游戏开发必备：高效的 AABB、球体和 OBB 碰撞检测算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-suan-fa-ji-chu-a-xun-lu-suan-fa-chi-xu-wei-hu/'
      tabindex="-57">  游戏算法基础-深入解析A*寻路算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/du-li-you-xi-kai-fa-zhe-gong-ju-xiang-2025jing-xuan-tui-jian-yu-shi-yong-zhi-nan/'
      tabindex="-58">  独立游戏开发者工具箱：2025精选推荐与实用指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xu-huan-yin-qing-you-xi-kai-fa-xi-lie-zhuan-ti-guan-fang-bian-ma-biao-zhun-huo-gui-yue/'
      tabindex="-59">  虚幻引擎游戏开发系列专题-官方编码标准或规约</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiang-jie-she-ji-mo-shi-dan-li-de-jin-hua-zhi-lu/'
      tabindex="-60">  详解设计模式_单例的进化之路</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xie-e-de-fei-chang-liang-quan-ju-bian-liang/'
      tabindex="-61">  邪恶的非常量全局变量</a></span>
  </li>
</ul>
</div>
      <div class="viewer page" id="viewer" tabindex="0">
        <div class="tab">
<div class="file-manager" onclick='document.getElementById("files").classList.toggle("open"); document.getElementById("content").classList.toggle("close")'> </div>
<ul id="tabs">
</ul>


</div>
        <div class="content" id="content"><h2 id="gou-zao-han-shu">构造函数</h2>
<p>构造函数是一种特殊的成员函数,在创建非聚合类类型对象后会自动被调用。当定义一个非聚合类类型对象时,编译器会检查是否能找到一个可以访问的构造函数,该构造函数与调用者提供的初始化值(如果有的情况下)相匹配。</p>
<ul>
<li>如果找到一个可访问的匹配构造函数，将为该对象分配内存，然后调用构造函数。</li>
<li>如果找不到合适的构造函数，则会生成编译错误。</li>
</ul>
<blockquote>
<ul>
<li>
<p>许多新手程序员可能不太清楚构造函数是否创建对象。实际上,它们不会创建对象,编译器在调用构造函数之前为对象分配内存,然后在未初始化的对象上调用构造函数。</p>
</li>
<li>
<p>然后,如果一组初始化参数找不到匹配的构造函数,则会出现编译错误。因此,虽然构造函数不创建对象,但是缺少匹配的构造函数将阻止对象的创建。</p>
</li>
</ul>
</blockquote>
<p>除了确定对象如何创建之外,构造函数通常还执行下面两个功能:</p>
<ul>
<li>它们通常通过成员初始化列表初始化任何成员。</li>
<li>可能执行其他操作,比如检查初始化值,打开文件或数据库等。 这些都是构造函数可以实现的。</li>
</ul>
<p>构造函数执行完毕之后,我们说该对象已经被“构造”完成,并且对象现在处于一致可用的状态。</p>
<hr />
<h2 id="gou-zao-han-shu-de-ming-ming">构造函数的命名</h2>
<p>与普通函数不同,构造函数必须遵循严格的命名规则:</p>
<ul>
<li>构造函数必须与类同名,这里的同名是严格意义上的,比如大小写一致。这个名称不包括模版参数。</li>
<li>构造函数没有返回类型,甚至没有<code>void</code>。</li>
</ul>
<p>由于构造函数通常是类接口的一部分,因此它们通常是公共的。</p>
<p>下面演示为一个程序添加一个基本的构造函数:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include</span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Foo
</span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_x {};
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_y {};
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">        </span><span style="color:#8fa1b3;">Foo</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">y</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">        {
</span><span style="color:#eff1f5;">            std::cout </span><span>&lt;&lt;&quot;</span><span style="color:#a3be8c;">Foo(</span><span>&quot; &lt;&lt;</span><span style="color:#eff1f5;"> x </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">,</span><span>&quot; &lt;&lt;</span><span style="color:#eff1f5;">y </span><span>&lt;&lt;&quot;</span><span style="color:#a3be8c;">)constructed</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const
</span><span style="color:#eff1f5;">        {
</span><span style="color:#eff1f5;">            std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">x: </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_x </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">, y: </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_y </span><span>&lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Foo </span><span style="color:#bf616a;">foo </span><span>{</span><span style="color:#d08770;">6</span><span>,</span><span style="color:#d08770;">7</span><span>};
</span><span>    foo.</span><span style="color:#bf616a;">print</span><span>();
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span><span>
</span></code></pre>
<p><img src="https://images.waer.ltd/notes/202503201750356.png" alt="image-20250320175001076" loading="lazy" decoding="async" /></p>
<p>当编译器看到定义<code>Foo foo{6,7}</code>时,它会寻找一个匹配的<code>Foo</code>构造函数,该构造函数可以接受两个<code>int</code>参数,在运行时，当 <code>foo</code> 被实例化时，会为 <code>foo</code> 分配内存，并调用 <code>Foo(int, int)</code> 构造函数，其中参数 <code>x</code> 被初始化为 <code>6</code> ，参数 <code>y</code> 被初始化为 <code>7</code> 。然后构造函数的主体执行并打印 <code>Foo(6, 7) constructed</code> 。</p>
<p>当我们调用 <code>print()</code> 成员函数时，你会发现成员 <code>m_x</code> 和 <code>m_y</code> 的值为 0。这是因为虽然我们的 <code>Foo(int, int)</code> 构造函数被调用了，但它实际上并没有初始化成员。别急,后文会逐步体现。</p>
<hr />
<h2 id="">构造函数不能是const</h2>
<p>构造函数需要初始化正在构造的对象,因此,构造函数不能是<code>const</code>。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Something
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_x</span><span style="color:#eff1f5;">{}; </span><span style="color:#65737e;">// 私有成员变量 m_x，默认初始化为 0
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Something</span><span style="color:#eff1f5;">() </span><span style="color:#65737e;">// 构造函数必须是非常量（non-const）的
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">m_x </span><span>= </span><span style="color:#d08770;">5</span><span style="color:#eff1f5;">; </span><span style="color:#65737e;">// 在非常量构造函数中可以修改成员变量
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">getX</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#eff1f5;">{ </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_x</span><span style="color:#eff1f5;">; } </span><span style="color:#65737e;">// 常成员函数，不能修改成员变量
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">const</span><span> Something </span><span style="color:#bf616a;">s</span><span>{}; </span><span style="color:#65737e;">// 定义常量对象 s，并隐式调用（非常量的）构造函数
</span><span>
</span><span>    std::cout &lt;&lt; s.</span><span style="color:#bf616a;">getX</span><span>(); </span><span style="color:#65737e;">// 输出 5
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p><code>const</code> 对象仍然可以调用非 <code>const</code> 构造函数，因为 <code>const</code> 限制只影响对象创建后，<strong>不影响初始化</strong>。</p>
<hr />
<h2 id="-1">通过成员初始化列表进行成员初始化</h2>
<p>为了让构造函数初始化成员，我们使用成员初始化列表（通常称为“成员初始化列表”）来完成。不要将这个与用于用值列表初始化聚合体的同名“初始化列表”混淆。</p>
<p>成员初始化列表最好通过示例来学习。在下面的例子中，我们的 <code>Foo(int, int)</code> 构造函数已经被更新为使用成员初始化列表来初始化 <code>m_x</code> 和 <code>m_y</code> 。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Foo
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_x {};
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_y {};
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Foo</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">y</span><span style="color:#eff1f5;">): </span><span style="color:#bf616a;">m_x </span><span style="color:#eff1f5;">{ x }, </span><span style="color:#bf616a;">m_y </span><span style="color:#eff1f5;">{ y } </span><span style="color:#65737e;">// here&#39;s our member initialization list
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Foo(</span><span>&quot; &lt;&lt;</span><span style="color:#eff1f5;"> x </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">, </span><span>&quot; &lt;&lt;</span><span style="color:#eff1f5;"> y </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">) constructed</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Foo(</span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_x </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">, </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_y </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">)</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Foo </span><span style="color:#bf616a;">foo</span><span>{ </span><span style="color:#d08770;">6</span><span>, </span><span style="color:#d08770;">7 </span><span>};
</span><span>    foo.</span><span style="color:#bf616a;">print</span><span>();
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>成员初始化列表定义在构造函数参数之后。它以冒号（:）开始，然后列出每个要初始化的成员及其对应的初始化值，用逗号分隔。</p>
<p>这里必须使用<strong>直接初始化形式</strong>（最好使用花括号，但圆括号也可以）——使用拷贝初始化（带有等号）在这里不起作用。另外请注意，<strong>成员初始化列表不以分号结尾</strong>。</p>
<p>当 <code>foo</code> 被实例化时，初始化列表中的成员将使用指定的初始化值进行初始化。在这种情况下，成员初始化列表将 <code>m_x</code> 初始化为 <code>x</code> 的值（ <code>x</code> 的值是 <code>6</code> ），并将 <code>m_y</code> 初始化为 <code>y</code> 的值（ <code>y</code> 的值是 <code>7</code> ）。然后构造函数的主体运行。</p>
<p>当调用 <code>print()</code> 成员函数时，你可以看到 <code>m_x</code> 仍然具有值 <code>6</code> ， <code>m_y</code> 仍然具有值 <code>7</code></p>
<hr />
<h2 id="-2">成员初始化列表格式化</h2>
<p>C++提供类很多自由来格式化你的成员初始化列表,因为它们并不关心你在冒号、逗号或空格位置上做了什么。所以一下样式都是有效的。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#bf616a;">Foo</span><span>(</span><span style="color:#b48ead;">int</span><span> x, </span><span style="color:#b48ead;">int</span><span> y) : </span><span style="color:#bf616a;">m_x </span><span>{ x }, </span><span style="color:#bf616a;">m_y </span><span>{ y }
</span><span>{
</span><span>}
</span></code></pre>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#bf616a;">Foo</span><span>(</span><span style="color:#b48ead;">int</span><span> x, </span><span style="color:#b48ead;">int</span><span> y) :
</span><span>    </span><span style="color:#bf616a;">m_x </span><span>{ x },
</span><span>    </span><span style="color:#bf616a;">m_y </span><span>{ y }
</span><span>{
</span><span>}
</span></code></pre>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#bf616a;">Foo</span><span>(</span><span style="color:#b48ead;">int</span><span> x, </span><span style="color:#b48ead;">int</span><span> y)
</span><span>    : </span><span style="color:#bf616a;">m_x </span><span>{ x }
</span><span>    , </span><span style="color:#bf616a;">m_y </span><span>{ y }
</span><span>{
</span><span>}
</span></code></pre>
<p>推荐使用上面第三种格式:</p>
<ul>
<li>构造函数名称后面跟一个冒号,这样可以干净的将成员初始化列表与函数原型分开。</li>
<li>缩进的成员初始化列表以便于更容易看到函数名称。</li>
</ul>
<p>如果成员初始化列表简短的情况下, 所有的初始化项可以放在一行上:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#bf616a;">Foo</span><span>(</span><span style="color:#b48ead;">int</span><span> x, </span><span style="color:#b48ead;">int</span><span> y)
</span><span>    : </span><span style="color:#bf616a;">m_x </span><span>{ x }, </span><span style="color:#bf616a;">m_y </span><span>{ y }
</span><span>{
</span><span>}
</span></code></pre>
<p>否则（或者如果你更喜欢），每个成员和初始化器可以分别放在单独的行上（以逗号开头以保持对齐）：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#bf616a;">Foo</span><span>(</span><span style="color:#b48ead;">int</span><span> x, </span><span style="color:#b48ead;">int</span><span> y)
</span><span>    : </span><span style="color:#bf616a;">m_x </span><span>{ x }
</span><span>    , </span><span style="color:#bf616a;">m_y </span><span>{ y }
</span><span>{
</span><span>}
</span></code></pre>
<hr />
<h2 id="-3">成员初始化顺序</h2>
<p>因为C++标准规定,成员初始化列表中的成员总是按照类中定义的顺序进行初始化。 在上面的例子中,由于 <code>m_x</code> 在类定义中定义在 <code>m_y</code> 之前， <code>m_x</code> 将首先被初始化（即使它在成员初始化列表中没有被列出在最前面）。</p>
<p><strong>最佳实践</strong></p>
<blockquote>
<p>成员在成员初始化列表中应该按照它们在类中定义的顺序列出。一些编译器会在成员初始化顺序不正确时发出警告。</p>
</blockquote>
<p>另外，最好避免使用其他成员的值来初始化成员（如果可能的话）。这样，即使你在初始化顺序上犯了错误，也不会有太大影响，因为初始化值之间没有依赖关系。</p>
<hr />
<h2 id="-4">成员初始化列表和默认成员初始化器</h2>
<p>成员可以一下几种不同的方式初始化:</p>
<ul>
<li>如果成员在成员初始化列表中列出,将优先使用该初始化值。</li>
<li>否则,如果成员具有默认的成员初始化器,则使用该默认值进行初始化。</li>
<li>否则该成员将使用默认初始化。</li>
</ul>
<p>这意味着如果成员既有默认成员初始化器，又在构造函数的成员初始化列表中列出，那么成员初始化列表中的值将优先。</p>
<p>看代码:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Foo
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_x {};    </span><span style="color:#65737e;">// 默认成员初始化（将被构造函数初始化列表覆盖）
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_y { </span><span style="color:#d08770;">2 </span><span style="color:#eff1f5;">}; </span><span style="color:#65737e;">// 默认成员初始化（如果未在构造函数中显式初始化，将使用此值）
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_z</span><span style="color:#eff1f5;">;      </span><span style="color:#65737e;">// 没有初始化，值不确定（未定义行为）
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Foo</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">        : </span><span style="color:#bf616a;">m_x </span><span style="color:#eff1f5;">{ x } </span><span style="color:#65737e;">// 成员初始化列表，m_x 被初始化为 x（覆盖默认初始化）
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Foo constructed</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">; </span><span style="color:#65737e;">// 输出构造函数被调用的提示
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// 输出对象的成员变量值
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Foo(</span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_x </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">, </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_y </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">, </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_z </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">)</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Foo </span><span style="color:#bf616a;">foo </span><span>{ </span><span style="color:#d08770;">6 </span><span>}; </span><span style="color:#65737e;">// 创建 Foo 对象，m_x 被初始化为 6，m_y 仍然是 2，m_z 未初始化（值不确定）
</span><span>    foo.</span><span style="color:#bf616a;">print</span><span>();   </span><span style="color:#65737e;">// 调用 print() 打印成员变量的值
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<hr />
<h2 id="-5">构造函数的函数体</h2>
<p>构造函数的函数体通常留空。这是因为我们主要使用构造函数进行初始化,这是通过成员初始化列表完成的。如果仅需要进行这些初始化操作,那么构造函数函数体中就不需要任何语句。</p>
<p>然而,因为构造函数体内语句的执行是在成员初始化列表之后,所以我们可以在其中添加语句来完成任何其他初始化任务。</p>
<p>在上述示例中，我们向控制台打印一些内容以显示构造函数已执行，但我们也可以执行其他操作，例如打开文件或数据库、分配内存等…</p>
<blockquote>
<p>优先在构造函数成员初始化列表中初始化成员，而不是在构造函数体中赋值。</p>
</blockquote>
<h2 id="-6">检测和处理构造函数中的无效参数</h2>
<p>考虑下面的程序:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Fraction
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_numerator {};
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_denominator {};
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Fraction</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">numerator</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">denominator</span><span style="color:#eff1f5;">):
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">m_numerator </span><span style="color:#eff1f5;">{ numerator }, </span><span style="color:#bf616a;">m_denominator </span><span style="color:#eff1f5;">{ denominator }
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span></code></pre>
<p>因为分数是由分子除以分母得到的，所以分数的分母不能为零（否则会得到除以零，这是数学上未定义的）。换句话说，这个类中 <code>m_denominator</code> 不能为 <code>0</code> 。</p>
<p>当用户尝试创建一个分母为零的分数（例如 <code>Fraction f { 1, 0 };</code> ）时，我们应该怎么做？</p>
<p>在成员初始化列表中，我们检测和处理错误的工具相当有限。我们可以使用条件运算符来检测错误，但接下来呢？</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Fraction
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_numerator {};
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_denominator {};
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Fraction</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">numerator</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">denominator</span><span style="color:#eff1f5;">):
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">m_numerator </span><span style="color:#eff1f5;">{ numerator }, </span><span style="color:#bf616a;">m_denominator </span><span style="color:#eff1f5;">{ denominator </span><span>!= </span><span style="color:#d08770;">0.0 </span><span>?</span><span style="color:#eff1f5;"> denominator </span><span>: ??? </span><span style="color:#eff1f5;">} </span><span style="color:#65737e;">// 然后呢,接下来怎么做?
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span></code></pre>
<p>你可能会想到,我们可以将分母改为一个有效的值,但是这样用户得到的结果就不会包含它们要求的值了,而且我们也没有办法通知他们做了非法操作。</p>
<p>因此,我们通常不会在成员初始化列表中尝试进行任何类型的验证,在大多数情况下,我们没有足够的信息支持我们完全在狗仔函数内部解决这些问题,因此在狗仔构造函数内部修复这些问题显然不是什么好主意。</p>
<blockquote>
<p>对于非成员函数和非特殊成员函数，我们可以将错误传递给调用者处理。但是构造函数没有返回值，所以我们没有好的方法来做这一点。在某些情况下，我们可以添加一个 <code>isValid()</code> 成员函数（或重载转换为 <code>bool</code> ），返回对象当前是否处于有效状态。例如，一个 <code>isValid()</code> 函数对于 <code>Fraction</code> 会返回 <code>true</code> 当 <code>m_denominator != 0.0</code> 。但这意味着调用者必须记住每次创建新的 Fraction 对象时都调用该函数。并且使语义上无效的对象可访问可能会导致错误。</p>
</blockquote>
<ul>
<li>在某些类型的程序中，我们可以直接停止整个程序，并让用户重新运行程序并输入正确的数据……但在大多数情况下，这根本不可接受。</li>
<li>异常会完全终止构造的过程,这意味着用户永远不会获得一个语义上无效的对象。因此,大多数情况下,抛出异常是最好的做法。</li>
</ul>
<p>当然,如果无法或者不想使用异常抛出的方式,我们还有一个合理的选择:</p>
<p>那就是不让用户直接创建类,可以提供一个函数,该函数要么返回一个实例,要么返回一个表示失败的值。</p>
<p>在下面的例子中，我们的 <code>createFraction()</code> 函数返回一个 <code>std::optional&lt;Fraction&gt;</code> ，该 <code>std::optional&lt;Fraction&gt;</code> 可能包含一个有效的 <code>Fraction</code> 。如果包含，则我们可以使用该 <code>Fraction</code>。如果不包含，则调用者可以检测到并处理这种情况。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">optional</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Fraction
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_numerator { </span><span style="color:#d08770;">0 </span><span style="color:#eff1f5;">};   </span><span style="color:#65737e;">// 分子，默认为 0
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_denominator { </span><span style="color:#d08770;">1 </span><span style="color:#eff1f5;">}; </span><span style="color:#65737e;">// 分母，默认为 1
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// 私有构造函数，外部无法直接调用
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Fraction</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">numerator</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">denominator</span><span style="color:#eff1f5;">):
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">m_numerator </span><span style="color:#eff1f5;">{ numerator }, </span><span style="color:#bf616a;">m_denominator </span><span style="color:#eff1f5;">{ denominator }
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// 允许该友元函数访问私有成员
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">friend</span><span style="color:#eff1f5;"> std::optional&lt;Fraction&gt; createFraction(</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> numerator, </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> denominator);
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#65737e;">// 负责创建 Fraction 实例的函数，返回 std::optional&lt;Fraction&gt;
</span><span>std::optional&lt;Fraction&gt; </span><span style="color:#8fa1b3;">createFraction</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">numerator</span><span>, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">denominator</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">if </span><span>(denominator == </span><span style="color:#d08770;">0</span><span>) </span><span style="color:#65737e;">// 分母不能为 0，否则返回空 optional
</span><span>        </span><span style="color:#b48ead;">return </span><span>{};
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">Fraction</span><span>{numerator, denominator}; </span><span style="color:#65737e;">// 否则返回合法的 Fraction
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">auto </span><span style="color:#bf616a;">f1 </span><span>{ </span><span style="color:#bf616a;">createFraction</span><span>(</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">1</span><span>) }; </span><span style="color:#65737e;">// 创建合法分数 0/1
</span><span>    </span><span style="color:#b48ead;">if </span><span>(f1) </span><span style="color:#65737e;">// 检查是否成功创建
</span><span>    {
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Fraction created</span><span style="color:#96b5b4;">\n</span><span>&quot;; </span><span style="color:#65737e;">// 输出 &quot;Fraction created&quot;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">auto </span><span style="color:#bf616a;">f2 </span><span>{ </span><span style="color:#bf616a;">createFraction</span><span>(</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>) }; </span><span style="color:#65737e;">// 试图创建非法分数 0/0
</span><span>    </span><span style="color:#b48ead;">if </span><span>(!f2) </span><span style="color:#65737e;">// 检查创建是否失败
</span><span>    {
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Bad fraction</span><span style="color:#96b5b4;">\n</span><span>&quot;; </span><span style="color:#65737e;">// 输出 &quot;Bad fraction&quot;
</span><span>    }
</span><span>}
</span></code></pre>
<hr />
<h2 id="-7">默认构造函数以及参数</h2>
<p>默认构造函数是一个不需要参数的构造函数,通常,这是一个没有参数定义的构造函数。
看个示例:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Foo
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Foo</span><span style="color:#eff1f5;">() </span><span style="color:#65737e;">// 默认构造函数
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Foo default constructed</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Foo </span><span style="color:#bf616a;">foo</span><span>{}; </span><span style="color:#65737e;">// 没有初始化值，调用foo的默认构造函数
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>如果一个类类型<strong>有默认构造函数</strong>，那么<strong>值初始化（value initialization）</strong> 和 <strong>默认初始化（default initialization）</strong> 都会调用默认构造函数。因此，对于这样的类（比如示例中的 Foo 类），以下两种写法本质上是等价的：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>Foo </span><span style="color:#bf616a;">foo</span><span>{};  </span><span style="color:#65737e;">// 值初始化，调用 Foo() 默认构造函数
</span><span>Foo foo2;   </span><span style="color:#65737e;">// 默认初始化，调用 Foo() 默认构造函数
</span></code></pre>
<blockquote>
<p>对于所有类类型，优先使用值初始化而不是默认初始化。</p>
</blockquote>
<hr />
<h2 id="-8">带有默认参数的构造函数</h2>
<p>与所有函数一样,构造函数的最右侧参数可以有默认参数。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include</span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Foo
</span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_x {};
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_y {};
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Foo</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span>=</span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">,</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">y</span><span>=</span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">) </span><span style="color:#65737e;">// 带有默认参数的构造函数
</span><span style="color:#eff1f5;">    : </span><span style="color:#bf616a;">m_x </span><span style="color:#eff1f5;">{x}
</span><span style="color:#eff1f5;">    , </span><span style="color:#bf616a;">m_y </span><span style="color:#eff1f5;">{y}
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt;&quot;</span><span style="color:#a3be8c;">Foo(</span><span>&quot;&lt;&lt;</span><span style="color:#bf616a;">m_x</span><span>&lt;&lt;&quot;</span><span style="color:#a3be8c;">,</span><span>&quot;&lt;&lt;</span><span style="color:#bf616a;">m_y</span><span>&lt;&lt;&quot;</span><span style="color:#a3be8c;">) constructed</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Foo </span><span style="color:#bf616a;">foo1</span><span>{}; </span><span style="color:#65737e;">// 调用Foo(int,int)构造函数并使用默认参数初始化
</span><span>    Foo </span><span style="color:#bf616a;">foo2</span><span>{</span><span style="color:#d08770;">6</span><span>,</span><span style="color:#d08770;">7</span><span>}; </span><span style="color:#65737e;">// 调用Foo(int,int) 构造函数
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span><span>
</span></code></pre>
<p><img src="https://images.waer.ltd/notes/202503211803678.png" alt="image-20250321180326324" loading="lazy" decoding="async" /></p>
<p>如果一个构造函数<strong>所有参数</strong>都有默认值，那么它就可以像默认构造函数一样工作，<strong>可以在不传递任何参数的情况下调用</strong>，因此它就是一个<strong>默认构造函数</strong>。</p>
<hr />
<h2 id="-9">构造函数重载</h2>
<p>由于构造函数也是函数,因此也可以被重载。也就是说,我们可以有多个构造函数,以便以不同的方式创建对象。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include</span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span>    </span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Foo
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_x {};
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_y {};
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">        </span><span style="color:#8fa1b3;">Foo</span><span style="color:#eff1f5;">() </span><span style="color:#65737e;">// 默认构造函数
</span><span style="color:#eff1f5;">        {
</span><span style="color:#eff1f5;">            std::cout </span><span>&lt;&lt;&quot;</span><span style="color:#a3be8c;">Foo() constructed</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">        </span><span style="color:#8fa1b3;">Foo</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span style="color:#eff1f5;">,</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">y</span><span style="color:#eff1f5;">) </span><span style="color:#65737e;">// 非默认构造函数
</span><span style="color:#eff1f5;">        : </span><span style="color:#bf616a;">m_x </span><span style="color:#eff1f5;">{x}
</span><span style="color:#eff1f5;">        , </span><span style="color:#bf616a;">m_y </span><span style="color:#eff1f5;">{y}
</span><span style="color:#eff1f5;">        {
</span><span style="color:#eff1f5;">            std::cout </span><span>&lt;&lt;&quot;</span><span style="color:#a3be8c;">Foo(</span><span>&quot;&lt;&lt;</span><span style="color:#bf616a;">m_x</span><span>&lt;&lt;&quot;</span><span style="color:#a3be8c;">,</span><span>&quot;&lt;&lt;</span><span style="color:#bf616a;">m_y</span><span>&lt;&lt;&quot;</span><span style="color:#a3be8c;">) constructed</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">    }</span><span>;
</span><span>
</span><span>    </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>    {
</span><span>        Foo </span><span style="color:#bf616a;">foo1</span><span>{}; </span><span style="color:#65737e;">// 调用Foo()构造函数并使用默认参数初始化
</span><span>        Foo </span><span style="color:#bf616a;">foo2</span><span>{</span><span style="color:#d08770;">6</span><span>,</span><span style="color:#d08770;">7</span><span>}; </span><span style="color:#65737e;">// 调用Foo(int,int) 构造函数
</span><span>
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>    }
</span><span>
</span></code></pre>
<p>以上结论的一个推论是,一个类应该只有一个默认构造函数。如果提供了多个默认构造函数,编译器将无法区分应该选择使用哪个构造函数而报错。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Foo
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_x {};
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_y {};
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Foo</span><span style="color:#eff1f5;">() </span><span style="color:#65737e;">// default constructor
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Foo constructed</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Foo</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span>=</span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">y</span><span>=</span><span style="color:#d08770;">2</span><span style="color:#eff1f5;">) </span><span style="color:#65737e;">// default constructor
</span><span style="color:#eff1f5;">        : </span><span style="color:#bf616a;">m_x </span><span style="color:#eff1f5;">{ x }, </span><span style="color:#bf616a;">m_y </span><span style="color:#eff1f5;">{ y }
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Foo(</span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_x </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">, </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_y </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">) constructed</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Foo </span><span style="color:#bf616a;">foo</span><span>{}; </span><span style="color:#65737e;">// 编译错误:不知道选用哪个默认构造函数
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>在上述示例中，我们使用无参数的方式实例化 <code>foo</code> ，因此编译器将查找默认构造函数。它会找到两个，并且无法区分应该使用哪个构造函数。这将导致编译错误。</p>
<hr />
<h2 id="-10">隐式默认构造函数</h2>
<p>如果非聚合类类型的对象没有用户声明的构造函数,编译器会生成一个公共的默认构造函数,这样类可以进行值初始化或默认初始化。这个构造函数就是隐式的默认构造函数。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Foo
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_x</span><span style="color:#eff1f5;">{};
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_y</span><span style="color:#eff1f5;">{};
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// 没有声明的构造函数
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Foo </span><span style="color:#bf616a;">foo</span><span>{};
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<ul>
<li>
<p>这个类没有用户声明的构造函数，所以编译器将为我们生成一个隐式默认构造函数。这个构造函数将用于实例化 <code>foo{}</code> 。</p>
</li>
<li>
<p>隐式默认构造函数等同于一个没有参数、没有成员初始化列表且构造函数体内没有语句的构造函数。换句话说，对于上述 <code>Foo</code> 类，编译器生成如下内容：</p>
</li>
</ul>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>public:
</span><span>    </span><span style="color:#bf616a;">Foo</span><span>() </span><span style="color:#65737e;">// 隐式生成默认构造函数
</span><span>    {
</span><span>    }
</span></code></pre>
<p><strong>隐式默认构造函数</strong>（implicit default constructor）在<strong>类没有数据成员</strong>的情况下通常比较有用。但<strong>如果一个类有数据成员</strong>，我们通常希望它们可以用<strong>用户提供的值进行初始化</strong>，而<strong>隐式默认构造函数无法满足这个需求</strong>。</p>
<p>在某些情况下，我们可能会手动编写一个<strong>默认构造函数</strong>，但它的行为实际上和<strong>编译器隐式生成的默认构造函数</strong>完全一样。</p>
<p><strong>在这种情况下，我们可以使用 = default 告诉编译器生成默认构造函数，而不必自己写一个。<strong>这种构造函数被称为</strong>显式默认化的默认构造函数</strong>（explicitly defaulted default constructor）。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Foo
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_x {};
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_y {};
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Foo</span><span style="color:#eff1f5;">() </span><span>= </span><span style="color:#b48ead;">default</span><span style="color:#eff1f5;">; </span><span style="color:#65737e;">// 生成一个显式默认构造函数
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Foo</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">y</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">        : </span><span style="color:#bf616a;">m_x </span><span style="color:#eff1f5;">{ x }, </span><span style="color:#bf616a;">m_y </span><span style="color:#eff1f5;">{ y }
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Foo(</span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_x </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">, </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_y </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">) constructed</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Foo </span><span style="color:#bf616a;">foo</span><span>{}; </span><span style="color:#65737e;">// 调用 Foo() 默认构造函数
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>在上述示例中，由于我们声明了一个用户自定义构造函数（ <code>Foo(int, int)</code> ），通常不会生成隐式默认构造函数。然而，因为我们告诉编译器需要为我们生成这样的构造函数，那么它将会生成。这个构造函数随后将被我们对 <code>foo{}</code> 的实例化使用。</p>
<blockquote>
<p>优先使用显式默认构造函数(<code>=default)</code>,而不是空主体的默认构造函数。</p>
</blockquote>
<hr />
<h2 id="-11">显式默认化的默认构造函数与空的用户定义构造函数区别</h2>
<ul>
<li>
<p>当使用值初始化一个类时,如果该类具有用户定义的默认构造函数,对象将会进行默认初始化。但是如果该类有一个未由用户提供的默认构造函数即，一个隐式定义的默认构造函数，或者使用 <code>= default</code> 定义的默认构造函数）,那么在默认初始化之前,该对象将被进行零初始化。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">User
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_a</span><span style="color:#eff1f5;">; </span><span style="color:#65737e;">// 注意：没有默认初始化值
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_b {}; </span><span style="color:#65737e;">// 默认初始化为 0
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">User</span><span style="color:#eff1f5;">() {} </span><span style="color:#65737e;">// 用户定义的空构造函数
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">a</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#eff1f5;">{ </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_a</span><span style="color:#eff1f5;">; }
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">b</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#eff1f5;">{ </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_b</span><span style="color:#eff1f5;">; }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Default
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_a</span><span style="color:#eff1f5;">; </span><span style="color:#65737e;">// 注意：没有默认初始化值
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_b {}; </span><span style="color:#65737e;">// 默认初始化为 0
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Default</span><span style="color:#eff1f5;">() </span><span>= </span><span style="color:#b48ead;">default</span><span style="color:#eff1f5;">; </span><span style="color:#65737e;">// 显式默认化的默认构造函数
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">a</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#eff1f5;">{ </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_a</span><span style="color:#eff1f5;">; }
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">b</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#eff1f5;">{ </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_b</span><span style="color:#eff1f5;">; }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Implicit
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_a</span><span style="color:#eff1f5;">; </span><span style="color:#65737e;">// 注意：没有默认初始化值
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_b {}; </span><span style="color:#65737e;">// 默认初始化为 0
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// 隐式默认构造函数（编译器自动生成）
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">a</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#eff1f5;">{ </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_a</span><span style="color:#eff1f5;">; }
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">b</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#eff1f5;">{ </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_b</span><span style="color:#eff1f5;">; }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    User </span><span style="color:#bf616a;">user</span><span>{}; </span><span style="color:#65737e;">// 默认初始化（m_a 未初始化，m_b 初始化为 0）
</span><span>    std::cout &lt;&lt; user.</span><span style="color:#bf616a;">a</span><span>() &lt;&lt; &#39; &#39; &lt;&lt; user.</span><span style="color:#bf616a;">b</span><span>() &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>
</span><span>    Default </span><span style="color:#bf616a;">def</span><span>{}; </span><span style="color:#65737e;">// 先零初始化（m_a、m_b 设为 0），然后默认初始化
</span><span>    std::cout &lt;&lt; def.</span><span style="color:#bf616a;">a</span><span>() &lt;&lt; &#39; &#39; &lt;&lt; def.</span><span style="color:#bf616a;">b</span><span>() &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>
</span><span>    Implicit </span><span style="color:#bf616a;">imp</span><span>{}; </span><span style="color:#65737e;">// 先零初始化（m_a、m_b 设为 0），然后默认初始化
</span><span>    std::cout &lt;&lt; imp.</span><span style="color:#bf616a;">a</span><span>() &lt;&lt; &#39; &#39; &lt;&lt; imp.</span><span style="color:#bf616a;">b</span><span>() &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>上面程序在我的电脑上的打印结果:</p>
<p><img src="https://images.waer.ltd/notes/202503211834070.png" alt="image-20250321183413006" loading="lazy" decoding="async" /></p>
</li>
<li>
<p>在 C++20 之前，如果一个类具有用户定义的默认构造函数（即使它的函数体为空），那么该类就不再被视为聚合类型（aggregate）。然而，如果使用 = default 语法显式地默认化默认构造函数，则不会影响该类仍然被视为聚合类型。</p>
<p>假设该类在其他方面符合聚合类型的要求，前者（用户定义的默认构造函数）会导致类使用<strong>列表初始化（list initialization）</strong>，而不是<strong>聚合初始化（aggregate initialization）</strong>。</p>
<p>从 C++20 开始，这个不一致性被修正了，使得<strong>无论是用户定义的空默认构造函数，还是显式默认化的默认构造函数，都会使类变为非聚合类型</strong>。</p>
<hr />
<h2 id="-12">创建默认构造函数的时机</h2>
<p>默认构造函数允许我们在没有提供初始化值的情况下创建<strong>非聚合类</strong>类型的对象。因此，<strong>只有当一个类的对象在默认情况下可以合理地被创建时，才应该提供默认构造函数</strong>。</p>
<p>换句话说，如果一个类的所有成员变量都可以有一个合理的默认值（例如 0、nullptr、空字符串等），那么提供默认构造函数是合适的。否则，类应该要求用户提供必要的初始化值，以确保对象在创建时处于有效的状态。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Fraction
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_numerator</span><span style="color:#eff1f5;">{ </span><span style="color:#d08770;">0 </span><span style="color:#eff1f5;">};    </span><span style="color:#65737e;">// 分子，默认初始化为 0
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_denominator</span><span style="color:#eff1f5;">{ </span><span style="color:#d08770;">1 </span><span style="color:#eff1f5;">};  </span><span style="color:#65737e;">// 分母，默认初始化为 1
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Fraction</span><span style="color:#eff1f5;">() </span><span>= </span><span style="color:#b48ead;">default</span><span style="color:#eff1f5;">;    </span><span style="color:#65737e;">// 显式声明默认构造函数
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Fraction</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">numerator</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">denominator</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">        : </span><span style="color:#bf616a;">m_numerator</span><span style="color:#eff1f5;">{ numerator }
</span><span style="color:#eff1f5;">        , </span><span style="color:#bf616a;">m_denominator</span><span style="color:#eff1f5;">{ denominator }
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Fraction(</span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_numerator </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">, </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_denominator </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">)</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Fraction </span><span style="color:#bf616a;">f1 </span><span>{</span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">5</span><span>};  </span><span style="color:#65737e;">// 使用带参数的构造函数
</span><span>    f1.</span><span style="color:#bf616a;">print</span><span>();
</span><span>
</span><span>    Fraction </span><span style="color:#bf616a;">f2 </span><span>{};  </span><span style="color:#65737e;">// 由于 `= default`，使用默认构造函数
</span><span>    f2.</span><span style="color:#bf616a;">print</span><span>();
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>对于表示<strong>分数（Fraction）的类来说，允许用户不提供初始化值</strong>来创建 Fraction 对象是合理的。在这种情况下，用户会得到默认的分数 0/1。</p>
<p>现在考虑下面这个类:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string_view</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Employee
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    std::string </span><span style="color:#bf616a;">m_name</span><span style="color:#eff1f5;">{ };
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_id</span><span style="color:#eff1f5;">{ };
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Employee</span><span style="color:#eff1f5;">(std::string_view </span><span style="color:#bf616a;">name</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">id</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">        : </span><span style="color:#bf616a;">m_name</span><span style="color:#eff1f5;">{ name }
</span><span style="color:#eff1f5;">        , </span><span style="color:#bf616a;">m_id</span><span style="color:#eff1f5;">{ id }
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Employee(</span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_name </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">, </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_id </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">)</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Employee </span><span style="color:#bf616a;">e1 </span><span>{ &quot;</span><span style="color:#a3be8c;">Joe</span><span>&quot;, </span><span style="color:#d08770;">1 </span><span>};
</span><span>    e1.</span><span style="color:#bf616a;">print</span><span>();
</span><span>
</span><span>    Employee </span><span style="color:#bf616a;">e2 </span><span>{}; </span><span style="color:#65737e;">//编译错误：无匹配的构造函数
</span><span>    e2.</span><span style="color:#bf616a;">print</span><span>();
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>现实中，一个员工对象<strong>必须有名字</strong>，否则不合理。因此，我们<strong>不应该提供默认构造函数</strong>，这样如果用户尝试创建无名员工，就会<strong>导致编译错误</strong>，提醒用户必须提供参数。</p>
<hr />
<h2 id="-13">委托构造函数</h2>
<p>在 C++ 中，<strong>委托构造函数</strong>（<strong>Delegating Constructors</strong>）允许一个构造函数<strong>调用同一个类中的另一个构造函数</strong>，以减少代码重复，提高可维护性。</p>
<p>当一个类包含多个构造函数时，每个构造函数中的代码通常非常相似，甚至完全相同，有大量的重复。我们同样希望尽可能去除构造函数中的冗余代码。</p>
<p>看这个例子:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string_view</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Employee
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    std::string m_name { </span><span>&quot;</span><span style="color:#a3be8c;">???</span><span>&quot; </span><span style="color:#eff1f5;">}; </span><span style="color:#65737e;">// 默认名称为 &quot;???&quot;
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_id { </span><span style="color:#d08770;">0 </span><span style="color:#eff1f5;">};               </span><span style="color:#65737e;">// 默认 ID 为 0
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">bool</span><span style="color:#eff1f5;"> m_isManager { </span><span style="color:#d08770;">false </span><span style="color:#eff1f5;">};   </span><span style="color:#65737e;">// 默认不是经理
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Employee</span><span style="color:#eff1f5;">(std::string_view </span><span style="color:#bf616a;">name</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">id</span><span style="color:#eff1f5;">) </span><span style="color:#65737e;">// 员工必须要有姓名和 ID
</span><span style="color:#eff1f5;">        : </span><span style="color:#bf616a;">m_name</span><span style="color:#eff1f5;">{ name }, </span><span style="color:#bf616a;">m_id </span><span style="color:#eff1f5;">{ id }
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Employee </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_name </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;"> created</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">; </span><span style="color:#65737e;">// 输出员工创建信息
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Employee</span><span style="color:#eff1f5;">(std::string_view </span><span style="color:#bf616a;">name</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">id</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">bool </span><span style="color:#bf616a;">isManager</span><span style="color:#eff1f5;">) </span><span style="color:#65737e;">// 员工可以选择是否是经理
</span><span style="color:#eff1f5;">        : </span><span style="color:#bf616a;">m_name</span><span style="color:#eff1f5;">{ name }, </span><span style="color:#bf616a;">m_id</span><span style="color:#eff1f5;">{ id }, </span><span style="color:#bf616a;">m_isManager </span><span style="color:#eff1f5;">{ isManager }
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Employee </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_name </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;"> created</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">; </span><span style="color:#65737e;">// 输出员工创建信息
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Employee </span><span style="color:#bf616a;">e1</span><span>{ &quot;</span><span style="color:#a3be8c;">James</span><span>&quot;, </span><span style="color:#d08770;">7 </span><span>};       </span><span style="color:#65737e;">// 创建普通员工 &quot;James&quot;
</span><span>    Employee </span><span style="color:#bf616a;">e2</span><span>{ &quot;</span><span style="color:#a3be8c;">Dave</span><span>&quot;, </span><span style="color:#d08770;">42</span><span>, </span><span style="color:#d08770;">true </span><span>}; </span><span style="color:#65737e;">// 创建经理 &quot;Dave&quot;
</span><span>}
</span></code></pre>
<p>你会发现,两个构造函数主体中都打印了完全相同的语句。</p>
<blockquote>
<p>通常来说，让构造函数打印内容（除了用于调试目的外）并不是一个好的做法，我们的文章中经常这样做,目的是为了更好的阐述观点,实际开发中不建议这样做,望悉知!</p>
</blockquote>
</li>
</ul>
<p>由于构造函数允许调用其他函数,包括类的其他成员函数,那么我们可以这样重构:</p>
<p>+++
title = “[C++游戏开发基础]:构造函数浅析(8000字)”
date = 2025-06-19
tags = [“C++”, “游戏开发”, “构造函数”]
description = “深入解析C++构造函数的原理、使用方法及最佳实践”
+++</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string_view</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Employee
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    std::string m_name { </span><span>&quot;</span><span style="color:#a3be8c;">???</span><span>&quot; </span><span style="color:#eff1f5;">}; </span><span style="color:#65737e;">// 默认名称为 &quot;???&quot;
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_id</span><span style="color:#eff1f5;">{ </span><span style="color:#d08770;">0 </span><span style="color:#eff1f5;">};               </span><span style="color:#65737e;">// 默认 ID 为 0
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">bool</span><span style="color:#eff1f5;"> m_isManager { </span><span style="color:#d08770;">false </span><span style="color:#eff1f5;">};  </span><span style="color:#65737e;">// 默认不是经理
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">printCreated</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#65737e;">// 辅助函数：打印员工创建信息
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Employee </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_name </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;"> created</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Employee</span><span style="color:#eff1f5;">(std::string_view </span><span style="color:#bf616a;">name</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">id</span><span style="color:#eff1f5;">) </span><span style="color:#65737e;">// 构造函数：指定姓名和 ID
</span><span style="color:#eff1f5;">        : </span><span style="color:#bf616a;">m_name</span><span style="color:#eff1f5;">{ name }, </span><span style="color:#bf616a;">m_id </span><span style="color:#eff1f5;">{ id }
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">printCreated</span><span style="color:#eff1f5;">(); </span><span style="color:#65737e;">// 调用辅助函数
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Employee</span><span style="color:#eff1f5;">(std::string_view </span><span style="color:#bf616a;">name</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">id</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">bool </span><span style="color:#bf616a;">isManager</span><span style="color:#eff1f5;">) </span><span style="color:#65737e;">// 构造函数：指定姓名、ID 以及是否为经理
</span><span style="color:#eff1f5;">        : </span><span style="color:#bf616a;">m_name</span><span style="color:#eff1f5;">{ name }, </span><span style="color:#bf616a;">m_id</span><span style="color:#eff1f5;">{ id }, </span><span style="color:#bf616a;">m_isManager </span><span style="color:#eff1f5;">{ isManager }
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">printCreated</span><span style="color:#eff1f5;">(); </span><span style="color:#65737e;">// 调用辅助函数
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Employee </span><span style="color:#bf616a;">e1</span><span>{ &quot;</span><span style="color:#a3be8c;">James</span><span>&quot;, </span><span style="color:#d08770;">7 </span><span>};       </span><span style="color:#65737e;">// 创建普通员工 &quot;James&quot;
</span><span>    Employee </span><span style="color:#bf616a;">e2</span><span>{ &quot;</span><span style="color:#a3be8c;">Dave</span><span>&quot;, </span><span style="color:#d08770;">42</span><span>, </span><span style="color:#d08770;">true </span><span>}; </span><span style="color:#65737e;">// 创建经理 &quot;Dave&quot;
</span><span>}
</span></code></pre>
<p>虽然这比之前的版本好（冗余语句被冗余函数调用所取代），但它需要引入一个新的函数。而且，我们的两个构造函数也在初始化 <code>m_name</code> 和 <code>m_id</code> 。理想情况下，我们也希望去除这种冗余。</p>
<p>你可能会想到,在一个构造函数中调用对外一个构造函数来实现,比如下面这样的:</p>
<p>+++
title = “[C++游戏开发基础]:构造函数浅析(8000字)”
date = 2025-06-19
tags = [“C++”, “游戏开发”, “构造函数”]
description = “深入解析C++构造函数的原理、使用方法及最佳实践”
+++</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string_view</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Employee
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    std::string m_name { </span><span>&quot;</span><span style="color:#a3be8c;">???</span><span>&quot; </span><span style="color:#eff1f5;">};
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_id { </span><span style="color:#d08770;">0 </span><span style="color:#eff1f5;">};
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">bool</span><span style="color:#eff1f5;"> m_isManager { </span><span style="color:#d08770;">false </span><span style="color:#eff1f5;">};
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Employee</span><span style="color:#eff1f5;">(std::string_view </span><span style="color:#bf616a;">name</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">id</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">        : </span><span style="color:#bf616a;">m_name</span><span style="color:#eff1f5;">{ name }, </span><span style="color:#bf616a;">m_id </span><span style="color:#eff1f5;">{ id } </span><span style="color:#65737e;">// 此构造函数用于初始化 m_name 和 m_id
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Employee </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_name </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;"> created</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">; </span><span style="color:#65737e;">// 这里重新加入了打印语句
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Employee</span><span style="color:#eff1f5;">(std::string_view </span><span style="color:#bf616a;">name</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">id</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">bool </span><span style="color:#bf616a;">isManager</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">        : </span><span style="color:#bf616a;">m_isManager </span><span style="color:#eff1f5;">{ isManager } </span><span style="color:#65737e;">// 此构造函数仅初始化 m_isManager
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// 试图调用 Employee(std::string_view, int) 来初始化 m_name 和 m_id
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">Employee</span><span style="color:#eff1f5;">(name, id); </span><span style="color:#65737e;">// 这段代码不会按预期工作！
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">const</span><span style="color:#eff1f5;"> std::string</span><span>&amp; </span><span style="color:#8fa1b3;">getName</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#eff1f5;">{ </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_name</span><span style="color:#eff1f5;">; }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Employee </span><span style="color:#bf616a;">e2</span><span>{ &quot;</span><span style="color:#a3be8c;">Dave</span><span>&quot;, </span><span style="color:#d08770;">42</span><span>, </span><span style="color:#d08770;">true </span><span>};
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">e2 has name: </span><span>&quot; &lt;&lt; e2.</span><span style="color:#bf616a;">getName</span><span>() &lt;&lt; &quot;</span><span style="color:#96b5b4;">\n</span><span>&quot;; </span><span style="color:#65737e;">// 打印 e2.m_name
</span><span>}
</span></code></pre>
<p>遗憾的是,类似这样的调用不会正常运行,你可以自己运行看看。</p>
<blockquote>
<p>不应在另一个函数的主体中直接调用构造函数。这样做要么会导致编译错误，要么会直接初始化一个临时对象。</p>
</blockquote>
<p>那么如果不能在另一个构造函数的主体中调用构造函数，我们该如何解决这个问题？</p>
<p>这就引出了 <strong>委托构造函数</strong>的概念。</p>
<p>构造函数允许将初始化责任(委托)转移给同一个类类型的另一个构造函数。这个过程有时候也称为构造函数链式调用,这样的构造函数称为委托构造函数。</p>
<p>要使一个构造函数委托初始化给另一个构造函数,只需要在成员初始化列表中调用构造函数即可:</p>
<p>+++
title = “[C++游戏开发基础]:构造函数浅析(8000字)”
date = 2025-06-19
tags = [“C++”, “游戏开发”, “构造函数”]
description = “深入解析C++构造函数的原理、使用方法及最佳实践”
+++</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string_view</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Employee
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    std::string m_name { </span><span>&quot;</span><span style="color:#a3be8c;">???</span><span>&quot; </span><span style="color:#eff1f5;">};
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_id { </span><span style="color:#d08770;">0 </span><span style="color:#eff1f5;">};
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Employee</span><span style="color:#eff1f5;">(std::string_view </span><span style="color:#bf616a;">name</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">        : </span><span style="color:#bf616a;">Employee</span><span style="color:#eff1f5;">{ name, </span><span style="color:#d08770;">0 </span><span style="color:#eff1f5;">} </span><span style="color:#65737e;">// 将初始化委托给 Employee(std::string_view, int) 构造函数
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Employee</span><span style="color:#eff1f5;">(std::string_view </span><span style="color:#bf616a;">name</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">id</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">        : </span><span style="color:#bf616a;">m_name</span><span style="color:#eff1f5;">{ name }, </span><span style="color:#bf616a;">m_id </span><span style="color:#eff1f5;">{ id } </span><span style="color:#65737e;">// 实际上初始化成员变量
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Employee </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_name </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;"> created</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Employee </span><span style="color:#bf616a;">e1</span><span>{ &quot;</span><span style="color:#a3be8c;">James</span><span>&quot; };
</span><span>    Employee </span><span style="color:#bf616a;">e2</span><span>{ &quot;</span><span style="color:#a3be8c;">Dave</span><span>&quot;, </span><span style="color:#d08770;">42 </span><span>};
</span><span>}
</span></code></pre>
<p>针对中这个示例,简单看一下初始化的流程:</p>
<ul>
<li>当 <code>e1 { "James" }</code> 被初始化时，匹配的构造函数 <code>Employee(std::string_view)</code> 将被调用，其中参数 <code>name</code> 设置为 <code>"James"</code> 。</li>
<li>这个构造函数的成员初始化列表委托初始化给另一个构造函数，因此 <code>Employee(std::string_view, int)</code> 随后被调用。</li>
<li><code>name</code> （ <code>"James"</code> ）的值作为第一个参数传递，字面量 <code>0</code> 作为第二个参数传递。被委托构造函数的成员初始化列表初始化成员，然后被委托构造函数的主体运行。</li>
<li>然后控制权返回到初始构造函数，其（空）主体运行。</li>
<li>最后,控制权返回给调用者。</li>
</ul>
<p>这种方法的缺点是有时候需要重复初始化值。在委托给<code>mployee(std::string_view, int)</code> 构造函数时，我们需要为 <code>int</code> 参数提供一个初始化值。我们不得不<strong>硬编码</strong>字面量 <code>0</code> ，因为没有方法可以引用默认成员初始化器。</p>
<blockquote>
<p>记住,硬编码不是什么好习惯!</p>
</blockquote>
<p>关于委托构造函数的几点额外说明。首先，委托给另一个构造函数的构造函数不允许自己进行任何成员初始化。所以你的构造函数可以委托或初始化，但不能两者都做。</p>
<p>换句话说就是,你既然委托了别人进行初始化的操作,那么你自己就别再做同样的初始化操作了。</p>
<blockquote>
<p>请注意，我们让 <code>Employee(std::string_view)</code>（参数较少的构造函数）委托（delegate）给 <code>Employee(std::string_view name, int id)</code>（参数较多的构造函数）。通常，参数较少的构造函数会委托给参数较多的构造函数。</p>
<hr />
<p>如果反过来,让<code>Employee(std::string_view name, int id)</code>委托给 <code>Employee(std::string_view)</code>，那么我们将无法使用 <code>id</code> 来初始化<code> m_id</code>，因为构造函数只能<strong>要么委托给另一个构造函数，要么自己进行初始化</strong>，但不能同时执行这两种操作。</p>
</blockquote>
<p><strong>警告⚠️</strong></p>
<blockquote>
<p>如果一个构造函数委托给另一个构造函数,而那个被委托的构造函数又委托回第一个构造函数。这样会形成一个无限循环,从而导致程序耗尽栈空间而崩溃。</p>
</blockquote>
<hr />
<h2 id="-14">使用默认参数来减少构造函数</h2>
<p>默认值有时也可以将多个构造函数减少到一定数量。例如,就上面的例子来说,通过在<code>id</code>参数上设置一个默认值,我们可以创建一个单个<code>Employee</code>构造函数,该构造函数只需要一个名称参数,此时<code>id</code>参数就是可选而非必须的。</p>
<p>+++
title = “[C++游戏开发基础]:构造函数浅析(8000字)”
date = 2025-06-19
tags = [“C++”, “游戏开发”, “构造函数”]
description = “深入解析C++构造函数的原理、使用方法及最佳实践”
+++</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string_view</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Employee
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    std::string </span><span style="color:#bf616a;">m_name</span><span style="color:#eff1f5;">{};
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_id</span><span style="color:#eff1f5;">{ </span><span style="color:#d08770;">0 </span><span style="color:#eff1f5;">}; </span><span style="color:#65737e;">// 默认成员初始化（default member initializer）
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Employee</span><span style="color:#eff1f5;">(std::string_view </span><span style="color:#bf616a;">name</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">id </span><span>= </span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">) </span><span style="color:#65737e;">// 为 id 提供默认参数（default argument）
</span><span style="color:#eff1f5;">        : </span><span style="color:#bf616a;">m_name</span><span style="color:#eff1f5;">{ name }, </span><span style="color:#bf616a;">m_id</span><span style="color:#eff1f5;">{ id }
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Employee </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_name </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;"> created</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Employee </span><span style="color:#bf616a;">e1</span><span>{ &quot;</span><span style="color:#a3be8c;">James</span><span>&quot; }; </span><span style="color:#65737e;">// 由于 id 没有提供，使用默认值 0
</span><span>    Employee </span><span style="color:#bf616a;">e2</span><span>{ &quot;</span><span style="color:#a3be8c;">Dave</span><span>&quot;, </span><span style="color:#d08770;">42 </span><span>}; </span><span style="color:#65737e;">// 提供了 id，使用 42 进行初始化
</span><span>}
</span></code></pre>
<p><strong>最佳实践</strong></p>
<blockquote>
<ul>
<li>
<p>用户必须提供初始化值的成员应该首先定义(并且作为构造函数的左侧参数)。</p>
</li>
<li>
<p>用户可以提供初始化值的成员应该第二定义(且作为构造函数的右侧参数)。</p>
</li>
</ul>
</blockquote>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Employee
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    std::string </span><span style="color:#bf616a;">m_name</span><span style="color:#eff1f5;">; </span><span style="color:#65737e;">// 必须提供
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_id</span><span style="color:#eff1f5;">; </span><span style="color:#65737e;">// 必须提供
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">bool </span><span style="color:#bf616a;">m_isManager</span><span style="color:#eff1f5;">; </span><span style="color:#65737e;">// 可选（有默认值）
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Employee</span><span style="color:#eff1f5;">(std::string_view </span><span style="color:#bf616a;">name</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">id</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">bool </span><span style="color:#bf616a;">isManager </span><span>= </span><span style="color:#d08770;">false</span><span style="color:#eff1f5;">) </span><span style="color:#65737e;">// isManager 在最右侧
</span><span style="color:#eff1f5;">        : </span><span style="color:#bf616a;">m_name</span><span style="color:#eff1f5;">{ name }, </span><span style="color:#bf616a;">m_id</span><span style="color:#eff1f5;">{ id }, </span><span style="color:#bf616a;">m_isManager</span><span style="color:#eff1f5;">{ isManager }
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span></code></pre>
<hr />
<p>当<strong>某个初始化值</strong>（例如默认成员初始化值和构造函数参数的默认值）在<strong>多个地方被使用</strong>时，<strong>建议定义一个命名常量</strong>，并在需要的地方使用它。</p>
<p>这样做的好处是：</p>
<ul>
<li>
<p><strong>统一管理初始化值</strong>，只需在一个地方修改，就能影响所有使用该值的地方。</p>
</li>
<li>
<p><strong>避免魔法数字（magic numbers）</strong>，提高代码的可读性和可维护性。</p>
</li>
</ul>
<p>尽管可以使用 <strong>constexpr 全局变量</strong> 来存储这些默认值，但更好的做法是<strong>在类中使用 static constexpr 成员变量</strong>。</p>
<p>+++
title = “[C++游戏开发基础]:构造函数浅析(8000字)”
date = 2025-06-19
tags = [“C++”, “游戏开发”, “构造函数”]
description = “深入解析C++构造函数的原理、使用方法及最佳实践”
+++</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string_view</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Employee
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">static constexpr int</span><span style="color:#eff1f5;"> default_id { </span><span style="color:#d08770;">0 </span><span style="color:#eff1f5;">}; </span><span style="color:#65737e;">// 定义一个命名常量，表示默认的 ID 值
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    std::string m_name {};
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_id { default_id }; </span><span style="color:#65737e;">// 在这里使用命名常量进行默认初始化
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Employee</span><span style="color:#eff1f5;">(std::string_view </span><span style="color:#bf616a;">name</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">id </span><span>=</span><span style="color:#eff1f5;"> default_id) </span><span style="color:#65737e;">// 在构造函数的默认参数中也使用该命名常量
</span><span style="color:#eff1f5;">        : </span><span style="color:#bf616a;">m_name </span><span style="color:#eff1f5;">{ name }, </span><span style="color:#bf616a;">m_id </span><span style="color:#eff1f5;">{ id }
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Employee </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_name </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;"> created</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Employee </span><span style="color:#bf616a;">e1 </span><span>{ &quot;</span><span style="color:#a3be8c;">James</span><span>&quot; };     </span><span style="color:#65737e;">// ID 默认使用 default_id（即 0）
</span><span>    Employee </span><span style="color:#bf616a;">e2 </span><span>{ &quot;</span><span style="color:#a3be8c;">Dave</span><span>&quot;, </span><span style="color:#d08770;">42 </span><span>};  </span><span style="color:#65737e;">// ID 显式指定为 42
</span><span>}
</span></code></pre>
<p><strong>为什么 static constexpr 更优？</strong></p>
<p>使用 static 关键字，使 default_id 成为<strong>所有 Employee 对象共享的静态成员</strong>。如果不使用<code>static</code>,每个 Employee 对象都会有<strong>自己独立的 default_id 成员</strong>，这虽然不会影响功能，但会<strong>浪费内存</strong>，因为所有 default_id 变量的值都是相同的。</p>
<p>使用这种方式,<code>default_id </code><strong>存储在类的静态区域</strong>，而不是每个对象都存一份。这样所有 <code>Employee</code> 对象都能<strong>共享一个 default_id</strong>，提高效率并减少内存浪费</p>
<p><strong>这种方式的缺点</strong></p>
<ul>
<li>
<p><strong>增加类的复杂度</strong>：每增加一个<strong>命名常量</strong>，都会给类添加一个额外的名称，可能会使类变得稍微复杂。</p>
<p><strong>是否值得使用取决于场景</strong>：</p>
<ul>
<li>如果默认值只在一个地方使用，<strong>直接写死</strong>即可（比如 m_id { 0 }）。</li>
<li><strong>如果默认值在多个地方使用</strong>，则使用 <strong>static constexpr</strong> 更合适。</li>
</ul>
</li>
</ul>
<hr />

        </div>
      </div>
      <div class="prompt" id="terminal"><input
    type="text"
    id="setter"
    onkeydown="writeit(this, event);moveIt(this.value.length, event)"
    onchange="writeit(this, event)"
    onkeyup="writeit(this, event)"
    onkeypress="writeit(this, event);"
    >
<label for="setter" id="writer"> </label><b class="cursor" id="cursor"></b></div>
      <footer class="footer">
        <div class="footer-content">
          <p class="icp-info">
            <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer">黔ICP备2021010295号</a>
          </p>
        </div>
      </footer>
    </main>
  </body>

</html>
