<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>慕予博客</title>
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"
    integrity="sha256-WCzAhd2P6gRJF9Hv3oOOd+hFJi/QJbv+Azn4CGB8gfY=" crossorigin="anonymous" defer></script>
  <script src="/js/index.js" defer></script>
  <script src="/js/prompt.js" defer></script>
  <script src="/js/keyboard.js" defer></script>
  <script src="/js/tab.js" defer></script>
  <script src="/js/commands.js" defer></script>
  <script src="/js/config.js" defer></script><script src="/config.js"></script><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="style.css"><link rel="stylesheet" href="/css/page.css"></head><body onkeydown="exec(event)" style="background-image: url(&quot;&#x2F;assets&#x2F;bg.jpg&quot;); "><main>
      <div class="files" id="files" tabindex="0">
<ul>

  <li class="file">
    <span><a href='https://ilikexff.cn/8-kuan-rang-ni-kai-fa-qi-fei-de-intellijidea-cha-jian/'
      tabindex="-2">  8款让你开发起飞的IntellijIDEA插件</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/aop-jie-mi-qie-mian-bian-cheng-de-zong-he-zhi-nan/'
      tabindex="-3">  AOP揭秘：切面编程的综合指南</a></span>
  </li><li class="file">
    <span><a class="selected"href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-mei-ju-pian-yi-wu-fan-wei-mei-ju/'
      tabindex="-4">  C++游戏开发基础-枚举篇一：无范围枚举</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-std-optional/'
      tabindex="-5">  C++游戏开发基础-深入解析std::optional</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shen-ru-jie-xi-thiszhi-zhen-de-ying-yong-yu-ji-qiao/'
      tabindex="-6">  C++游戏开发基础-深入解析this指针的应用与技巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-fu-zhi-gou-zao-han-shu/'
      tabindex="-7">  C++游戏开发基础-深入解析复制构造函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-mo-ban-he-can-shu-tui-dao-zhi-nan/'
      tabindex="-8">  C++游戏开发基础-类模版和参数推导指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/dockerbi-zhi-bi-hui/'
      tabindex="-9">  Docker必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/githithub-xiao-ce/'
      tabindex="-10">  GitGitHub小册</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/google-hacking/'
      tabindex="-11">  Google Hacking</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/googleguan-fang-ti-shi-gong-cheng-bai-pi-shu-zhong-wen-yi-ben/'
      tabindex="-12">  Google官方《提示工程白皮书（中文译本）》</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-dai-ma-bu-quan-ti-shi-gong-neng-xiao-shi-de-ji-chong-jie-jue-fang-an-re-geng-ban/'
      tabindex="-13">  IDEA代码补全&amp;提示功能消失的几种解决方案(热更版)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-chen-jin-shi-bian-cheng-ti-yan/'
      tabindex="-14">  IDEA沉浸式编程体验</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-han-shu-shi-bian-cheng/'
      tabindex="-15">  Java函数式编程</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-ji-he-yuan-ma-qian-xi/'
      tabindex="-16">  Java集合源码浅析</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mysql-shi-wu-te-xing-yu-ge-chi-ji-bie-xiang-jie/'
      tabindex="-17">  MySQL_事务特性与隔离级别详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ocao-zuo-fu-shi-xian-mei-ju-de-shu-ru-shu-chu/'
      tabindex="-18">  O操作符,实现枚举的输入输出</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/prdsuan-fa-ting-shuo-ni-xiang-ping-yun-qi-chou-yi-ke-rong-yao-shui-jing/'
      tabindex="-19">  PRD算法：听说你想凭运气抽一颗荣耀水晶?</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/picgo-pei-zhi-ge-chong-tu-chuang/'
      tabindex="-20">  PicGo配置各种图床</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/redis-bi-zhi-bi-hui/'
      tabindex="-21">  Redis必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-zhong-de-move-yu-yi-sui-bi/'
      tabindex="-22">  Rust中的move语义随笔</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ssm-kuang-jia-shi-xian-ji-cheng-duan-xin-yan-zheng-ma-gong-neng/'
      tabindex="-23">  SSM框架实现集成短信验证码功能</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/slf4jyu-logbackshi-yong-zhi-nan-ji-yu-gradle/'
      tabindex="-24">  Slf4j与Logback实用指南(基于Gradle)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/spring-security5-xdao-spring-security6-xde-qian-yi/'
      tabindex="-25">  Spring Security5.x到Spring Security6.x的迁移</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springboot-webkai-fa-jing-jie/'
      tabindex="-26">  SpringBoot Web开发精解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springsecurity/'
      tabindex="-27">  SpringSecurity</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/unity6xia-jia-zhong-guo-qu-tuan-jie-yin-qing-jie-bang-zhe-shi-fen-lie-huan-shi-ben-di-hua-de-kai-shi/'
      tabindex="-28">  Unity6下架中国区，团结引擎接棒：这是分裂，还是本地化的开始？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-cong-0-dao-1-da-zao-quan-yu-yan-zhi-chi-de-mo-neng-bian-ji-qi-yu-fa-pian/'
      tabindex="-29">  Vim从0到1打造全语言支持的万能编辑器-语法篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-tiao-tou-powershell-pian/'
      tabindex="-30">  Vim折腾之 PowerShell篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-di-zhi-chuan-di-xiang-jie/'
      tabindex="-31">  [C++游戏开发基础]:地址传递详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-yin-yong-fan-hui-he-di-zhi-fan-hui/'
      tabindex="-32">  [C++游戏开发基础]:引用返回和地址返回</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-he-const/'
      tabindex="-33">  [C++游戏开发基础]:指针和const</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shu-ju-feng-zhuang-yin-cang-de-hao-chu/'
      tabindex="-34">  [C++游戏开发基础]:数据封装(隐藏)的好处</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-gou-zao-han-shu-qian-xi-8000zi/'
      tabindex="-35">  [C++游戏开发基础]:构造函数浅析(8000字)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-li-jie-kong-zhi-zhen/'
      tabindex="-36">  [C++游戏开发基础]:理解空指针</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-zhong-de-fang-wen-han-shu/'
      tabindex="-37">  [C++游戏开发基础]:类中的访问函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-de-ji-ben-gai-nian-li-jie/'
      tabindex="-38">  [C++游戏开发基础]指针的基本概念理解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/fanatical-wu-yue-feng-kuang-te-hui-wei-ni-de-steam-ku-jia-dian-liao/'
      tabindex="-39">  _Fanatical 五月疯狂特惠：为你的 Steam 库加点料！</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-kai-yuan-mi-ma-gong-ju-xpwd-zhong-wen-ban-bian-geng-ri-zhi/'
      tabindex="-40">  _Rust开源密码工具xpwd中文版变更日志</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/readme/'
      tabindex="-41">  readme</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wblog-bo-ke-xian-shang-bu-shu/'
      tabindex="-42">  wblog博客线上部署</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/shang-gu-shen-qi-vim-su-cheng-bei-wang-lu/'
      tabindex="-43">  上古神器_Vim速成备忘录</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mian-fei-ji-huo-quan-ban-ben-typora-zui-xin-ban-wei-li/'
      tabindex="-44">  免费激活全版本Typora，最新版为例</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-lombokxian-wei-ren-zhi-de-ji-ge-qi-ji-yin-qiao/'
      tabindex="-45">  关于Lombok鲜为人知的几个奇技淫巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-jie-kou-xian-liu-de-yi-ci-jian-dan-shi-jian/'
      tabindex="-46">  关于接口限流的一次简单实践</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/tu-jie-er-jin-zhi/'
      tabindex="-47">  图解二进制</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ru-he-xie-de-yi-shou-you-ya-gui-fan-de-springboot-jie-kou/'
      tabindex="-48">  如何写得一手优雅规范的SpringBoot 接口？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/kai-fa-bi-hui-xi-lie-jwtqian-tan/'
      tabindex="-49">  开发必会系列_JWT浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ji-qiao-jiu-shi-xiao-lu-chatgpt-diao-jiao-zhi-bei/'
      tabindex="-50">  技巧就是效率，ChatGPT调教指北</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-sheng-intellij-kai-fa-xiao-lu-zhe-kuan-dai-ma-tu-ding-cha-jian-codepins-zhi-de-yi-shi/'
      tabindex="-51">  提升 IntelliJ 开发效率？这款代码图钉插件 CodePins 值得一试</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-wen-de-zhi-hui-zhuan-zai/'
      tabindex="-52">  提问的智慧转载</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiao-lu-gong-ju-markdown/'
      tabindex="-53">  效率工具Markdown</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wu-wei-bing-fa-rust-sheng-ming-zhou-qi-qian-tan/'
      tabindex="-54">  无畏并发_Rust 生命周期浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-yu-de-bei-sai-er-qu-xian-gan-shou-si-hua-de-shu-xue-zhi-mei/'
      tabindex="-55">  游戏开发与的贝塞尔曲线_感受丝滑的数学之美</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-bi-bei-gao-xiao-de-aabb-qiu-ti-he-obb-peng-zhuang-jian-ce-suan-fa/'
      tabindex="-56">  游戏开发必备：高效的 AABB、球体和 OBB 碰撞检测算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-suan-fa-ji-chu-a-xun-lu-suan-fa-chi-xu-wei-hu/'
      tabindex="-57">  游戏算法基础-深入解析A*寻路算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/du-li-you-xi-kai-fa-zhe-gong-ju-xiang-2025jing-xuan-tui-jian-yu-shi-yong-zhi-nan/'
      tabindex="-58">  独立游戏开发者工具箱：2025精选推荐与实用指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xu-huan-yin-qing-you-xi-kai-fa-xi-lie-zhuan-ti-guan-fang-bian-ma-biao-zhun-huo-gui-yue/'
      tabindex="-59">  虚幻引擎游戏开发系列专题-官方编码标准或规约</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiang-jie-she-ji-mo-shi-dan-li-de-jin-hua-zhi-lu/'
      tabindex="-60">  详解设计模式_单例的进化之路</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xie-e-de-fei-chang-liang-quan-ju-bian-liang/'
      tabindex="-61">  邪恶的非常量全局变量</a></span>
  </li>
</ul>
</div>
      <div class="viewer page" id="viewer" tabindex="0">
        <div class="tab">
<div class="file-manager" onclick='document.getElementById("files").classList.toggle("open"); document.getElementById("content").classList.toggle("close")'> </div>
<ul id="tabs">
</ul>


</div>
        <div class="content" id="content"><p>正片开始,假设你正在编写一个程序,需要用到一组颜色,并且在只有基本类型可用的情况下,你该如何去实现这一点?</p>
<p>其中一种做法是,我们可以将颜色存储为整数值,并用某种映射关系来说明每一个整数代表的颜色;比如:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>  </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">appleColor </span><span>{</span><span style="color:#d08770;">0</span><span>}; </span><span style="color:#65737e;">// 定义苹果为0 代表红色
</span><span>  </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">shirtCOlor </span><span>{</span><span style="color:#d08770;">1</span><span>}; </span><span style="color:#65737e;">// 定义衬衫为1 代表绿色
</span><span>  
</span><span>  </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>严格来说,这样的做法并没有什么错误之处,但是从程序的最佳实践上说,这样的做法并不直观,并且还用到了魔法数,不论是在C++还是其他编程语言中,尽可能避免在程序中使用魔法数字,这不是一个值的推荐的写法,因此,我们可以使用符号常量来对上面的写法进一步的优化,达到消除魔法数的目的:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>`</span><span style="color:#b48ead;">constexpr int </span><span style="color:#bf616a;">red </span><span>{</span><span style="color:#d08770;">0</span><span>};
</span><span style="color:#b48ead;">constexpr int</span><span> green {</span><span style="color:#d08770;">1</span><span>};
</span><span style="color:#b48ead;">constexpr int</span><span> blue {</span><span style="color:#d08770;">2</span><span>};
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>  </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">appleColor </span><span>{red};
</span><span>  </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">shirtColor </span><span>{green};
</span><span>  
</span><span>  </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>ok ,虽然这样写稍微好读一些，但程序员仍然需要推断 <code>appleColor</code> 和<code> shirtColor</code>（它们是 int 类型）应该保存颜色符号常量集合中的某个值（这些常量可能在其他地方定义，可能在一个单独的文件中）。</p>
<p>基于此,我们可以使用类型别名来进一步优化,使得这个程序更加清晰一点;</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">using </span><span>Color = </span><span style="color:#b48ead;">int</span><span>; </span><span style="color:#65737e;">// 定义一个名为颜色的类型别名
</span><span>
</span><span style="color:#b48ead;">constexpr</span><span> Color </span><span style="color:#bf616a;">red</span><span>{ </span><span style="color:#d08770;">0 </span><span>};
</span><span style="color:#b48ead;">constexpr</span><span> Color </span><span style="color:#bf616a;">green</span><span>{ </span><span style="color:#d08770;">1 </span><span>};
</span><span style="color:#b48ead;">constexpr</span><span> Color </span><span style="color:#bf616a;">blue</span><span>{ </span><span style="color:#d08770;">2 </span><span>};
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Color </span><span style="color:#bf616a;">appleColor</span><span>{ red };
</span><span>    Color </span><span style="color:#bf616a;">shirtColor</span><span>{ green };
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>阅读这段代码的人仍然需要理解这些颜色符号常量是与 Color 类型的变量一起使用的，但至少现在这个类型有一个独特的名字，这样如果有人搜索 Color，就能够找到相关的符号常量集合了。</p>
<p>但是这并不完美,依旧存在问题,因为Color只是int的别名,那么我们依旧可以像下面这样做;</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>Color otherColor {</span><span style="color:#d08770;">10</span><span>};
</span></code></pre>
<p>此外,当我们使用调试器来调试程序时,对于这些变量,我们只能看到我们用来表示某种颜色的整数值,而不是更加直观形象的颜色符号意义,如<code>red</code>,这可能会使得我们更加难以判断程序是否正确。</p>
<hr />
<h2 id="mei-ju">枚举</h2>
<p>就上面讨论的内容,非常比特否的是,C++给我们提供了一种相对完美的解决方案,那就是使用枚举实现。</p>
<p>枚举也称为枚举类型(enum),是一种复合数据类型,其值被限制为一组命名的符号常量(枚举器);</p>
<p>C++中枚举分为范围枚举和无范围枚举,本文即将先介绍的是无范围枚举。</p>
<hr />
<h3 id="wu-fan-wei-mei-ju">无范围枚举</h3>
<p>无范围枚举是通过<code>enum</code>关键字来定义的。</p>
<p>枚举类型最好通过例子来讲解,所以我们还是基于前面讨论的颜色定义的例子来定义一个无范围枚举,并存储一些颜色。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#65737e;">// 定义枚举类型
</span><span style="color:#b48ead;">enum </span><span>Color
</span><span>{
</span><span>    red,
</span><span>    green,
</span><span>    blue,
</span><span>};
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Color </span><span style="color:#bf616a;">apple </span><span>{red};
</span><span>    Color </span><span style="color:#bf616a;">shirt </span><span>{green};
</span><span>    Color </span><span style="color:#bf616a;">cup </span><span>{blue};
</span><span>    Color </span><span style="color:#bf616a;">socks </span><span>{yellow}; </span><span style="color:#65737e;">// 错误：白色不是颜色的枚举
</span><span>    Color </span><span style="color:#bf616a;">hat </span><span>{</span><span style="color:#d08770;">2</span><span>}; </span><span style="color:#65737e;">// 错误: 2不是颜色的枚举者
</span><span>  
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>上面的程序中,我们使用了<code>enum</code>关键字来定义了一个名为<code>Color</code>的枚举。 大括号内定义了几种<code>Color</code>类型的枚举项,每一项都是枚举类型,之间用逗号分隔,注意,尽管最后一项的枚举项后的逗号不是必须的,但是建议也加上,良好的编码习惯是非常重要的,而这些习惯不应该作为单独的课程来学习,而是在每一次编码时都刻意的去保持这种习惯,只有这样,日复一日后,不论何时何地,你所留下的每一行代码,都堪比徐志摩的诗!!!!</p>
<p>在 <code>main()</code> 中，我们实例化了三个变量，类型为 <code>Color</code> ： <code>apple</code> 被初始化为颜色 <code>red</code> ， <code>shirt</code> 被初始化为颜色 <code>green</code> ， <code>cup</code> 被初始化为颜色 <code>blue</code> 。为这些对象分配了内存。请注意，枚举类型初始化器必须是该类型定义的枚举项之一。变量 <code>socks</code> 和 <code>hat</code> 会导致编译错误，因为初始化器 <code>yellow</code> 和 <code>2</code> 不是 <code>Color</code> 的枚举项。</p>
<blockquote>
<p>枚举器是隐式<code>constexpr</code>的。</p>
</blockquote>
<hr />
<h3 id="ming-ming-mei-ju-he-mei-ju-yuan-su">命名枚举和枚举元素</h3>
<p>按照惯例,枚举类型的名字以大写字母开头(所有程序定义的类型都是如此)。</p>
<blockquote>
<p>尽管在语义上,枚举可以不需要命名,但是在现代C ++中应该避免使用无名枚举。</p>
</blockquote>
<p>枚举器必须给出名称。不幸的是，目前来说并没有通用的枚举器命名约定。</p>
<p>下面是一些常见的命名风格选择:</p>
<ul>
<li>以小写字母开头（例如 red）</li>
<li>以大写字母开头（Red）</li>
<li>全部大写（RED）</li>
<li>以前缀开头的大写字母（COLOR_RED）</li>
<li>或以“k”开头并采用间断大写（kColorRed）</li>
</ul>
<blockquote>
<p>个人比较倾向于小写字母开头的风格,当然,你可以选择一个自己喜欢的风格,一旦风格确定,尽可能在程序中保持一致,不建议在一个项目或者程序中同时使用多种风格的命名。</p>
</blockquote>
<p><strong>一些命名建议:</strong></p>
<ul>
<li>现代C++规范通常建议避免使用全大写字母的命名约定,因为全大写字母通常用于预处理器宏,并且可能会产生冲突。</li>
<li>建议避免使用大写字母开头的命名约定,因为大写字母开头的名称通常保留给程序定义的类型。</li>
</ul>
<p><strong>最佳实践</strong></p>
<blockquote>
<p>将枚举类型命名为首字母大写的名称。将枚举项命名为首字母小写的名称。</p>
</blockquote>
<hr />
<p>有一个点需要了解的是,你创建的每个枚举类型都被认为是不同的类型，这意味着编译器可以将其与其他类型区分开来（与 <code>typedef</code> 或类型别名不同，它们被认为与它们所别名的类型没有区别）。</p>
<p>因为枚举类型是独立的，属于一个枚举类型的枚举器不能用于另一个枚举类型的对象：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">enum </span><span>Pet
</span><span>{
</span><span>    cat,
</span><span>    dog,
</span><span>    pig,
</span><span>    whale,
</span><span>};
</span><span>
</span><span style="color:#b48ead;">enum </span><span>Color
</span><span>{
</span><span>    black,
</span><span>    red,
</span><span>    blue,
</span><span>};
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Pet </span><span style="color:#bf616a;">myPet </span><span>{ black }; </span><span style="color:#65737e;">// 编译错误:black枚举项不属于Pet枚举类型
</span><span>    Color </span><span style="color:#bf616a;">shirt </span><span>{ pig }; </span><span style="color:#65737e;">// 同理
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<h3 id="shi-yong-mei-ju-lei-xing">使用枚举类型</h3>
<p>因为枚举器具有描述性，它们有助于增强代码文档和可读性。当您有一组相关的常量，并且对象每次只需要存储其中一个值时，使用枚举类型最为合适。</p>
<p>下面是一些常见的枚举使用例子:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">enum </span><span>DaysOfWeek
</span><span>{
</span><span>    sunday,
</span><span>    monday,
</span><span>    tuesday,
</span><span>    wednesday,
</span><span>    thursday,
</span><span>    friday,
</span><span>    saturday,
</span><span>};
</span><span>
</span><span style="color:#b48ead;">enum </span><span>CardinalDirections
</span><span>{
</span><span>    north,
</span><span>    east,
</span><span>    south,
</span><span>    west,
</span><span>};
</span><span>
</span><span style="color:#b48ead;">enum </span><span>CardSuits
</span><span>{
</span><span>    clubs,
</span><span>    diamonds,
</span><span>    hearts,
</span><span>    spades,
</span><span>};
</span></code></pre>
<p>有时函数会返回一个状态码给调用者，以指示函数是否执行成功或遇到错误。传统上，使用不同的负小数值来表示可能的错误码。例如：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">readFileContents</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">if </span><span>(!</span><span style="color:#bf616a;">openFile</span><span>())
</span><span>        </span><span style="color:#b48ead;">return </span><span>-</span><span style="color:#d08770;">1</span><span>; </span><span style="color:#65737e;">// error 1
</span><span>    </span><span style="color:#b48ead;">if </span><span>(!</span><span style="color:#bf616a;">readFile</span><span>())
</span><span>        </span><span style="color:#b48ead;">return </span><span>-</span><span style="color:#d08770;">2</span><span>; </span><span style="color:#65737e;">// error 2
</span><span>    </span><span style="color:#b48ead;">if </span><span>(!</span><span style="color:#bf616a;">parseFile</span><span>())
</span><span>        </span><span style="color:#b48ead;">return </span><span>-</span><span style="color:#d08770;">3</span><span>; </span><span style="color:#65737e;">// error 3
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>; </span><span style="color:#65737e;">// success
</span><span>}
</span></code></pre>
<p>然而,前面已经说过,使用魔法数字并不是最佳的选择,这里更推荐的方法是使用枚举类型:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">enum </span><span>FileReadResult
</span><span>{
</span><span>    readResultSuccess,
</span><span>    readResultErrorFileOpen,
</span><span>    readResultErrorFileRead,
</span><span>    readResultErrorFileParse,
</span><span>};
</span><span>
</span><span>FileReadResult </span><span style="color:#8fa1b3;">readFileContents</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">if </span><span>(!</span><span style="color:#bf616a;">openFile</span><span>())
</span><span>        </span><span style="color:#b48ead;">return</span><span> readResultErrorFileOpen;
</span><span>    </span><span style="color:#b48ead;">if </span><span>(!</span><span style="color:#bf616a;">readFile</span><span>())
</span><span>        </span><span style="color:#b48ead;">return</span><span> readResultErrorFileRead;
</span><span>    </span><span style="color:#b48ead;">if </span><span>(!</span><span style="color:#bf616a;">parseFile</span><span>())
</span><span>        </span><span style="color:#b48ead;">return</span><span> readResultErrorFileParse;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return</span><span> readResultSuccess;
</span><span>}
</span></code></pre>
<p>然后调用者可以将函数的返回值与相应的枚举值进行比较，这种方式比直接测试返回结果是否为特定整数值更容易理解。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">readFileContents</span><span>() == readResultSuccess)
</span><span>{
</span><span>    </span><span style="color:#65737e;">// do something
</span><span>}
</span><span style="color:#b48ead;">else
</span><span>{
</span><span>    </span><span style="color:#65737e;">// print error message
</span><span>}
</span></code></pre>
<p>枚举类型也可以在游戏中有很好的应用(后续会持续更新游戏开发领域的文章)，用于标识不同类型的物品、怪物或地形。基本上，任何小规模的相关对象都可以。</p>
<p>例如:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">enum </span><span>ItemType
</span><span>{
</span><span>	sword,
</span><span>	torch,
</span><span>	potion,
</span><span>};
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>	ItemType </span><span style="color:#bf616a;">holding</span><span>{ torch };
</span><span>
</span><span>	</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>枚举类型在用户需要在两个或多个选项中做出选择时，也可以作为有用的函数参数：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">enum </span><span>SortOrder
</span><span>{
</span><span>    alphabetical,         </span><span style="color:#65737e;">// 按字母顺序
</span><span>    alphabeticalReverse,  </span><span style="color:#65737e;">// 按字母逆序
</span><span>    numerical,            </span><span style="color:#65737e;">// 按数值顺序
</span><span>};
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">sortData</span><span>(SortOrder </span><span style="color:#bf616a;">order</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">switch </span><span>(order)
</span><span>    {
</span><span>        </span><span style="color:#b48ead;">case</span><span> alphabetical:
</span><span>            </span><span style="color:#65737e;">// 按字母顺序正向排序数据
</span><span>            </span><span style="color:#b48ead;">break</span><span>;
</span><span>        </span><span style="color:#b48ead;">case</span><span> alphabeticalReverse:
</span><span>            </span><span style="color:#65737e;">// 按字母顺序反向排序数据
</span><span>            </span><span style="color:#b48ead;">break</span><span>;
</span><span>        </span><span style="color:#b48ead;">case</span><span> numerical:
</span><span>            </span><span style="color:#65737e;">// 按数值顺序排序数据
</span><span>            </span><span style="color:#b48ead;">break</span><span>;
</span><span>    }
</span><span>}
</span></code></pre>
<p>枚举也可以用来定义一组相关的位标志位置，以便与 <code>std::bitset</code> 一起使用。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">bitset</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">namespace </span><span>Flags
</span><span>{
</span><span>    </span><span style="color:#b48ead;">enum </span><span>State
</span><span>    {
</span><span>        isHungry,   </span><span style="color:#65737e;">// 是否饥饿
</span><span>        isSad,      </span><span style="color:#65737e;">// 是否悲伤
</span><span>        isMad,      </span><span style="color:#65737e;">// 是否生气
</span><span>        isHappy,    </span><span style="color:#65737e;">// 是否开心
</span><span>        isLaughing, </span><span style="color:#65737e;">// 是否大笑
</span><span>        isAsleep,   </span><span style="color:#65737e;">// 是否睡着
</span><span>        isDead,     </span><span style="color:#65737e;">// 是否死亡
</span><span>        isCrying,   </span><span style="color:#65737e;">// 是否哭泣
</span><span>    };
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    std::bitset&lt;</span><span style="color:#d08770;">8</span><span>&gt; </span><span style="color:#bf616a;">me</span><span>{}; </span><span style="color:#65737e;">// 创建一个 8 位的 bitset，初始值为 0 (所有状态均为 false)
</span><span>    me.</span><span style="color:#bf616a;">set</span><span>(Flags::isHappy);    </span><span style="color:#65737e;">// 设置“开心”状态为 true
</span><span>    me.</span><span style="color:#bf616a;">set</span><span>(Flags::isLaughing); </span><span style="color:#65737e;">// 设置“大笑”状态为 true
</span><span>
</span><span>    std::cout &lt;&lt; std::boolalpha; </span><span style="color:#65737e;">// 将布尔值以 true/false 形式输出
</span><span>
</span><span>    </span><span style="color:#65737e;">// 查询一些状态 (使用 test() 函数查看指定位是否为 true)
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">I am happy? </span><span>&quot; &lt;&lt; me.</span><span style="color:#bf616a;">test</span><span>(Flags::isHappy) &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;       </span><span style="color:#65737e;">// 是否开心？
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">I am laughing? </span><span>&quot; &lt;&lt; me.</span><span style="color:#bf616a;">test</span><span>(Flags::isLaughing) &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;; </span><span style="color:#65737e;">// 是否大笑？
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<hr />
<h3 id="wu-fan-wei-mei-ju-de-zuo-yong-yu">无范围枚举的作用域</h3>
<p>无作用域枚举之所以这样命名，是因为它们将其枚举器名称放置在与枚举定义本身相同的作用域中（而不是像命名空间那样创建一个新的作用域区域）。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">enum </span><span>Color </span><span style="color:#65737e;">// 该枚举 (enum) 定义在全局命名空间中
</span><span>{
</span><span>    red,   </span><span style="color:#65737e;">// 因此 red 被放入全局命名空间中
</span><span>    green, </span><span style="color:#65737e;">// 同理，green 也在全局命名空间中
</span><span>    blue,  </span><span style="color:#65737e;">// blue 也一样
</span><span>};
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Color </span><span style="color:#bf616a;">apple </span><span>{ red }; </span><span style="color:#65737e;">// 我的苹果是红色的 (直接使用 red，没有命名空间限定)
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>枚举在全局作用域中定义。因此，所有枚举名称（ <code>red</code> 、 <code>green</code> 和 <code>blue</code> ）也进入全局作用域。这会污染全局作用域，并显著增加命名冲突的可能性。</p>
<p>这一后果是，枚举名在同一作用域内不能在多个枚举中使用：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">enum </span><span>Color
</span><span>{
</span><span>    red,
</span><span>    green,
</span><span>    blue, </span><span style="color:#65737e;">// blue 被放入全局命名空间中
</span><span>};
</span><span>
</span><span style="color:#b48ead;">enum </span><span>Feeling
</span><span>{
</span><span>    happy,
</span><span>    tired,
</span><span>    blue, </span><span style="color:#65737e;">// 错误: 与上面的 blue 命名冲突
</span><span>};
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Color </span><span style="color:#bf616a;">apple </span><span>{ red }; </span><span style="color:#65737e;">// 我的苹果是红色的
</span><span>    Feeling </span><span style="color:#bf616a;">me </span><span>{ happy }; </span><span style="color:#65737e;">// 我现在很开心（尽管我的程序无法编译）
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>在上面的示例中，两个未限定的枚举（ <code>Color</code> 和 <code>Feeling</code> ）将同名的枚举项 <code>blue</code> 放到了全局作用域中。这导致了命名冲突，并产生了编译错误。</p>
<p>无范围的枚举也为枚举器提供了一个命名作用域区域（就像命名空间为内部声明的名称提供一个命名作用域区域一样）。这意味着我们可以按照以下方式访问无范围枚举的枚举器：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">enum </span><span>Color
</span><span>{
</span><span>    red,
</span><span>    green,
</span><span>    blue, </span><span style="color:#65737e;">// blue 被放入全局命名空间中
</span><span>};
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Color </span><span style="color:#bf616a;">apple </span><span>{ red };          </span><span style="color:#65737e;">// 可以，直接从全局命名空间访问枚举器 red
</span><span>    Color </span><span style="color:#bf616a;">raspberry </span><span>{ Color::red }; </span><span style="color:#65737e;">// 也可以，从 Color 枚举作用域中访问枚举器 red
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>但是大多数情况下，未限定的枚举元素不使用作用域解析运算符来访问。</p>
<hr />
<h3 id="bi-mian-mei-ju-xiang-ming-ming-chong-tu">避免枚举项命名冲突</h3>
<p>防止未限定作用域枚举命名冲突有很多常见的做法;</p>
<p>一种是将每个枚举项都以前缀的形式加上枚举本身的名称:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">enum </span><span>Color
</span><span>{
</span><span>    color_red,
</span><span>    color_blue,
</span><span>    color_green,
</span><span>};
</span><span>
</span><span style="color:#b48ead;">enum </span><span>Feeling
</span><span>{
</span><span>    feeling_happy,
</span><span>    feeling_tired,
</span><span>    feeling_blue, 
</span><span>};
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Color </span><span style="color:#bf616a;">paint </span><span>{ color_blue };
</span><span>    Feeling </span><span style="color:#bf616a;">me </span><span>{ feeling_blue };
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>尽管这种做法还是有空间污染的情况,但是大大减少了命名冲突的几率;</p>
<p>更好的选择是将枚举类型放在一个提供独立作用域区域的结构中，例如命名空间：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">namespace </span><span>Color
</span><span>{
</span><span>    </span><span style="color:#65737e;">// 名称颜色，红色，蓝色和绿色是在命名空间颜色内定义的
</span><span>    </span><span style="color:#b48ead;">enum </span><span>Color
</span><span>    {
</span><span>        red,
</span><span>        green,
</span><span>        blue,
</span><span>    };
</span><span>}
</span><span>
</span><span style="color:#b48ead;">namespace </span><span>Feeling
</span><span>{
</span><span>    </span><span style="color:#b48ead;">enum </span><span>Feeling
</span><span>    {
</span><span>        happy,
</span><span>        tired,
</span><span>        blue, </span><span style="color:#65737e;">// 由于命名空间不同,这里的blue和Color中的blue不会产生冲突
</span><span>    };
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Color::Color </span><span style="color:#bf616a;">paint</span><span>{ Color::blue };
</span><span>    Feeling::Feeling </span><span style="color:#bf616a;">me</span><span>{ Feeling::blue };
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p><strong>最佳实践</strong></p>
<blockquote>
<p>尽量将枚举放在命名的作用域区域（例如命名空间或类）中，以防止枚举器污染全局命名空间。</p>
</blockquote>
<hr />
<h3 id="mei-ju-zhi-de-bi-jiao">枚举值的比较</h3>
<p>我们可以使用相等运算符（ <code>operator==</code> 和 <code>operator!=</code> ）来测试某个枚举是否具有特定枚举项的值。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">enum </span><span>Color
</span><span>{
</span><span>    red,
</span><span>    green,
</span><span>    blue,
</span><span>};
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Color </span><span style="color:#bf616a;">shirt</span><span>{ blue };
</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span>(shirt == blue) </span><span style="color:#65737e;">// if the shirt is blue
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Your shirt is blue!</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">else
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Your shirt is not blue!</span><span>&quot;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<hr />
<h3 id="wu-fan-wei-mei-ju-zheng-shu-zhuan-huan">无范围枚举整数转换</h3>
<p>在上面的内容中,我们提到过枚举器是符号常量。但其实这些枚举器具有整型值。</p>
<p>当我们定义一个枚举时，每个枚举项会自动与一个整数值关联，该值基于其在枚举列表中的位置。默认情况下，第一个枚举项被赋予整数值 0，而每个后续的枚举项的值比前一个枚举项大 1.</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">enum </span><span>Color
</span><span>{
</span><span>    black,   </span><span style="color:#65737e;">// 0
</span><span>    red,     </span><span style="color:#65737e;">// 1
</span><span>    blue,    </span><span style="color:#65737e;">// 2
</span><span>    green,   </span><span style="color:#65737e;">// 3
</span><span>    white,   </span><span style="color:#65737e;">// 4
</span><span>    cyan,    </span><span style="color:#65737e;">// 5
</span><span>    yellow,  </span><span style="color:#65737e;">// 6
</span><span>    magenta, </span><span style="color:#65737e;">// 7
</span><span>};
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Color </span><span style="color:#bf616a;">shirt</span><span>{ blue }; </span><span style="color:#65737e;">// shirt实际存储的值是2
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>可以显式的定义枚举器的值。这些整数值可以是正数或者负数,并且可以与其他枚举器共享相同的值。为定义的任何枚举器将被赋予比前一个枚举器大1的值。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">enum </span><span>Animal
</span><span>{
</span><span>    cat = -</span><span style="color:#d08770;">3</span><span>,    </span><span style="color:#65737e;">// 
</span><span>    dog,         </span><span style="color:#65737e;">// -2
</span><span>    pig,         </span><span style="color:#65737e;">// -1
</span><span>    horse = </span><span style="color:#d08770;">5</span><span>,
</span><span>    giraffe = </span><span style="color:#d08770;">5</span><span>, 
</span><span>    chicken,     </span><span style="color:#65737e;">// 6
</span><span>};
</span></code></pre>
<p>请注意，在这个例子中，<strong>horse</strong>（马）和 <strong>giraffe</strong>（长颈鹿）被赋予了相同的值。当这种情况发生时，这两个<strong>枚举器 (enumerators)</strong> 将变得<strong>不再唯一 (non-distinct)</strong> —— 本质上，<strong>horse</strong> 和 <strong>giraffe</strong> 可以互换使用。</p>
<p>虽然 C++ <strong>允许</strong>在同一个<strong>枚举 (enumeration)</strong> 中为<strong>两个枚举器</strong>分配相同的值，但<strong>通常应尽量避免</strong>这样做。</p>
<p><strong>最佳实践</strong></p>
<blockquote>
<p>除非你有充分的理由,否则不要为枚举器显式的赋值。</p>
</blockquote>
<hr />
<h3 id="dui-mei-ju-jin-xing-zhi-chu-shi-hua">对枚举进行值初始化</h3>
<p>如果一个<strong>枚举类型 (enumeration)</strong> 被<strong>零初始化 (zero-initialized)</strong>（例如在进行<strong>值初始化 (value-initialization)</strong> 时发生这种情况），那么该枚举将被赋值为 0，即使枚举中<strong>并不存在</strong>值为 0 的<strong>枚举器 (enumerator)</strong>。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#65737e;">//  注意:在此列表中没有具有值0的枚举器
</span><span style="color:#b48ead;">enum </span><span>Animal
</span><span>{
</span><span>    cat = -</span><span style="color:#d08770;">3</span><span>,    </span><span style="color:#65737e;">// -3
</span><span>    dog,         </span><span style="color:#65737e;">// -2
</span><span>    pig,         </span><span style="color:#65737e;">// -1
</span><span>    horse = </span><span style="color:#d08770;">5</span><span>,   </span><span style="color:#65737e;">// 5
</span><span>    giraffe = </span><span style="color:#d08770;">5</span><span>, </span><span style="color:#65737e;">// 5
</span><span>    chicken,     </span><span style="color:#65737e;">// 6
</span><span>};
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Animal </span><span style="color:#bf616a;">a </span><span>{}; </span><span style="color:#65737e;">// 这里会将a初始化为0,即使在枚举项中并没有这个枚举
</span><span>    std::cout &lt;&lt; a; </span><span style="color:#65737e;">// prints 0
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>如果存在值为 0 的枚举项，值初始化将枚举类型默认为该枚举项的意义。例如，使用前面的 <code>enum Color</code> 示例，值初始化的 <code>Color</code> 将默认为 <code>black</code> 。因此，最好考虑将值为 0 的枚举项设置为你的枚举的最佳默认意义。</p>
<p><strong>最佳实践:</strong></p>
<blockquote>
<ul>
<li>
<p>使用表示0的枚举项作为你枚举的最佳默认值。</p>
</li>
<li>
<p>如果没有好的默认含义,可以考虑添加一个表示“无效”或者“未知”的枚举,其值为0 ,这样的状态可以明确记录并在适当的地方进行显式的处理。</p>
</li>
</ul>
</blockquote>
<hr />
<h3 id="wu-fan-wei-mei-ju-hui-yin-shi-zhuan-huan-wei-zheng-shu-zhi">无范围枚举会隐式转换为整数值</h3>
<p>尽管枚举存储整数值，但它们并不被视为整数类型（它们是复合类型）。然而，无范围枚举会隐式转换为整数值。</p>
<p>因为枚举器是编译时常量，因此这是一个 constexpr 转换,考虑下面程序:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">enum </span><span>Color
</span><span>{
</span><span>    black, </span><span style="color:#65737e;">//  0
</span><span>    red, </span><span style="color:#65737e;">//  1
</span><span>    blue, </span><span style="color:#65737e;">//  2
</span><span>    green, </span><span style="color:#65737e;">//  3
</span><span>    white, </span><span style="color:#65737e;">//  4
</span><span>    cyan, </span><span style="color:#65737e;">//  5
</span><span>    yellow, </span><span style="color:#65737e;">//  6
</span><span>    magenta, </span><span style="color:#65737e;">//  7
</span><span>};
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Color </span><span style="color:#bf616a;">shirt</span><span>{ blue };
</span><span>
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Your shirt is </span><span>&quot; &lt;&lt; shirt &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;; </span><span style="color:#65737e;">// prints 2
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>当一个枚举类型在函数调用或与某个运算符一起使用时，编译器会首先尝试找到一个与该枚举类型匹配的函数或运算符。例如，当编译器尝试编译<code> std::cout &lt;&lt; shirt</code> 时，编译器会首先检查 <code>operator&lt;&lt;</code> 是否知道如何将 <code>Color</code> 类型的对象（因为 shirt 是 Color 类型）输出到 <code>std::cout</code> 中。但它并不支持这种操作。</p>
<p>由于编译器找不到匹配的运算符，它接着会检查<code> operator&lt;&lt;</code> 是否知道如何打印非作用域枚举转换成的整型类型的对象。由于它确实支持这种操作，<code>shirt</code> 中的值会被转换为一个整型值，并以整型值 <code>2</code> 的形式打印出来。</p>
<hr />
<h3 id="mei-ju-da-xiao-he-ji-chu-lei-xing">枚举大小和基础类型</h3>
<p>枚举器具有整型值。但是具体是哪一种类型的整型呢?</p>
<p>对于无范围枚举类型,C++并没有标准规定使用哪一种具体的整数类型作为底层类型,因此该选择是由实现决定的。大多数编译器会使用<code>int</code>类型作为底层类型。</p>
<p>我们可以显式的指定枚举的底层类型,且必须是整数类型。例如,如果你的程序应用在一个对对带宽敏感的环境中,那么也许你会希望将枚举指定为一个较小的值。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">cstdint</span><span>&gt;  </span><span style="color:#65737e;">// for std::int8_t
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#65737e;">// 显式的指定枚举器的整数类型
</span><span style="color:#b48ead;">enum </span><span>Color : </span><span style="color:#a3be8c;">std::int8_t
</span><span>{
</span><span>    black,
</span><span>    red,
</span><span>    blue,
</span><span>};
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Color </span><span style="color:#bf616a;">c</span><span>{ black };
</span><span>    std::cout &lt;&lt; sizeof(c) &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;; </span><span style="color:#65737e;">// prints 1 (byte)
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p><strong>最佳实践</strong></p>
<blockquote>
<p>仅在必要时指定枚举的基本类型。</p>
</blockquote>
<h3 id="zheng-shu-dao-wu-fan-wei-mei-ju-lei-xing-de-zhuan-huan">整数到无范围枚举类型的转换</h3>
<p>编译器会隐式的将无范围枚举转为整数,但是这个过程反过来是不成立的,不会隐式的将整数转换为无范围枚举。所以下面的代码会产生编译错误:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">enum </span><span>Pet </span><span style="color:#65737e;">// 未指定基类型
</span><span>{
</span><span>    cat,   </span><span style="color:#65737e;">// 分配值 0
</span><span>    dog,   </span><span style="color:#65737e;">// 分配值 1
</span><span>    pig,   </span><span style="color:#65737e;">// 分配值 2
</span><span>    whale, </span><span style="color:#65737e;">// 分配值 3
</span><span>};
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Pet </span><span style="color:#bf616a;">pet </span><span>{ </span><span style="color:#d08770;">2 </span><span>}; </span><span style="color:#65737e;">// 编译错误：整数值 2 不能隐式转换为 Pet 类型
</span><span>    pet = </span><span style="color:#d08770;">3</span><span>;       </span><span style="color:#65737e;">// 编译错误：整数值 3 不能隐式转换为 Pet 类型
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>如果确实需要进行转换,那么可以使用<code>static_cast</code>进行显式的转换</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">enum </span><span>Pet </span><span style="color:#65737e;">// 未指定基类型
</span><span>{
</span><span>    cat,   </span><span style="color:#65737e;">// 分配值 0
</span><span>    dog,   </span><span style="color:#65737e;">// 分配值 1
</span><span>    pig,   </span><span style="color:#65737e;">// 分配值 2
</span><span>    whale, </span><span style="color:#65737e;">// 分配值 3
</span><span>};
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Pet </span><span style="color:#bf616a;">pet </span><span>{ static_cast&lt;Pet&gt;(</span><span style="color:#d08770;">2</span><span>) }; 
</span><span>    pet = static_cast&lt;Pet&gt;(</span><span style="color:#d08770;">3</span><span>);      
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>其次，从 C++17 开始，如果一个<strong>非作用域枚举 (unscoped enumeration)</strong> <strong>显式指定了基类型 (explicitly specified base)</strong>，那么编译器将允许你使用一个<strong>整型值 (integral value)</strong> 对该枚举进行<strong>列表初始化 (list initialization)</strong>。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">enum </span><span>Pet: </span><span style="color:#a3be8c;">int </span><span style="color:#65737e;">// 我们已经指定了基类型
</span><span>{
</span><span>    cat,   </span><span style="color:#65737e;">// 分配值 0
</span><span>    dog,   </span><span style="color:#65737e;">// 分配值 1
</span><span>    pig,   </span><span style="color:#65737e;">// 分配值 2
</span><span>    whale, </span><span style="color:#65737e;">// 分配值 3
</span><span>};
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Pet </span><span style="color:#bf616a;">pet1 </span><span>{ </span><span style="color:#d08770;">2 </span><span>}; </span><span style="color:#65737e;">// ✅ 可以使用大括号初始化非作用域枚举 (C++17) ，因为指定了基类型
</span><span>    Pet </span><span style="color:#bf616a;">pet2 </span><span>(</span><span style="color:#d08770;">2</span><span>);   </span><span style="color:#65737e;">// ❌ 编译错误：不能使用圆括号直接初始化整数值
</span><span>    Pet pet3 = </span><span style="color:#d08770;">2</span><span>;   </span><span style="color:#65737e;">// ❌ 编译错误：不能通过赋值初始化整数值
</span><span>
</span><span>    pet1 = </span><span style="color:#d08770;">3</span><span>;       </span><span style="color:#65737e;">// ❌ 编译错误：不能直接赋值整数值
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<hr />
<h3 id="mei-ju-he-zi-fu-chuan-de-xiang-hu-zhuan-huan">枚举和字符串的相互转换</h3>
<p>基于上面讨论的枚举和整数转换的例子中,将枚举作为整数值打印出来并不难,但这并不是我们想要的,通常情况下,我们更希望打印的是枚举项名称,比如<code>blue</code> ;尽管C++并没有内置的实现方案,但是我们可以自己探索:</p>
<p>获取枚举值名称的典型方法是编写一个函数，允许我们传入一个枚举值，并返回该枚举值的名称作为字符串。但这样做需要某种方式来确定对于给定的枚举值应该返回哪个字符串。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string_view</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">enum </span><span>Color
</span><span>{
</span><span>    black,
</span><span>    red,
</span><span>    blue,
</span><span>};
</span><span>
</span><span style="color:#b48ead;">constexpr</span><span> std::string_view </span><span style="color:#8fa1b3;">getColorName</span><span>(Color </span><span style="color:#bf616a;">color</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">switch </span><span>(color)
</span><span>    {
</span><span>    </span><span style="color:#b48ead;">case</span><span> black: </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">black</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">case</span><span> red:   </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">red</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">case</span><span> blue:  </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">blue</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">default</span><span>:    </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">???</span><span>&quot;;
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">constexpr</span><span> Color </span><span style="color:#bf616a;">shirt</span><span>{ blue };
</span><span>
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Your shirt is </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">getColorName</span><span>(shirt) &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<blockquote>
<p>该函数是 <code>constexpr</code> 的，这样我们就可以在常量表达式中使用颜色的名称。</p>
</blockquote>
<p>虽然这样可以让我们获取枚举项的名称，但如果我们要将这个名称打印到控制台，不得不使用 <code>std::cout &lt;&lt; getColorName(shirt)</code> 并不比 <code>std::cout &lt;&lt; shirt</code> 方便多少。我们将在后续的博文中学习通过I/O操作符重载的方式使用 <code>std::cout</code> 打印枚举。</p>
<hr />
<h3 id="wu-fan-wei-mei-ju-de-shu-ru">无范围枚举的输入</h3>
<p>在以下示例中，我们定义了一个 <code>Pet</code> 枚举。因为 <code>Pet</code> 是用户定义的类型，语言不知道如何通过 <code>std::cin</code> 输入一个 <code>Pet</code> ：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">enum </span><span>Pet
</span><span>{
</span><span>    cat,   </span><span style="color:#65737e;">// 0
</span><span>    dog,   </span><span style="color:#65737e;">// 1
</span><span>    pig,   </span><span style="color:#65737e;">// 2
</span><span>    whale, </span><span style="color:#65737e;">// 3
</span><span>};
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Pet </span><span style="color:#bf616a;">pet </span><span>{ pig };
</span><span>    std::cin &gt;&gt; pet; </span><span style="color:#65737e;">// 编译错误
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>一种简单的方式是读取一个整数,然后使用<code>static_cats</code>将整数转换为相应的枚举类型;</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string_view</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">enum </span><span>Pet
</span><span>{
</span><span>    cat,   </span><span style="color:#65737e;">// 0
</span><span>    dog,   </span><span style="color:#65737e;">// 1
</span><span>    pig,   </span><span style="color:#65737e;">// 2
</span><span>    whale, </span><span style="color:#65737e;">// 3
</span><span>};
</span><span>
</span><span style="color:#b48ead;">constexpr</span><span> std::string_view </span><span style="color:#8fa1b3;">getPetName</span><span>(Pet </span><span style="color:#bf616a;">pet</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">switch </span><span>(pet)
</span><span>    {
</span><span>    </span><span style="color:#b48ead;">case</span><span> cat:   </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">cat</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">case</span><span> dog:   </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">dog</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">case</span><span> pig:   </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">pig</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">case</span><span> whale: </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">whale</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">default</span><span>:    </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">???</span><span>&quot;;
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Enter a pet (0=cat, 1=dog, 2=pig, 3=whale): </span><span>&quot;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">input</span><span>{};
</span><span>    std::cin &gt;&gt; input; </span><span style="color:#65737e;">// input an integer
</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span>(input &lt; </span><span style="color:#d08770;">0 </span><span>|| input &gt; </span><span style="color:#d08770;">3</span><span>)
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">You entered an invalid pet</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">else
</span><span>    {
</span><span>        Pet </span><span style="color:#bf616a;">pet</span><span>{ static_cast&lt;Pet&gt;(input) }; 
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">You entered: </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">getPetName</span><span>(pet) &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>与其输入一个数字，让用户输入一个表示枚举项的字符串（例如“pig”），然后我们将该字符串转换为相应的枚举项会更好。然而，做到这一点需要我们解决几个问题。</p>
<p>首先，我们不能使用字符串进行 switch 语句，因此我们需要使用其他方式来匹配用户传递的字符串。这里最简单的方法是使用一系列 if 语句。</p>
<p>其次，如果用户传递进一个无效的字符串，我们应该返回哪个枚举值？一种选择是添加一个表示<code>“none/invalid”</code>的枚举值，并返回它。然而，更好的选择是使用 <code>std::optional</code> 。</p>
<p>关于<code>std::optional</code>,在之前的博客中有介绍过,传送门:<a class="" href="https://www.ilikexff.cn/articles/153">[通俗易懂C++]:std::optional</a></p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">optional</span><span>&gt; </span><span style="color:#65737e;">// for std::optional
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string_view</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">enum </span><span>Pet
</span><span>{
</span><span>    cat,   </span><span style="color:#65737e;">// 0
</span><span>    dog,   </span><span style="color:#65737e;">// 1
</span><span>    pig,   </span><span style="color:#65737e;">// 2
</span><span>    whale, </span><span style="color:#65737e;">// 3
</span><span>};
</span><span>
</span><span style="color:#b48ead;">constexpr</span><span> std::string_view </span><span style="color:#8fa1b3;">getPetName</span><span>(Pet </span><span style="color:#bf616a;">pet</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">switch </span><span>(pet)
</span><span>    {
</span><span>    </span><span style="color:#b48ead;">case</span><span> cat:   </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">cat</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">case</span><span> dog:   </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">dog</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">case</span><span> pig:   </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">pig</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">case</span><span> whale: </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">whale</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">default</span><span>:    </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">???</span><span>&quot;;
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">constexpr</span><span> std::optional&lt;Pet&gt; </span><span style="color:#8fa1b3;">getPetFromString</span><span>(std::string_view </span><span style="color:#bf616a;">sv</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">if </span><span>(sv == &quot;</span><span style="color:#a3be8c;">cat</span><span>&quot;)   </span><span style="color:#b48ead;">return</span><span> cat;
</span><span>    </span><span style="color:#b48ead;">if </span><span>(sv == &quot;</span><span style="color:#a3be8c;">dog</span><span>&quot;)   </span><span style="color:#b48ead;">return</span><span> dog;
</span><span>    </span><span style="color:#b48ead;">if </span><span>(sv == &quot;</span><span style="color:#a3be8c;">pig</span><span>&quot;)   </span><span style="color:#b48ead;">return</span><span> pig;
</span><span>    </span><span style="color:#b48ead;">if </span><span>(sv == &quot;</span><span style="color:#a3be8c;">whale</span><span>&quot;) </span><span style="color:#b48ead;">return</span><span> whale;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span>{};
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Enter a pet: cat, dog, pig, or whale: </span><span>&quot;;
</span><span>    std::string </span><span style="color:#bf616a;">s</span><span>{};
</span><span>    std::cin &gt;&gt; s;
</span><span>
</span><span>    std::optional&lt;Pet&gt; </span><span style="color:#bf616a;">pet </span><span>{ </span><span style="color:#bf616a;">getPetFromString</span><span>(s) };
</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span>(!pet)
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">You entered an invalid pet</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">else
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">You entered: </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">getPetName</span><span>(*pet) &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>

        </div>
      </div>
      <div class="prompt" id="terminal"><input
    type="text"
    id="setter"
    onkeydown="writeit(this, event);moveIt(this.value.length, event)"
    onchange="writeit(this, event)"
    onkeyup="writeit(this, event)"
    onkeypress="writeit(this, event);"
    >
<label for="setter" id="writer"> </label><b class="cursor" id="cursor"></b></div>
      <footer class="footer">
        <div class="footer-content">
          <p class="icp-info">
            <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer">黔ICP备2021010295号</a>
          </p>
        </div>
      </footer>
    </main>
  </body>

</html>
