<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>慕予博客</title>
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"
    integrity="sha256-WCzAhd2P6gRJF9Hv3oOOd+hFJi/QJbv+Azn4CGB8gfY=" crossorigin="anonymous" defer></script>
  <script src="/js/index.js" defer></script>
  <script src="/js/prompt.js" defer></script>
  <script src="/js/keyboard.js" defer></script>
  <script src="/js/tab.js" defer></script>
  <script src="/js/commands.js" defer></script>
  <script src="/js/config.js" defer></script><script src="/config.js"></script><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="style.css"><link rel="stylesheet" href="/css/page.css"></head><body onkeydown='exec(event)' style='background-image: url("/assets/background.jpg");'><main>
      <div class="files" id="files" tabindex="0">
<ul>

  <li class="file">
    <span><a href='https://ilikexff.cn/8-kuan-rang-ni-kai-fa-qi-fei-de-intellijidea-cha-jian/'
      tabindex="-2">  8款让你开发起飞的IntellijIDEA插件</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/aop-jie-mi-qie-mian-bian-cheng-de-zong-he-zhi-nan/'
      tabindex="-3">  AOP揭秘：切面编程的综合指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-mei-ju-pian-yi-wu-fan-wei-mei-ju/'
      tabindex="-4">  C++游戏开发基础-枚举篇一：无范围枚举</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-std-optional/'
      tabindex="-5">  C++游戏开发基础-深入解析std::optional</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shen-ru-jie-xi-thiszhi-zhen-de-ying-yong-yu-ji-qiao/'
      tabindex="-6">  C++游戏开发基础-深入解析this指针的应用与技巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-fu-zhi-gou-zao-han-shu/'
      tabindex="-7">  C++游戏开发基础-深入解析复制构造函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-mo-ban-he-can-shu-tui-dao-zhi-nan/'
      tabindex="-8">  C++游戏开发基础-类模版和参数推导指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/dockerbi-zhi-bi-hui/'
      tabindex="-9">  Docker必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/githithub-xiao-ce/'
      tabindex="-10">  GitGitHub小册</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/google-hacking/'
      tabindex="-11">  Google Hacking</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/googleguan-fang-ti-shi-gong-cheng-bai-pi-shu-zhong-wen-yi-ben/'
      tabindex="-12">  Google官方《提示工程白皮书（中文译本）》</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-dai-ma-bu-quan-ti-shi-gong-neng-xiao-shi-de-ji-chong-jie-jue-fang-an-re-geng-ban/'
      tabindex="-13">  IDEA代码补全&amp;提示功能消失的几种解决方案(热更版)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-chen-jin-shi-bian-cheng-ti-yan/'
      tabindex="-14">  IDEA沉浸式编程体验</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-han-shu-shi-bian-cheng/'
      tabindex="-15">  Java函数式编程</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-ji-he-yuan-ma-qian-xi/'
      tabindex="-16">  Java集合源码浅析</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mysql-shi-wu-te-xing-yu-ge-chi-ji-bie-xiang-jie/'
      tabindex="-17">  MySQL_事务特性与隔离级别详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ocao-zuo-fu-shi-xian-mei-ju-de-shu-ru-shu-chu/'
      tabindex="-18">  O操作符,实现枚举的输入输出</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/prdsuan-fa-ting-shuo-ni-xiang-ping-yun-qi-chou-yi-ke-rong-yao-shui-jing/'
      tabindex="-19">  PRD算法：听说你想凭运气抽一颗荣耀水晶?</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/picgo-pei-zhi-ge-chong-tu-chuang/'
      tabindex="-20">  PicGo配置各种图床</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/redis-bi-zhi-bi-hui/'
      tabindex="-21">  Redis必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-zhong-de-move-yu-yi-sui-bi/'
      tabindex="-22">  Rust中的move语义随笔</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ssm-kuang-jia-shi-xian-ji-cheng-duan-xin-yan-zheng-ma-gong-neng/'
      tabindex="-23">  SSM框架实现集成短信验证码功能</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/slf4jyu-logbackshi-yong-zhi-nan-ji-yu-gradle/'
      tabindex="-24">  Slf4j与Logback实用指南(基于Gradle)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/spring-security5-xdao-spring-security6-xde-qian-yi/'
      tabindex="-25">  Spring Security5.x到Spring Security6.x的迁移</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springboot-webkai-fa-jing-jie/'
      tabindex="-26">  SpringBoot Web开发精解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springsecurity/'
      tabindex="-27">  SpringSecurity</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/unity6xia-jia-zhong-guo-qu-tuan-jie-yin-qing-jie-bang-zhe-shi-fen-lie-huan-shi-ben-di-hua-de-kai-shi/'
      tabindex="-28">  Unity6下架中国区，团结引擎接棒：这是分裂，还是本地化的开始？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-cong-0-dao-1-da-zao-quan-yu-yan-zhi-chi-de-mo-neng-bian-ji-qi-yu-fa-pian/'
      tabindex="-29">  Vim从0到1打造全语言支持的万能编辑器-语法篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-tiao-tou-powershell-pian/'
      tabindex="-30">  Vim折腾之 PowerShell篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-di-zhi-chuan-di-xiang-jie/'
      tabindex="-31">  [C++游戏开发基础]:地址传递详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-yin-yong-fan-hui-he-di-zhi-fan-hui/'
      tabindex="-32">  [C++游戏开发基础]:引用返回和地址返回</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-he-const/'
      tabindex="-33">  [C++游戏开发基础]:指针和const</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shu-ju-feng-zhuang-yin-cang-de-hao-chu/'
      tabindex="-34">  [C++游戏开发基础]:数据封装(隐藏)的好处</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-gou-zao-han-shu-qian-xi-8000zi/'
      tabindex="-35">  [C++游戏开发基础]:构造函数浅析(8000字)</a></span>
  </li><li class="file">
    <span><a class="selected"href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-li-jie-kong-zhi-zhen/'
      tabindex="-36">  [C++游戏开发基础]:理解空指针</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-zhong-de-fang-wen-han-shu/'
      tabindex="-37">  [C++游戏开发基础]:类中的访问函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-de-ji-ben-gai-nian-li-jie/'
      tabindex="-38">  [C++游戏开发基础]指针的基本概念理解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/fanatical-wu-yue-feng-kuang-te-hui-wei-ni-de-steam-ku-jia-dian-liao/'
      tabindex="-39">  _Fanatical 五月疯狂特惠：为你的 Steam 库加点料！</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-kai-yuan-mi-ma-gong-ju-xpwd-zhong-wen-ban-bian-geng-ri-zhi/'
      tabindex="-40">  _Rust开源密码工具xpwd中文版变更日志</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/readme/'
      tabindex="-41">  readme</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wblog-bo-ke-xian-shang-bu-shu/'
      tabindex="-42">  wblog博客线上部署</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/shang-gu-shen-qi-vim-su-cheng-bei-wang-lu/'
      tabindex="-43">  上古神器_Vim速成备忘录</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mian-fei-ji-huo-quan-ban-ben-typora-zui-xin-ban-wei-li/'
      tabindex="-44">  免费激活全版本Typora，最新版为例</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-lombokxian-wei-ren-zhi-de-ji-ge-qi-ji-yin-qiao/'
      tabindex="-45">  关于Lombok鲜为人知的几个奇技淫巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-jie-kou-xian-liu-de-yi-ci-jian-dan-shi-jian/'
      tabindex="-46">  关于接口限流的一次简单实践</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/tu-jie-er-jin-zhi/'
      tabindex="-47">  图解二进制</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ru-he-xie-de-yi-shou-you-ya-gui-fan-de-springboot-jie-kou/'
      tabindex="-48">  如何写得一手优雅规范的SpringBoot 接口？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/kai-fa-bi-hui-xi-lie-jwtqian-tan/'
      tabindex="-49">  开发必会系列_JWT浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ji-qiao-jiu-shi-xiao-lu-chatgpt-diao-jiao-zhi-bei/'
      tabindex="-50">  技巧就是效率，ChatGPT调教指北</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-sheng-intellij-kai-fa-xiao-lu-zhe-kuan-dai-ma-tu-ding-cha-jian-codepins-zhi-de-yi-shi/'
      tabindex="-51">  提升 IntelliJ 开发效率？这款代码图钉插件 CodePins 值得一试</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-wen-de-zhi-hui-zhuan-zai/'
      tabindex="-52">  提问的智慧转载</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiao-lu-gong-ju-markdown/'
      tabindex="-53">  效率工具Markdown</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wu-wei-bing-fa-rust-sheng-ming-zhou-qi-qian-tan/'
      tabindex="-54">  无畏并发_Rust 生命周期浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-yu-de-bei-sai-er-qu-xian-gan-shou-si-hua-de-shu-xue-zhi-mei/'
      tabindex="-55">  游戏开发与的贝塞尔曲线_感受丝滑的数学之美</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-bi-bei-gao-xiao-de-aabb-qiu-ti-he-obb-peng-zhuang-jian-ce-suan-fa/'
      tabindex="-56">  游戏开发必备：高效的 AABB、球体和 OBB 碰撞检测算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-suan-fa-ji-chu-a-xun-lu-suan-fa-chi-xu-wei-hu/'
      tabindex="-57">  游戏算法基础-深入解析A*寻路算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/du-li-you-xi-kai-fa-zhe-gong-ju-xiang-2025jing-xuan-tui-jian-yu-shi-yong-zhi-nan/'
      tabindex="-58">  独立游戏开发者工具箱：2025精选推荐与实用指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xu-huan-yin-qing-you-xi-kai-fa-xi-lie-zhuan-ti-guan-fang-bian-ma-biao-zhun-huo-gui-yue/'
      tabindex="-59">  虚幻引擎游戏开发系列专题-官方编码标准或规约</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiang-jie-she-ji-mo-shi-dan-li-de-jin-hua-zhi-lu/'
      tabindex="-60">  详解设计模式_单例的进化之路</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xie-e-de-fei-chang-liang-quan-ju-bian-liang/'
      tabindex="-61">  邪恶的非常量全局变量</a></span>
  </li>
</ul>
</div>
      <div class="viewer page" id="viewer" tabindex="0">
        <div class="tab">
<div class="file-manager" onclick='document.getElementById("files").classList.toggle("open"); document.getElementById("content").classList.toggle("close")'> </div>
<ul id="tabs">
</ul>


</div>
        <div class="content" id="content"><p>除了指向内存地址外,指针还可以指向一个空值(<code>null</code>),空值是一个特殊的值,可以理解为没有值。当一个指针持有空值时,意味着该指针没有指向任何东西,这样的指针被称为<strong>空指针</strong>!</p>
<p>创建空指针最简单的方法是使用值进行初始化:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>  </span><span style="color:#b48ead;">int</span><span>* </span><span style="color:#bf616a;">ptr </span><span>{}; </span><span style="color:#65737e;">// PTR现在是一个无效的指针，没有持有地址
</span><span>  </span><span style="color:#b48ead;">int</span><span>* ptr1 = </span><span style="color:#d08770;">nullptr</span><span>; </span><span style="color:#65737e;">// 等效的空指针初始化
</span><span>  </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>因为我们可以使用赋值来改变指针所指向的内容，所以最初设置为 null 的指针后来可以被改变，指向一个有效的对象：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">int</span><span>* ptr = </span><span style="color:#d08770;">nullptr</span><span>; </span><span style="color:#65737e;">// 初始化一个空指针
</span><span>    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x </span><span>{</span><span style="color:#d08770;">5</span><span>};
</span><span>    ptr = &amp;x;
</span><span>    std::cout &lt;&lt; *ptr &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>    
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<hr />
<h2 id="nullptrguan-jian-zi">nullptr关键字</h2>
<p>与关键字 <code>true</code> 和 <code>false</code> 表示布尔字面值类似，<code>nullptr </code>关键字表示空指针字面值。我们可以使用 <code>nullptr</code> 来显式初始化或分配一个指针为空值。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">int</span><span>* </span><span style="color:#bf616a;">ptr </span><span>{ </span><span style="color:#d08770;">nullptr </span><span>}; </span><span style="color:#65737e;">// 可以使用 nullptr 将指针初始化为 null 指针
</span><span>
</span><span>    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">value </span><span>{ </span><span style="color:#d08770;">5 </span><span>};
</span><span>    </span><span style="color:#b48ead;">int</span><span>* </span><span style="color:#bf616a;">ptr2 </span><span>{ &amp;value }; </span><span style="color:#65737e;">// ptr2 是一个有效的指针，指向 value
</span><span>    ptr2 = </span><span style="color:#d08770;">nullptr</span><span>; </span><span style="color:#65737e;">// 可以将 nullptr 赋给指针，来将指针变为 null 指针
</span><span>
</span><span>    </span><span style="color:#bf616a;">someFunction</span><span>(</span><span style="color:#d08770;">nullptr</span><span>); </span><span style="color:#65737e;">// 我们也可以将 nullptr 作为参数传递给需要指针类型的函数
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<blockquote>
<p>当需要为初始化、赋值或将空指针传递给函数时,最佳实践是使用<code>nullptr</code></p>
</blockquote>
<hr />
<h2 id="jie-yin-yong-kong-zhi-zhen">解引用空指针</h2>
<p>和解引用野指针导致的为定义行为类似,对空指针解引用也会出现为定义行为。在大多数情况下,它会导致你的应用程序崩溃。以下程序可以帮你加深理解:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">int</span><span>* ptr = {};
</span><span>    std::cout &lt;&lt; *ptr &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>    
</span><span>    
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p><img src="https://images.waer.ltd/notes/202502191835430.png" alt="image-20250219183518231" loading="lazy" decoding="async" /></p>
<p>这也是作为C++开发者最常见的错误之一,也就是意外的解引用野指针和空指针导致的程序崩溃。因此:</p>
<blockquote>
<p>无论何时使用指针,都需要格外的关注这一点,确保你的代码没有解引用空指针或者悬空指针,这会导致为定义行为,进而使得应用程序崩溃,一旦程序崩溃导致严重线上问题,那么你的领导可能就用‘C’语言和你交流了。</p>
</blockquote>
<hr />
<h2 id="">空指针的检查</h2>
<p>我们可以使用条件来测试指针是否为<code>nullptr</code>:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x </span><span>{ </span><span style="color:#d08770;">5 </span><span>};
</span><span>    </span><span style="color:#b48ead;">int</span><span>* </span><span style="color:#bf616a;">ptr </span><span>{ &amp;x };
</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span>(ptr == </span><span style="color:#d08770;">nullptr</span><span>) 
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">ptr is null</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">else
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">ptr is non-null</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">int</span><span>* </span><span style="color:#bf616a;">nullPtr </span><span>{};
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">nullPtr is </span><span>&quot; &lt;&lt; (nullPtr==</span><span style="color:#d08770;">nullptr </span><span>? &quot;</span><span style="color:#a3be8c;">null</span><span style="color:#96b5b4;">\n</span><span>&quot; : &quot;</span><span style="color:#a3be8c;">non-null</span><span style="color:#96b5b4;">\n</span><span>&quot;); 
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>类似于0隐式转换为<code>false</code>,非0整数转为<code>true</code>一样,指针也会隐式转会为布尔值,空指针转换为布尔值的<code>false</code>,非空指针则是转为<code>true</code> ,基于这个规则,我们就可以简化上面代码中的条件判断写法:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x </span><span>{ </span><span style="color:#d08770;">5 </span><span>};
</span><span>    </span><span style="color:#b48ead;">int</span><span>* </span><span style="color:#bf616a;">ptr </span><span>{ &amp;x };
</span><span>
</span><span>    </span><span style="color:#65737e;">// 指针在为空时会转换为布尔值 false，非空时会转换为布尔值 true
</span><span>    </span><span style="color:#b48ead;">if </span><span>(ptr) </span><span style="color:#65737e;">// 隐式转换为布尔值
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">ptr is non-null</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">else
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">ptr is null</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">int</span><span>* </span><span style="color:#bf616a;">nullPtr </span><span>{};  </span><span style="color:#65737e;">// nullPtr 初始化为 nullptr
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">nullPtr is </span><span>&quot; &lt;&lt; (nullPtr ? &quot;</span><span style="color:#a3be8c;">non-null</span><span style="color:#96b5b4;">\n</span><span>&quot; : &quot;</span><span style="color:#a3be8c;">null</span><span style="color:#96b5b4;">\n</span><span>&quot;); </span><span style="color:#65737e;">// 隐式转换为布尔值
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<blockquote>
<p>⚠️条件语句只能用来区分空指针和非空指针。没有便捷的方法可以判断一个非空指针是指向有效对象还是悬空（指向无效对象）。</p>
</blockquote>
<hr />
<h2 id="-1">避免悬空指针</h2>
<p>解引用一个空指针或悬空指针将导致未定义行为。因此，我们需要确保我们的代码不做这两件事情之一。</p>
<p>我们可以通过使用条件语句来确保在尝试解引用之前指针不是空指针，从而轻松避免解引用空指针：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">if </span><span>(ptr) 
</span><span>  </span><span style="color:#65737e;">// todo
</span><span style="color:#b48ead;">else
</span><span>  </span><span style="color:#65737e;">// todo
</span></code></pre>
<p>那么对于悬空指针怎么处理?因为没有办法检测一个指针是否为悬空指针,因此,一个有效的方法就是在写每一行代码时,尽可能避免存在任何悬空指针,通过确保任何不指向有效对象的指针都将它设置为<code>nullptr</code>来做到这一点。</p>
<blockquote>
<p>最佳实践:一个指针应该持有有效对象的地址，或者设置为 nullptr。这样我们只需要测试指针是否为空，并且可以假设任何非空指针都是有效的。</p>
</blockquote>
<p>当一个对象被销毁时，指向该已销毁对象的任何指针将悬空（它们不会自动设置为 <code>nullptr</code> ）。检测这些情况并确保这些指针随后被设置为 <code>nullptr</code> 是程序猿的责任。</p>
<hr />
<h2 id="-2">0和NULL</h2>
<p>在某些老版本代码中,你看会看到使用 0或者NULL这俩字面值来替代<code>nullptr</code>的情况。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">float</span><span>* </span><span style="color:#bf616a;">ptr </span><span>{ </span><span style="color:#d08770;">0 </span><span>};  </span><span style="color:#65737e;">// ptr 现在是一个空指针（只是举个例子，实际中不要这样做）
</span><span>
</span><span>    </span><span style="color:#b48ead;">float</span><span>* ptr2; </span><span style="color:#65737e;">// ptr2 是未初始化的
</span><span>    ptr2 = </span><span style="color:#d08770;">0</span><span>; </span><span style="color:#65737e;">// ptr2 现在是一个空指针（只是举个例子，实际中不要这样做）
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>此外,还有一个就是<code>NULL</code>的预处理宏。这个宏是从<code>C</code>语言中继承来的,在C中通常用于表示空指针。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">cstddef</span><span>&gt; </span><span style="color:#65737e;">// 引入 NULL，NULL 是一个宏定义，表示空指针
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">double</span><span>* </span><span style="color:#bf616a;">ptr </span><span>{ </span><span style="color:#d08770;">NULL </span><span>}; </span><span style="color:#65737e;">// ptr 是一个空指针
</span><span>
</span><span>    </span><span style="color:#b48ead;">double</span><span>* ptr2; </span><span style="color:#65737e;">// ptr2 是未初始化的
</span><span>    ptr2 = </span><span style="color:#d08770;">NULL</span><span>; </span><span style="color:#65737e;">// ptr2 现在是一个空指针
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<blockquote>
<p>现在C++中应该避免使用上面两个字面值来表示空指针;</p>
</blockquote>
<hr />
<h2 id="-3">优先使用引用而非指针</h2>
<p><strong>指针和引用都允许我们间接地访问其他对象。</strong></p>
<p>指针具有额外的功能，可以改变它们指向的对象，并且可以指向空（<code>null</code>）。然而，这些指针的功能也本质上是危险的：空指针有可能被解引用，而改变指针指向的对象会更容易导致悬空指针的产生：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">int</span><span>* </span><span style="color:#bf616a;">ptr </span><span>{ };
</span><span>
</span><span>    {
</span><span>        </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span>{ </span><span style="color:#d08770;">5 </span><span>};
</span><span>        ptr = &amp;x; </span><span style="color:#65737e;">// 将指针指向一个会被销毁的对象（引用无法做到这一点）
</span><span>    } </span><span style="color:#65737e;">// ptr 现在是悬空指针，指向了一个无效的对象
</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span>(ptr) </span><span style="color:#65737e;">// 条件语句返回 true，因为 ptr 不是 nullptr
</span><span>        std::cout &lt;&lt; *ptr; </span><span style="color:#65737e;">// 解引用悬空指针，导致未定义行为
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>引用不能像指针那样指向空（nullptr）。每次引用必须在创建时绑定到一个有效的对象，而且不能后期修改为引用另一个对象。因此，空引用的问题不会出现，也避免了因引用指向无效对象而导致的错误。</p>
<p>由于引用的绑定性和不可重新绑定的特性，使得引用相较于指针更安全。在大多数情况下，引用提供了更简洁、更安全的方式来访问对象，不会轻易出现如空引用、悬空引用等问题;</p>
<p>看个例子:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">int</span><span> x = </span><span style="color:#d08770;">10</span><span>;
</span><span>    </span><span style="color:#b48ead;">int</span><span>&amp; ref = x; </span><span style="color:#65737e;">// 引用ref绑定到x
</span><span>
</span><span>    std::cout &lt;&lt; ref &lt;&lt; std::endl; </span><span style="color:#65737e;">// 输出10
</span><span>
</span><span>    </span><span style="color:#65737e;">// 下面这行代码将会报错，因为引用无法绑定为空
</span><span>    </span><span style="color:#65737e;">// int&amp; nullRef = nullptr; // 错误：不能将引用绑定到nullptr
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<ul>
<li>
<p>在这个示例中，<code>int&amp; ref = x;</code> 是将 <code>ref</code> 绑定到 <code>x</code>。引用总是绑定到一个有效对象。</p>
</li>
<li>
<p>如果尝试使用 <code>nullptr</code> 来初始化引用，如 <code>int&amp; nullRef = nullptr;</code>，会导致编译错误。因为引用不能指向空`（null），这就消除了空引用的风险。</p>
</li>
</ul>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">add</span><span>(</span><span style="color:#b48ead;">int</span><span>&amp; </span><span style="color:#bf616a;">a</span><span>, </span><span style="color:#b48ead;">int</span><span>&amp; </span><span style="color:#bf616a;">b</span><span>) {
</span><span>    </span><span style="color:#b48ead;">return</span><span> a + b;
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">int</span><span> x = </span><span style="color:#d08770;">5</span><span>;
</span><span>    </span><span style="color:#b48ead;">int</span><span> y = </span><span style="color:#d08770;">10</span><span>;
</span><span>
</span><span>    </span><span style="color:#65737e;">// 引用更加安全，因为它无法为null，也不会悬空
</span><span>    std::cout &lt;&lt; </span><span style="color:#bf616a;">add</span><span>(x, y) &lt;&lt; std::endl; </span><span style="color:#65737e;">// 正常工作，输出15
</span><span>
</span><span>    </span><span style="color:#65737e;">// 使用指针时需要显式地处理空指针的情况
</span><span>    </span><span style="color:#b48ead;">int</span><span>* ptr1 = </span><span style="color:#d08770;">nullptr</span><span>;
</span><span>    </span><span style="color:#b48ead;">int</span><span>* ptr2 = &amp;x;
</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span>(ptr1 &amp;&amp; ptr2) {
</span><span>        std::cout &lt;&lt; *ptr1 + *ptr2 &lt;&lt; std::endl; </span><span style="color:#65737e;">// 可能崩溃，因为ptr1是空指针
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>在 <code>add</code> 函数中，我们使用引用来传递 <code>a</code> 和<code> b</code>。引用的好处是，我们不需要检查指针是否为空，引用始终绑定到有效的对象。</p>
<ul>
<li>
<p>如果我们使用指针（如 <code>ptr1</code> 和 <code>ptr2</code>），我们必须显式检查指针是否为<code> nullptr</code>，否则可能会发生崩溃或未定义行为。</p>
</li>
<li>
<p>引用避免了这种额外的检查，使得代码更加简洁和安全。</p>
</li>
</ul>
<p>所以:<strong>由于引用更安全，应该优先使用引用而非指针，除非指针提供的额外功能是必须的。</strong></p>
<blockquote>
<p>感谢阅读,欢迎指正!</p>
</blockquote>

        </div>
      </div>
      <div class="prompt" id="terminal"><input
    type="text"
    id="setter"
    onkeydown="writeit(this, event);moveIt(this.value.length, event)"
    onchange="writeit(this, event)"
    onkeyup="writeit(this, event)"
    onkeypress="writeit(this, event);"
    >
<label for="setter" id="writer"> </label><b class="cursor" id="cursor"></b></div>
      <footer class="footer">
        <div class="footer-content">
          <p class="icp-info">
            <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer">黔ICP备2021010295号</a>
          </p>
        </div>
      </footer>
    </main>
  </body>

</html>
