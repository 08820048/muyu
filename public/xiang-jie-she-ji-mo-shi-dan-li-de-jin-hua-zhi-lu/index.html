<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>慕予博客</title>
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"
    integrity="sha256-WCzAhd2P6gRJF9Hv3oOOd+hFJi/QJbv+Azn4CGB8gfY=" crossorigin="anonymous" defer></script>
  <script src="/js/index.js" defer></script>
  <script src="/js/prompt.js" defer></script>
  <script src="/js/keyboard.js" defer></script>
  <script src="/js/tab.js" defer></script>
  <script src="/js/commands.js" defer></script>
  <script src="/js/config.js" defer></script><script src="/config.js"></script><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="style.css"><link rel="stylesheet" href="/css/page.css"></head><body onkeydown="exec(event)" style="background-image: url(&#x27;&#x2F;assets&#x2F;bg.jpg&#x27;); "><main>
      <div class="files" id="files" tabindex="0">
<ul>

  <li class="file">
    <span><a href='https://ilikexff.cn/8-kuan-rang-ni-kai-fa-qi-fei-de-intellijidea-cha-jian/'
      tabindex="-2">  8款让你开发起飞的IntellijIDEA插件</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/aop-jie-mi-qie-mian-bian-cheng-de-zong-he-zhi-nan/'
      tabindex="-3">  AOP揭秘：切面编程的综合指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-mei-ju-pian-yi-wu-fan-wei-mei-ju/'
      tabindex="-4">  C++游戏开发基础-枚举篇一：无范围枚举</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-std-optional/'
      tabindex="-5">  C++游戏开发基础-深入解析std::optional</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shen-ru-jie-xi-thiszhi-zhen-de-ying-yong-yu-ji-qiao/'
      tabindex="-6">  C++游戏开发基础-深入解析this指针的应用与技巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-fu-zhi-gou-zao-han-shu/'
      tabindex="-7">  C++游戏开发基础-深入解析复制构造函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-mo-ban-he-can-shu-tui-dao-zhi-nan/'
      tabindex="-8">  C++游戏开发基础-类模版和参数推导指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/dockerbi-zhi-bi-hui/'
      tabindex="-9">  Docker必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/githithub-xiao-ce/'
      tabindex="-10">  GitGitHub小册</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/google-hacking/'
      tabindex="-11">  Google Hacking</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/googleguan-fang-ti-shi-gong-cheng-bai-pi-shu-zhong-wen-yi-ben/'
      tabindex="-12">  Google官方《提示工程白皮书（中文译本）》</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-dai-ma-bu-quan-ti-shi-gong-neng-xiao-shi-de-ji-chong-jie-jue-fang-an-re-geng-ban/'
      tabindex="-13">  IDEA代码补全&amp;提示功能消失的几种解决方案(热更版)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-chen-jin-shi-bian-cheng-ti-yan/'
      tabindex="-14">  IDEA沉浸式编程体验</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-han-shu-shi-bian-cheng/'
      tabindex="-15">  Java函数式编程</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-ji-he-yuan-ma-qian-xi/'
      tabindex="-16">  Java集合源码浅析</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mysql-shi-wu-te-xing-yu-ge-chi-ji-bie-xiang-jie/'
      tabindex="-17">  MySQL_事务特性与隔离级别详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ocao-zuo-fu-shi-xian-mei-ju-de-shu-ru-shu-chu/'
      tabindex="-18">  O操作符,实现枚举的输入输出</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/prdsuan-fa-ting-shuo-ni-xiang-ping-yun-qi-chou-yi-ke-rong-yao-shui-jing/'
      tabindex="-19">  PRD算法：听说你想凭运气抽一颗荣耀水晶?</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/picgo-pei-zhi-ge-chong-tu-chuang/'
      tabindex="-20">  PicGo配置各种图床</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/redis-bi-zhi-bi-hui/'
      tabindex="-21">  Redis必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-zhong-de-move-yu-yi-sui-bi/'
      tabindex="-22">  Rust中的move语义随笔</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ssm-kuang-jia-shi-xian-ji-cheng-duan-xin-yan-zheng-ma-gong-neng/'
      tabindex="-23">  SSM框架实现集成短信验证码功能</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/slf4jyu-logbackshi-yong-zhi-nan-ji-yu-gradle/'
      tabindex="-24">  Slf4j与Logback实用指南(基于Gradle)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/spring-security5-xdao-spring-security6-xde-qian-yi/'
      tabindex="-25">  Spring Security5.x到Spring Security6.x的迁移</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springboot-webkai-fa-jing-jie/'
      tabindex="-26">  SpringBoot Web开发精解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springsecurity/'
      tabindex="-27">  SpringSecurity</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/unity6xia-jia-zhong-guo-qu-tuan-jie-yin-qing-jie-bang-zhe-shi-fen-lie-huan-shi-ben-di-hua-de-kai-shi/'
      tabindex="-28">  Unity6下架中国区，团结引擎接棒：这是分裂，还是本地化的开始？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-cong-0-dao-1-da-zao-quan-yu-yan-zhi-chi-de-mo-neng-bian-ji-qi-yu-fa-pian/'
      tabindex="-29">  Vim从0到1打造全语言支持的万能编辑器-语法篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-tiao-tou-powershell-pian/'
      tabindex="-30">  Vim折腾之 PowerShell篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-di-zhi-chuan-di-xiang-jie/'
      tabindex="-31">  [C++游戏开发基础]:地址传递详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-yin-yong-fan-hui-he-di-zhi-fan-hui/'
      tabindex="-32">  [C++游戏开发基础]:引用返回和地址返回</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-he-const/'
      tabindex="-33">  [C++游戏开发基础]:指针和const</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shu-ju-feng-zhuang-yin-cang-de-hao-chu/'
      tabindex="-34">  [C++游戏开发基础]:数据封装(隐藏)的好处</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-gou-zao-han-shu-qian-xi-8000zi/'
      tabindex="-35">  [C++游戏开发基础]:构造函数浅析(8000字)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-li-jie-kong-zhi-zhen/'
      tabindex="-36">  [C++游戏开发基础]:理解空指针</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-zhong-de-fang-wen-han-shu/'
      tabindex="-37">  [C++游戏开发基础]:类中的访问函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-de-ji-ben-gai-nian-li-jie/'
      tabindex="-38">  [C++游戏开发基础]指针的基本概念理解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/fanatical-wu-yue-feng-kuang-te-hui-wei-ni-de-steam-ku-jia-dian-liao/'
      tabindex="-39">  _Fanatical 五月疯狂特惠：为你的 Steam 库加点料！</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-kai-yuan-mi-ma-gong-ju-xpwd-zhong-wen-ban-bian-geng-ri-zhi/'
      tabindex="-40">  _Rust开源密码工具xpwd中文版变更日志</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/readme/'
      tabindex="-41">  readme</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wblog-bo-ke-xian-shang-bu-shu/'
      tabindex="-42">  wblog博客线上部署</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/shang-gu-shen-qi-vim-su-cheng-bei-wang-lu/'
      tabindex="-43">  上古神器_Vim速成备忘录</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mian-fei-ji-huo-quan-ban-ben-typora-zui-xin-ban-wei-li/'
      tabindex="-44">  免费激活全版本Typora，最新版为例</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-lombokxian-wei-ren-zhi-de-ji-ge-qi-ji-yin-qiao/'
      tabindex="-45">  关于Lombok鲜为人知的几个奇技淫巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-jie-kou-xian-liu-de-yi-ci-jian-dan-shi-jian/'
      tabindex="-46">  关于接口限流的一次简单实践</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/tu-jie-er-jin-zhi/'
      tabindex="-47">  图解二进制</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ru-he-xie-de-yi-shou-you-ya-gui-fan-de-springboot-jie-kou/'
      tabindex="-48">  如何写得一手优雅规范的SpringBoot 接口？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/kai-fa-bi-hui-xi-lie-jwtqian-tan/'
      tabindex="-49">  开发必会系列_JWT浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ji-qiao-jiu-shi-xiao-lu-chatgpt-diao-jiao-zhi-bei/'
      tabindex="-50">  技巧就是效率，ChatGPT调教指北</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-sheng-intellij-kai-fa-xiao-lu-zhe-kuan-dai-ma-tu-ding-cha-jian-codepins-zhi-de-yi-shi/'
      tabindex="-51">  提升 IntelliJ 开发效率？这款代码图钉插件 CodePins 值得一试</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-wen-de-zhi-hui-zhuan-zai/'
      tabindex="-52">  提问的智慧转载</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiao-lu-gong-ju-markdown/'
      tabindex="-53">  效率工具Markdown</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wu-wei-bing-fa-rust-sheng-ming-zhou-qi-qian-tan/'
      tabindex="-54">  无畏并发_Rust 生命周期浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-yu-de-bei-sai-er-qu-xian-gan-shou-si-hua-de-shu-xue-zhi-mei/'
      tabindex="-55">  游戏开发与的贝塞尔曲线_感受丝滑的数学之美</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-bi-bei-gao-xiao-de-aabb-qiu-ti-he-obb-peng-zhuang-jian-ce-suan-fa/'
      tabindex="-56">  游戏开发必备：高效的 AABB、球体和 OBB 碰撞检测算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-suan-fa-ji-chu-a-xun-lu-suan-fa-chi-xu-wei-hu/'
      tabindex="-57">  游戏算法基础-深入解析A*寻路算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/du-li-you-xi-kai-fa-zhe-gong-ju-xiang-2025jing-xuan-tui-jian-yu-shi-yong-zhi-nan/'
      tabindex="-58">  独立游戏开发者工具箱：2025精选推荐与实用指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xu-huan-yin-qing-you-xi-kai-fa-xi-lie-zhuan-ti-guan-fang-bian-ma-biao-zhun-huo-gui-yue/'
      tabindex="-59">  虚幻引擎游戏开发系列专题-官方编码标准或规约</a></span>
  </li><li class="file">
    <span><a class="selected"href='https://ilikexff.cn/xiang-jie-she-ji-mo-shi-dan-li-de-jin-hua-zhi-lu/'
      tabindex="-60">  详解设计模式_单例的进化之路</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xie-e-de-fei-chang-liang-quan-ju-bian-liang/'
      tabindex="-61">  邪恶的非常量全局变量</a></span>
  </li>
</ul>
</div>
      <div class="viewer page" id="viewer" tabindex="0">
        <div class="tab">
<div class="file-manager" onclick='document.getElementById("files").classList.toggle("open"); document.getElementById("content").classList.toggle("close")'> </div>
<ul id="tabs">
</ul>


</div>
        <div class="content" id="content"><h2 id="gai-nian">概念</h2>
<p><strong>单例模式</strong>(<code>Singleton Pattern</code>)是设计模式中一个重要的模式之一，是确保一个类在任何情况下都绝对<strong>只有一个实例。<strong>单例模式一般会屏</strong>蔽构造器</strong>，单例对象提供一个全局访问点，属于<a class="" href="https://baike.baidu.com/item/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/22912595?fr=aladdin">创建型模式</a>。</p>
<p>根据初始化时间的不同，可以将单例模式分为两类：</p>
<ul>
<li>饿汉式单例</li>
<li>懒汉式单例</li>
</ul>
<p>当然，除了上面的两个分类之外，处于对性能、安全等方面的考量，单例模式还演化出了各种实现版本，每一种版本的演进，都是单例的一次**进化与升级，**下面就来看看单例模式的进化之路上都经历了哪些挑战与对抗。</p>
<hr />
<h2 id="e-yi-shi-dan-li">饿汉式单例</h2>
<blockquote>
<p>饿汉式单例，特指在 <strong>类加载的时候就立即初始化并创建单例对象</strong>的一种单例模式写法。由于是在<strong>线程还没有出现之前</strong>就被实例化了，所以这种模式下的单例是线程绝对安全的，不存在访问安全的问题。</p>
</blockquote>
<p>根据具体的实现方式划分，饿汉式单例可以通过 <strong>私有化构造器</strong>以及 <strong>使用静态代码块</strong>的方式具体实现。</p>
<ul>
<li>私有化构造器写法：<code>HungrySingleton.java</code></li>
</ul>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#65737e;">/**
</span><span style="color:#65737e;"> * </span><span style="color:#b48ead;">@author</span><span style="color:#65737e;">: 八尺妖剑
</span><span style="color:#65737e;"> * @date: 2023/1/31 9:32
</span><span style="color:#65737e;"> * @email: ilikexff@gmail.com
</span><span style="color:#65737e;"> * @blog: https://www.waer.ltd
</span><span style="color:#65737e;"> * @Description: 饿汉式单例-构造器私有化写法
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">public class </span><span style="color:#ebcb8b;">HungrySingleton </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">private static final </span><span style="color:#ebcb8b;">HungrySingleton </span><span style="color:#eff1f5;">hungrSingleton  </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">HungrySingleton</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">private </span><span style="color:#8fa1b3;">HungrySingleton</span><span style="color:#eff1f5;">() {};
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">public static </span><span style="color:#ebcb8b;">HungrySingleton </span><span style="color:#8fa1b3;">getInstance</span><span style="color:#eff1f5;">() {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> hungrSingleton;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span></code></pre>
<p>上面的代码中，我们将构造器进行了私有化之后，无法再通过<code>new</code>来创建对象，这种实现下，只能通过提供的<code>getInstance()</code>方法来获得单例对象。</p>
<ul>
<li>静态代码块写法:<code>HungryStaticSingleton.java</code></li>
</ul>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">package </span><span>设计模式.单例模式.饿汉式单例;
</span><span>
</span><span style="color:#65737e;">/**
</span><span style="color:#65737e;"> * </span><span style="color:#b48ead;">@author</span><span style="color:#65737e;">: 八尺妖剑
</span><span style="color:#65737e;"> * @date: 2022/4/23 8:36
</span><span style="color:#65737e;"> * @description: 饿汉式单例静态块写法
</span><span style="color:#65737e;"> * @blog:www.waer.ltd
</span><span style="color:#65737e;"> */
</span><span>@</span><span style="color:#bf616a;">SuppressWarnings</span><span>({&quot;</span><span style="color:#a3be8c;">all</span><span>&quot;})
</span><span style="color:#b48ead;">public class </span><span style="color:#ebcb8b;">HungryStaticSingleton </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">private static final </span><span style="color:#ebcb8b;">HungryStaticSingleton </span><span style="color:#eff1f5;">hungryStaticSingleton;
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">static </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">        hungryStaticSingleton </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">HungryStaticSingleton</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">private </span><span style="color:#8fa1b3;">HungryStaticSingleton</span><span style="color:#eff1f5;">(){
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">public static </span><span style="color:#ebcb8b;">HungryStaticSingleton </span><span style="color:#8fa1b3;">getInstance</span><span style="color:#eff1f5;">(){
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> hungryStaticSingleton;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span></code></pre>
<ul>
<li>测试类</li>
</ul>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">package </span><span>ltd.waer.javabaseforio.PatternDesign;
</span><span>
</span><span>@</span><span style="color:#bf616a;">SuppressWarnings</span><span>(&quot;</span><span style="color:#a3be8c;">all</span><span>&quot;)
</span><span style="color:#65737e;">/**
</span><span style="color:#65737e;"> * </span><span style="color:#b48ead;">@author</span><span style="color:#65737e;">: 八尺妖剑
</span><span style="color:#65737e;"> * @date: 2023/1/31 9:42
</span><span style="color:#65737e;"> * @email: ilikexff@gmail.com
</span><span style="color:#65737e;"> * @blog: https://www.waer.ltd
</span><span style="color:#65737e;"> * @Description: 饿汉式单例测试类
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">public class </span><span style="color:#ebcb8b;">HungrySingletonTest </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">public static void </span><span style="color:#8fa1b3;">main</span><span style="color:#eff1f5;">(</span><span style="color:#ebcb8b;">String</span><span style="color:#b48ead;">[] </span><span style="color:#bf616a;">args</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">//私有构造器写法
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">HungrySingleton</span><span style="color:#eff1f5;"> hungrySingleton1 </span><span>= </span><span style="color:#ebcb8b;">HungrySingleton</span><span style="color:#eff1f5;">.</span><span style="color:#bf616a;">getInstance</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">HungrySingleton</span><span style="color:#eff1f5;"> hungrySingleton2 </span><span>= </span><span style="color:#ebcb8b;">HungrySingleton</span><span style="color:#eff1f5;">.</span><span style="color:#bf616a;">getInstance</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(hungrySingleton1 </span><span>==</span><span style="color:#eff1f5;"> hungrySingleton2);
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">//静态块初始化写法
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">HungryStaticSingleton</span><span style="color:#eff1f5;"> singleton3 </span><span>= </span><span style="color:#ebcb8b;">HungryStaticSingleton</span><span style="color:#eff1f5;">.</span><span style="color:#bf616a;">getInstance</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">HungryStaticSingleton</span><span style="color:#eff1f5;"> singleton4 </span><span>= </span><span style="color:#ebcb8b;">HungryStaticSingleton</span><span style="color:#eff1f5;">.</span><span style="color:#bf616a;">getInstance</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(singleton3</span><span>==</span><span style="color:#eff1f5;">singleton4);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span></code></pre>
<blockquote>
<p>测试结果:true。说明两种方式实现的单例都是有效的，因为不论我们调用多少次 <code>getInstance </code>方法最后<strong>返回的就是同一个对象</strong>。</p>
</blockquote>
<p><strong>优缺点：</strong></p>
<p>创建的对象没有添加任何锁，执行效率高。</p>
<p>由于是在类加载的时候就初始化了，所以不管我们使用与否，它都将占有一定的内存空间，这种情况下，通过项目中存在了大量的单例，那么所占用的内存量就<strong>很可观了</strong>，着实浪费。</p>
<hr />
<h2 id="lan-yi-shi-dan-li">懒汉式单例</h2>
<blockquote>
<p>那么针对上述<strong>饿汉式单例</strong>存在的空间占用问题，有没有合适的替换或者解决方案呢？那么有请<strong>懒汉</strong>出场。</p>
<p>见名知意， <strong>懒汉式单例</strong>与<strong>饿汉式单例</strong>的理念刚好相反。它不会在 <strong>类加载的时候就初始化</strong>，而是等到用到了才会初始化，就这点来说，确实很 <strong>懒汉</strong>，不饿不吃饭(<del>似乎有点道理??我不饿的时候也不想吃饭</del>)。</p>
</blockquote>
<p>到这里，单例模式就开始自己的进化之路了，下面列一下<strong>进化路线</strong>。</p>
<p>进化主线：</p>
<blockquote>
<ul>
<li>普通非线程安全单例
<ul>
<li>sync线程安全单例
<ul>
<li>双重检查锁单例
<ul>
<li>内部类单例
<ul>
<li>枚举式单例</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>打野副本:</p>
<blockquote>
<ul>
<li>内部类单例
<ul>
<li>注册式单例</li>
<li>单线程安全单例
<ul>
<li>枚举式单例</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="1-pu-tong-fei-xian-cheng-an-quan-dan-li">1. <strong>普通非线程安全单例</strong></h3>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">package </span><span>ltd.waer.javabaseforio.PatternDesign.LazySingleton;
</span><span>@</span><span style="color:#bf616a;">SuppressWarnings</span><span>(&quot;</span><span style="color:#a3be8c;">all</span><span>&quot;)
</span><span style="color:#65737e;">/**
</span><span style="color:#65737e;"> * </span><span style="color:#b48ead;">@author</span><span style="color:#65737e;">: 八尺妖剑
</span><span style="color:#65737e;"> * @date: 2023/1/31 9:47
</span><span style="color:#65737e;"> * @email: ilikexff@gmail.com
</span><span style="color:#65737e;"> * @blog: https://www.waer.ltd
</span><span style="color:#65737e;"> * @Description: 版本一:非线程安全
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">public class </span><span style="color:#ebcb8b;">LazySingleton </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">   </span><span style="color:#b48ead;">private static </span><span style="color:#ebcb8b;">LazySingleton </span><span style="color:#eff1f5;">lazySingleton </span><span>= </span><span style="color:#d08770;">null</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">   </span><span style="color:#b48ead;">private </span><span style="color:#8fa1b3;">LazySingleton</span><span style="color:#eff1f5;">() {
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">   };
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">   </span><span style="color:#b48ead;">public static </span><span style="color:#ebcb8b;">LazySingleton </span><span style="color:#8fa1b3;">getInstance</span><span style="color:#eff1f5;">() {
</span><span style="color:#eff1f5;">       </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(</span><span style="color:#d08770;">null </span><span>==</span><span style="color:#eff1f5;"> lazySingleton) {
</span><span style="color:#eff1f5;">           lazySingleton </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">LazySingleton</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">       }
</span><span style="color:#eff1f5;">       </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> lazySingleton;
</span><span style="color:#eff1f5;">   }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">public static void </span><span style="color:#8fa1b3;">main</span><span style="color:#eff1f5;">(</span><span style="color:#ebcb8b;">String</span><span style="color:#b48ead;">[] </span><span style="color:#bf616a;">args</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">LazySingleton</span><span style="color:#eff1f5;"> instance1 </span><span>= </span><span style="color:#ebcb8b;">LazySingleton</span><span style="color:#eff1f5;">.</span><span style="color:#bf616a;">getInstance</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">LazySingleton</span><span style="color:#eff1f5;"> instance2 </span><span>= </span><span style="color:#ebcb8b;">LazySingleton</span><span style="color:#eff1f5;">.</span><span style="color:#bf616a;">getInstance</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(instance1 </span><span>==</span><span style="color:#eff1f5;"> instance2);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span></code></pre>
<p>上面是单例的最简单写法，也是最初的一种版本，在开始时将实例赋值为<code>null</code>，并没有进行初始化，而是在调用<code>getInstance</code>方法的时候才会初始化，虽然实现简单，但也存在线程安全问题，<strong>多线程环境下有一定几率会返回多个单例对象</strong>，这显然违背了单例的原则，进一步的解决办法就是下面这种实现。使用<code>synchronizeed</code>关键字保证线程安全。</p>
<h3 id="2-syncxian-cheng-an-quan-dan-li">2. <code>sync</code><strong>线程安全单例</strong></h3>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">package </span><span>ltd.waer.javabaseforio.PatternDesign.LazySingleton;
</span><span>@</span><span style="color:#bf616a;">SuppressWarnings</span><span>(&quot;</span><span style="color:#a3be8c;">all</span><span>&quot;)
</span><span style="color:#65737e;">/**
</span><span style="color:#65737e;"> * </span><span style="color:#b48ead;">@author</span><span style="color:#65737e;">: 八尺妖剑
</span><span style="color:#65737e;"> * @date: 2023/1/31 9:51
</span><span style="color:#65737e;"> * @email: ilikexff@gmail.com
</span><span style="color:#65737e;"> * @blog: https://www.waer.ltd
</span><span style="color:#65737e;"> * @Description: 线程安全的懒汉式单例-synchronized
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">public class </span><span style="color:#ebcb8b;">LazySyncSingleton </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">private static </span><span style="color:#ebcb8b;">LazySyncSingleton </span><span style="color:#eff1f5;">lazySyncSingleton </span><span>= </span><span style="color:#d08770;">null</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">private </span><span style="color:#8fa1b3;">LazySyncSingleton</span><span style="color:#eff1f5;">() {};
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">public synchronized </span><span style="color:#ebcb8b;">LazySyncSingleton </span><span style="color:#8fa1b3;">getInstance </span><span style="color:#eff1f5;">() {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(</span><span style="color:#d08770;">null </span><span>==</span><span style="color:#eff1f5;"> lazySyncSingleton) {
</span><span style="color:#eff1f5;">            lazySyncSingleton </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">LazySyncSingleton</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> lazySyncSingleton;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span></code></pre>
<p>上面的实现也非常简单，在前面一种写法的基础山加了一个<code>synchronized</code>关键字即可，这样确实解决了线程安全的问题，但也引出了一个新的问题，<strong>假如单例对象的创建非常复杂耗时的情况下，一旦并发量上来了，CPU压力上升，那么可能会导致大批量线程出现阻塞的情况，从而导致程序的允许性能大幅下降</strong>，解决方法是**双重检查锁(double-checked locking)**单例写法，如下：</p>
<h3 id="3-shuang-zhong-jian-cha-suo-dan-li">3. <strong>双重检查锁单例</strong></h3>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">package </span><span>ltd.waer.javabaseforio.PatternDesign.LazySingleton;
</span><span>@</span><span style="color:#bf616a;">SuppressWarnings</span><span>(&quot;</span><span style="color:#a3be8c;">all</span><span>&quot;)
</span><span style="color:#65737e;">/**
</span><span style="color:#65737e;"> * </span><span style="color:#b48ead;">@author</span><span style="color:#65737e;">: 八尺妖剑
</span><span style="color:#65737e;"> * @date: 2023/1/31 9:59
</span><span style="color:#65737e;"> * @email: ilikexff@gmail.com
</span><span style="color:#65737e;"> * @blog: https://www.waer.ltd
</span><span style="color:#65737e;"> * @Description: 解决写法2的问题，双重检查锁写法
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">public class </span><span style="color:#ebcb8b;">LazyDoubleCheckSingleton </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">private volatile static </span><span style="color:#ebcb8b;">LazyDoubleCheckSingleton </span><span style="color:#eff1f5;">lazyDoubleCheckSingleton </span><span>= </span><span style="color:#d08770;">null</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">private </span><span style="color:#8fa1b3;">LazyDoubleCheckSingleton </span><span style="color:#eff1f5;">() {
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    };
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">public static </span><span style="color:#ebcb8b;">LazyDoubleCheckSingleton </span><span style="color:#8fa1b3;">getInstance</span><span style="color:#eff1f5;">() {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">( </span><span style="color:#d08770;">null </span><span>==</span><span style="color:#eff1f5;"> lazyDoubleCheckSingleton) {
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">synchronized </span><span style="color:#eff1f5;">(</span><span style="color:#ebcb8b;">LazyDoubleCheckSingleton</span><span style="color:#eff1f5;">.</span><span style="color:#bf616a;">class</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">                </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(</span><span style="color:#d08770;">null </span><span>==</span><span style="color:#eff1f5;"> lazyDoubleCheckSingleton) {
</span><span style="color:#eff1f5;">                    lazyDoubleCheckSingleton </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">LazyDoubleCheckSingleton</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">                }
</span><span style="color:#eff1f5;">            }
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> lazyDoubleCheckSingleton;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span></code></pre>
<p>这种写法中，较于上面的写法做了两个地方的改变。</p>
<ul>
<li>
<p>在<code>lazyDoubleCheckSingleton</code>属性加上了<code>volatile</code>关键字，原因就是为了解决<strong>多线程下可见性问题</strong>，因为我们的<code>getInstance</code>方法在判断<code>lazyDoubleCheckSingleton</code>是否为<code>null</code>时并没有加锁，所以假如线程<code>1</code>初始化了对象，另外线程<code>2</code>是无法感知的，而加上了<code>volatile</code>之后便可以解决这个问题。</p>
</li>
<li>
<p>把<code>synchronized</code><strong>关键字移到了方法内部，尽可能缩小加锁的代码块，提升效率</strong>。</p>
</li>
</ul>
<p>迭代了这几个版本，到这里是否就已经完美了呢？其实不是，这种写法依旧存在问题，那就是<strong>指令重排</strong>问题。</p>
<p>上面<code>new</code>对象只有一行代码，然而这行代码在<code>JVM</code>底层却分成了3步：</p>
<ol>
<li>分配内存来创建对象，即<code>new</code>操作。</li>
<li>创建一个对象<code>lazyDoubleCheckSingleton</code>此时<code>lazyDoubleCheckSingleton==nul</code>。</li>
<li>将<code>new</code>出来的对象赋给<code>lazyDoubleCheckSingleton</code>。</li>
</ol>
<p>但实际运行的时候为了提升效率，这<code>3</code>步并<strong>不会按照实际顺序</strong>来运行。</p>
<blockquote>
<p>假如线程<code>t1</code>进入同步代码块正在创建对象，而此时执行了后面<code>2</code>步，也即是此时<code>lazyDoubleCheckSingleton</code>依已经不为<code>null</code>了，但是对象却没有创建结束，这时候又来了一个线程<code>t2</code>进入<code>getInstance</code>方法，这时候<code>if</code>条件不再成立，线程<code>t2</code>会直接返回一个<strong>残缺不全的对象</strong>，自然会出现报错。</p>
</blockquote>
<p>为了解决这个问题，下面引出了第四个单例版本，即</p>
<h3 id="4-nei-bu-lei-dan-li">4. <strong>内部类单例</strong></h3>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">package </span><span>ltd.waer.javabaseforio.PatternDesign.LazySingleton;
</span><span style="color:#b48ead;">import </span><span>java.io.</span><span style="color:#ebcb8b;">Serializable</span><span>;
</span><span style="color:#b48ead;">import </span><span>java.lang.reflect.</span><span style="color:#ebcb8b;">Constructor</span><span>;
</span><span>@</span><span style="color:#bf616a;">SuppressWarnings</span><span>(&quot;</span><span style="color:#a3be8c;">all</span><span>&quot;)
</span><span style="color:#65737e;">/**
</span><span style="color:#65737e;"> * </span><span style="color:#b48ead;">@author</span><span style="color:#65737e;">: 八尺妖剑
</span><span style="color:#65737e;"> * @date: 2023/1/31 10:48
</span><span style="color:#65737e;"> * @email: ilikexff@gmail.com
</span><span style="color:#65737e;"> * @blog: https://www.waer.ltd
</span><span style="color:#65737e;"> * @Description: 内部类懒汉式单例-解决指令重排问题
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">public class </span><span style="color:#ebcb8b;">LazyInnerClassSingleton  </span><span style="color:#b48ead;">implements </span><span style="color:#a3be8c;">Serializable </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">private </span><span style="color:#8fa1b3;">LazyInnerClassSingleton </span><span style="color:#eff1f5;">() {
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    };
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">public static final </span><span style="color:#ebcb8b;">LazyInnerClassSingleton </span><span style="color:#8fa1b3;">getInstance</span><span style="color:#eff1f5;">() {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return </span><span style="color:#ebcb8b;">InnerLazy</span><span style="color:#eff1f5;">.</span><span style="color:#d08770;">LAZY</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">private static class </span><span style="color:#ebcb8b;">InnerLazy </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">private static final </span><span style="color:#ebcb8b;">LazyInnerClassSingleton </span><span style="color:#eff1f5;">LAZY </span><span>=</span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">LazyInnerClassSingleton</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span></code></pre>
<p>这种写法巧妙的利用了<strong>内部类会等到外部调用时才会被初始化的特性</strong>，用饿汉式单例的思想实现了懒汉式单例。</p>
<p>这种写法看起来已经是高效完美，但其实存在安全隐患，比如可以通过<strong>反射</strong>的方式破坏这种写法，测试代码如下：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">public static</span><span> void </span><span style="color:#bf616a;">main</span><span>(</span><span style="color:#ebcb8b;">String</span><span style="color:#b48ead;">[]</span><span> args) throws </span><span style="color:#ebcb8b;">Exception </span><span>{
</span><span>    </span><span style="color:#ebcb8b;">Class</span><span>&lt;?&gt; clazz = </span><span style="color:#ebcb8b;">LazyInnerClassSingleton</span><span>.</span><span style="color:#bf616a;">class</span><span>;
</span><span>    </span><span style="color:#ebcb8b;">Constructor</span><span> constructor = clazz.</span><span style="color:#bf616a;">getDeclaredConstructor</span><span>();
</span><span>    constructor.</span><span style="color:#bf616a;">setAccessible</span><span>(</span><span style="color:#d08770;">true</span><span>);
</span><span>    </span><span style="color:#ebcb8b;">Object</span><span> o1 = constructor.</span><span style="color:#bf616a;">newInstance</span><span>();
</span><span>    </span><span style="color:#ebcb8b;">Object</span><span> o2 = </span><span style="color:#ebcb8b;">LazyInnerClassSingleton</span><span>.</span><span style="color:#bf616a;">getInstance</span><span>();
</span><span>    </span><span style="color:#ebcb8b;">System</span><span>.out.</span><span style="color:#bf616a;">println</span><span>(o1 == o2); </span><span style="color:#65737e;">//false
</span><span>}
</span></code></pre>
<blockquote>
<p>可以看到，虽然构造方法被私有化了，但是我们仍然可以<strong>利用反射来破坏单例</strong>。为了防止反射破坏单例，我们将上面的写法再改造一下。</p>
</blockquote>
<h3 id="5-gai-jin-ban-de-nei-bu-lei-dan-li">5. 改进版的内部类单例</h3>
<p>``java
public class LazyInnerClassSingleton {</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>private LazyInnerClassSingleton(){
</span><span>    //防止反射破坏单例
</span><span>     if(null != InnerLazy.LAZY){
</span><span>       throw new RuntimeException(&quot;不允许通过反射类构造单例对象&quot;);
</span><span>     }
</span><span>}
</span><span>
</span><span>public static final LazyInnerClassSingleton getInstance(){
</span><span>    return InnerLazy.LAZY;
</span><span>}
</span><span>
</span><span>private static class InnerLazy{
</span><span>    private static final LazyInnerClassSingleton LAZY = new LazyInnerClassSingleton();
</span><span>}
</span></code></pre>
<p>}</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>
</span><span>尽管如此，但假如我们的单例对象实现了 `Serializable `接口，那么内部类的写法就还是能**通过序列化来破坏**。
</span><span>
</span><span>### 6. 实现了`Serializable`接口的内部类单例
</span><span>
</span><span>``java
</span><span>package singleton.lazy;
</span><span>
</span><span>import java.io.Serializable;
</span><span>
</span><span>public class LazyInnerClassSingleton implements Serializable {
</span><span>
</span><span>    private LazyInnerClassSingleton(){
</span><span>        //防止反射破坏单例
</span><span>         if(null != InnerLazy.LAZY){
</span><span>           throw new RuntimeException(&quot;不允许通过反射类构造单例对象&quot;);
</span><span>         }
</span><span>    }
</span><span>
</span><span>    public static final LazyInnerClassSingleton getInstance(){
</span><span>        return InnerLazy.LAZY;
</span><span>    }
</span><span>
</span><span>    private static class InnerLazy {
</span><span>        private static final LazyInnerClassSingleton LAZY = new LazyInnerClassSingleton();
</span><span>    }
</span><span>}
</span></code></pre>
<p>由于实现了序列化的接口，所以内部类的写法依然可以通过序列化来进行破坏，比如使用下面这段测试代码。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">package </span><span>singleton.lazy;
</span><span style="color:#b48ead;">import </span><span>java.io.</span><span style="color:#ebcb8b;">FileInputStream</span><span>;
</span><span style="color:#b48ead;">import </span><span>java.io.</span><span style="color:#ebcb8b;">FileOutputStream</span><span>;
</span><span style="color:#b48ead;">import </span><span>java.io.</span><span style="color:#ebcb8b;">ObjectInputStream</span><span>;
</span><span style="color:#b48ead;">import </span><span>java.io.</span><span style="color:#ebcb8b;">ObjectOutputStream</span><span>;
</span><span>
</span><span style="color:#b48ead;">public class </span><span style="color:#ebcb8b;">TestLazyInnerClassSingleton2 </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">public static void </span><span style="color:#8fa1b3;">main</span><span style="color:#eff1f5;">(</span><span style="color:#ebcb8b;">String</span><span style="color:#b48ead;">[] </span><span style="color:#bf616a;">args</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">//序列化攻击内部类式单例
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">LazyInnerClassSingleton</span><span style="color:#eff1f5;"> s1 </span><span>= </span><span style="color:#d08770;">null</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">LazyInnerClassSingleton</span><span style="color:#eff1f5;"> s2 </span><span>= </span><span style="color:#ebcb8b;">LazyInnerClassSingleton</span><span style="color:#eff1f5;">.</span><span style="color:#bf616a;">getInstance</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">FileOutputStream</span><span style="color:#eff1f5;"> fos </span><span>= </span><span style="color:#d08770;">null</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">try </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">            fos </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">FileOutputStream</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">LazyInnerClassSingleton.text</span><span>&quot;</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">            </span><span style="color:#ebcb8b;">ObjectOutputStream</span><span style="color:#eff1f5;"> oos </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ObjectOutputStream</span><span style="color:#eff1f5;">(fos);
</span><span style="color:#eff1f5;">            oos.</span><span style="color:#bf616a;">writeObject</span><span style="color:#eff1f5;">(s2);
</span><span style="color:#eff1f5;">            oos.</span><span style="color:#bf616a;">flush</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">            oos.</span><span style="color:#bf616a;">close</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">            </span><span style="color:#ebcb8b;">FileInputStream</span><span style="color:#eff1f5;"> fis </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">FileInputStream</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">LazyInnerClassSingleton.text</span><span>&quot;</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">            </span><span style="color:#ebcb8b;">ObjectInputStream</span><span style="color:#eff1f5;"> ois </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ObjectInputStream</span><span style="color:#eff1f5;">(fis);
</span><span style="color:#eff1f5;">            s1 </span><span>= </span><span style="color:#eff1f5;">(</span><span style="color:#ebcb8b;">LazyInnerClassSingleton</span><span style="color:#eff1f5;">)ois.</span><span style="color:#bf616a;">readObject</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">            ois.</span><span style="color:#bf616a;">close</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">            </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(s1 </span><span>==</span><span style="color:#eff1f5;"> s2);</span><span style="color:#65737e;">//输出：false
</span><span style="color:#eff1f5;">        }</span><span style="color:#b48ead;">catch </span><span style="color:#eff1f5;">(</span><span style="color:#ebcb8b;">Exception </span><span style="color:#bf616a;">e</span><span style="color:#eff1f5;">){
</span><span style="color:#eff1f5;">            e.</span><span style="color:#bf616a;">printStackTrace</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span></code></pre>
<blockquote>
<p>上面示例中 <code>s1</code> 是通过我们自己提供的全局入口创建的对象，而 <code>s2</code> 是通过序列化的方式创建的对象，不相等说明这是两个对象，也就是说序列化破坏了单例模式。</p>
</blockquote>
<p>解决办法就是在 <code>LazyInnerClassSingleton</code> 类中加一个 <code>readResolve</code> 方法，防止序列化破坏单例。</p>
<h3 id="7-zai-gai-jin-ban-de-nei-bu-lei-dan-li">7. 再改进版的内部类单例</h3>
<p>``java
package singleton.lazy;</p>
<p>import java.io.Serializable;</p>
<p>public class LazyInnerClassSingleton implements Serializable {</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>private LazyInnerClassSingleton(){
</span><span>    //防止反射破坏单例
</span><span>     if(null != InnerLazy.LAZY){
</span><span>       throw new RuntimeException(&quot;不允许通过反射类构造单例对象&quot;);
</span><span>     }
</span><span>}
</span><span>
</span><span>public static final LazyInnerClassSingleton getInstance(){
</span><span>    return InnerLazy.LAZY;
</span><span>}
</span><span>
</span><span>private static class InnerLazy {
</span><span>    private static final LazyInnerClassSingleton LAZY = new LazyInnerClassSingleton();
</span><span>}
</span><span>
</span><span>//防止通过序列化破坏单例
</span><span>private Object readResolve(){
</span><span>    return InnerLazy.LAZY;
</span><span>}
</span></code></pre>
<p>}</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>
</span><span>这次返回了 `true`，也就是序列化没有破坏单例了。原因是因为 `JDK `源码中在序列化的时候会检验一个类中是否存在一个 `readResolve` 方法，如果存在，则会放弃通过序列化产生的对象，而返回原本的对象。
</span><span>
</span><span>这种方式虽然保证了单例，但是在校验是否存在 `readResolve` 方法前还是会产生一个对象，只不过这个对象会在发现类中存在 `readResolve` 方法后丢掉，然后返回原本的单例对象。这种写法只是保证了结果的唯一，但是过程中依然会**被实例化多次**，假如创建对象的频率增大，**就意味着内存分配的开销也随之增大。**
</span><span>
</span><span>**上面介绍了这么多种写法，看起来每种写法似乎都存在问题，难道就没有一种最优雅、安全、高效的方法吗？这就是我们最后要介绍的枚举式单例，不过在介绍枚举式单例之前，我们先刷一下副本，看看其它写法。**
</span><span>
</span><span>### 8. 注册式单例
</span><span>
</span><span>将每一个实例都保存起来，然后在需要使用的时候直接通过唯一的标识获取实例，这便是注册式单例。
</span><span>
</span><span>```java
</span><span>import java.util.Map;
</span><span>import java.util.concurrent.ConcurrentHashMap;
</span><span>
</span><span>public class ContainerSingleton {
</span><span>    private ContainerSingleton(){
</span><span>
</span><span>    }
</span><span>
</span><span>    private static Map&lt;String,Object&gt; ioc = new ConcurrentHashMap&lt;&gt;();
</span><span>
</span><span>    public static Object getBean(String className){
</span><span>        synchronized (ioc){
</span><span>            //如果容器中不存在当前对象
</span><span>            if(!ioc.containsKey(className)){
</span><span>                Object obj = null;
</span><span>                try {
</span><span>                    obj = Class.forName(className).newInstance();
</span><span>                    //将className作为唯一标识存入容器
</span><span>                    ioc.put(className,obj);
</span><span>                }catch (Exception e) {
</span><span>                    e.printStackTrace();
</span><span>                }
</span><span>                return obj;
</span><span>            }
</span><span>        }
</span><span>        //如果容器中已经存在了单例对象，则直接返回
</span><span>        return ioc.get(className);
</span><span>    }
</span><span>}
</span></code></pre>
<p>新建一个空对象 <code>MyObject.java</code>，用来测试单例。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">package </span><span>singleton.register;
</span><span>
</span><span style="color:#b48ead;">public class </span><span style="color:#ebcb8b;">MyObject </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">}
</span></code></pre>
<p>新建一个测试类 <code>TestContainerSingleton.java</code>。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">package </span><span>singleton.register;
</span><span>
</span><span style="color:#b48ead;">public class </span><span style="color:#ebcb8b;">TestContainerSingleton </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">public static void </span><span style="color:#8fa1b3;">main</span><span style="color:#eff1f5;">(</span><span style="color:#ebcb8b;">String</span><span style="color:#b48ead;">[] </span><span style="color:#bf616a;">args</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">MyObject</span><span style="color:#eff1f5;"> myObject1 </span><span>= </span><span style="color:#eff1f5;">(</span><span style="color:#ebcb8b;">MyObject</span><span style="color:#eff1f5;">) </span><span style="color:#ebcb8b;">ContainerSingleton</span><span style="color:#eff1f5;">.</span><span style="color:#bf616a;">getBean</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">singleton.register.MyObject</span><span>&quot;</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">MyObject</span><span style="color:#eff1f5;"> myObject2 </span><span>= </span><span style="color:#eff1f5;">(</span><span style="color:#ebcb8b;">MyObject</span><span style="color:#eff1f5;">) </span><span style="color:#ebcb8b;">ContainerSingleton</span><span style="color:#eff1f5;">.</span><span style="color:#bf616a;">getBean</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">singleton.register.MyObject</span><span>&quot;</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(myObject1 </span><span>==</span><span style="color:#eff1f5;"> myObject2);</span><span style="color:#65737e;">//输出：true
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span></code></pre>
<p>上面返回 <code>true</code> 是因为我们加了 <code>synchronized</code> 关键字，实际上 <code>Spring </code>框架中用的就是容器式单例，默认是线程不安全的。</p>
<h3 id="9-dan-xian-cheng-an-quan-dan-li">9. 单线程安全单例</h3>
<p>基于<code>ThreadLocal</code>实现，该单例不能保证其创建的对象是全局唯一，但是能保证在单个线程中是唯一的，在单线程环境下线程天生安全。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">import </span><span>java.util.concurrent.</span><span style="color:#ebcb8b;">ThreadFactory</span><span>;
</span><span style="color:#b48ead;">public class </span><span style="color:#ebcb8b;">ThreadLocalSingleton </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">private </span><span style="color:#8fa1b3;">ThreadLocalSingleton</span><span style="color:#eff1f5;">(){
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">private static final </span><span style="color:#ebcb8b;">ThreadLocal</span><span style="color:#eff1f5;">&lt;</span><span style="color:#ebcb8b;">ThreadLocalSingleton</span><span style="color:#eff1f5;">&gt; singleton </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ThreadLocal</span><span style="color:#eff1f5;">&lt;</span><span style="color:#ebcb8b;">ThreadLocalSingleton</span><span style="color:#eff1f5;">&gt;(){
</span><span style="color:#eff1f5;">        @</span><span style="color:#bf616a;">Override
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">protected </span><span style="color:#ebcb8b;">ThreadLocalSingleton </span><span style="color:#8fa1b3;">initialValue</span><span style="color:#eff1f5;">() {
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">return new </span><span style="color:#ebcb8b;">ThreadLocalSingleton</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">    };
</span><span style="color:#eff1f5;">    
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">public static </span><span style="color:#ebcb8b;">ThreadLocalSingleton </span><span style="color:#8fa1b3;">getInstance</span><span style="color:#eff1f5;">(){
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> singleton.</span><span style="color:#bf616a;">get</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span></code></pre>
<p>测试类:</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">public class </span><span style="color:#ebcb8b;">TestThreadLocalSingleton </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">public static void </span><span style="color:#8fa1b3;">main</span><span style="color:#eff1f5;">(</span><span style="color:#ebcb8b;">String</span><span style="color:#b48ead;">[] </span><span style="color:#bf616a;">args</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(</span><span style="color:#ebcb8b;">ThreadLocalSingleton</span><span style="color:#eff1f5;">.</span><span style="color:#bf616a;">getInstance</span><span style="color:#eff1f5;">());</span><span style="color:#65737e;">//主线程输出
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(</span><span style="color:#ebcb8b;">ThreadLocalSingleton</span><span style="color:#eff1f5;">.</span><span style="color:#bf616a;">getInstance</span><span style="color:#eff1f5;">());</span><span style="color:#65737e;">//主线程输出
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">Thread</span><span style="color:#eff1f5;"> t1 </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">Thread</span><span style="color:#eff1f5;">(()</span><span style="color:#b48ead;">-&gt;</span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">           </span><span style="color:#ebcb8b;">ThreadLocalSingleton</span><span style="color:#eff1f5;"> singleton </span><span>= </span><span style="color:#ebcb8b;">ThreadLocalSingleton</span><span style="color:#eff1f5;">.</span><span style="color:#bf616a;">getInstance</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">            </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(</span><span style="color:#ebcb8b;">Thread</span><span style="color:#eff1f5;">.</span><span style="color:#bf616a;">currentThread</span><span style="color:#eff1f5;">().</span><span style="color:#bf616a;">getName</span><span style="color:#eff1f5;">() </span><span>+ &quot;</span><span style="color:#a3be8c;">:</span><span>&quot; +</span><span style="color:#eff1f5;"> singleton);
</span><span style="color:#eff1f5;">        });
</span><span style="color:#eff1f5;">        t1.</span><span style="color:#bf616a;">start</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span></code></pre>
<p><img src="https://s2.loli.net/2022/04/23/MZraX8gnyDBl5cS.png" alt="image-20220423105451698" loading="lazy" decoding="async" /></p>
<p>从上图可以看到，<code>main</code> 线程输出的和 <code>t1</code> 线程输出的并不是同一个对象，故而 <code>ThreadLocal</code> 式示例仅对单线程是安全的。</p>
<h3 id="">10. 枚举式单例</h3>
<p>枚举式单例充分利用了枚举类的特性来创建单例对象，<strong>目前来说这是最优雅的一种写法。</strong></p>
<p>照例我们新建一个空的对象 <code>MyObject.java</code> 来测试单例。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">package </span><span>singleton.meiju;
</span><span>
</span><span style="color:#b48ead;">public class </span><span style="color:#ebcb8b;">MyObject </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">}
</span></code></pre>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">public class </span><span style="color:#ebcb8b;">EnumSingleton </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#ebcb8b;">INSTANCE</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">private </span><span style="color:#ebcb8b;">MyObject </span><span style="color:#eff1f5;">myObject;
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">EnumSingleton</span><span style="color:#eff1f5;">(){
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">this</span><span style="color:#eff1f5;">.myObject </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">MyObject</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">public </span><span style="color:#ebcb8b;">Object </span><span style="color:#8fa1b3;">getData</span><span style="color:#eff1f5;">() {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> myObject;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">public static </span><span style="color:#ebcb8b;">EnumSingleton </span><span style="color:#8fa1b3;">getInstance</span><span style="color:#eff1f5;">(){
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">INSTANCE</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span></code></pre>
<ul>
<li>新建测试类 <code>TestEnumSingleton.java</code> 进行测试。</li>
</ul>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">package </span><span>singleton.meiju;
</span><span>
</span><span style="color:#b48ead;">public class </span><span style="color:#ebcb8b;">TestEnumSingleton </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">public static void </span><span style="color:#8fa1b3;">main</span><span style="color:#eff1f5;">(</span><span style="color:#ebcb8b;">String</span><span style="color:#b48ead;">[] </span><span style="color:#bf616a;">args</span><span style="color:#eff1f5;">) </span><span style="color:#b48ead;">throws </span><span style="color:#ebcb8b;">Exception</span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">EnumSingleton</span><span style="color:#eff1f5;"> enumSingleton </span><span>= </span><span style="color:#ebcb8b;">EnumSingleton</span><span style="color:#eff1f5;">.</span><span style="color:#bf616a;">getInstance</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(enumSingleton.</span><span style="color:#bf616a;">getData</span><span style="color:#eff1f5;">() </span><span>==</span><span style="color:#eff1f5;"> enumSingleton.</span><span style="color:#bf616a;">getData</span><span style="color:#eff1f5;">());</span><span style="color:#65737e;">//输出：true
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span></code></pre>
<p>输出结果为 <code>true</code>，枚举式单例写法能有效的防止通过反射以及序列化手段的破坏，确实为目前最佳的单例实践之选。</p>
<hr />
<h2 id="-1">小结</h2>
<p>尽管实现单例模式的具体思想和方法多种多样，也各有千秋和不足，但在实际的使用中，并不是最优的就是最合适的，在使用单例模式时，应该结合具体的项目需求以及场景来选择合适的实现方式。比如小项目追求线程安全又拥有足够空间的情况下使用<strong>饿汉式单例</strong>又何尝不可？</p>
<hr />
<p>致谢&amp;引用:</p>
<ul>
<li><a class="" href="https://dzone.com/articles/java-singletons-using-enum">Java Singletons Using Enum</a></li>
<li><a class="" href="https://www.geeksforgeeks.org/advantages-and-disadvantages-of-using-enum-as-singleton-in-java/">Advantages and Disadvantages of using Enum as Singleton in Java</a></li>
<li><a class="" href="https://baike.baidu.com/item/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/22912595?fr=aladdin">百度百科</a></li>
</ul>

        </div>
      </div>
      <div class="prompt" id="terminal"><input
    type="text"
    id="setter"
    onkeydown="writeit(this, event);moveIt(this.value.length, event)"
    onchange="writeit(this, event)"
    onkeyup="writeit(this, event)"
    onkeypress="writeit(this, event);"
    >
<label for="setter" id="writer"> </label><b class="cursor" id="cursor"></b></div>
      <footer class="footer">
        <div class="footer-content">
          <p class="icp-info">
            <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer">黔ICP备2021010295号</a>
          </p>
        </div>
      </footer>
    </main>
  </body>

</html>
