<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>慕予博客</title>
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"
    integrity="sha256-WCzAhd2P6gRJF9Hv3oOOd+hFJi/QJbv+Azn4CGB8gfY=" crossorigin="anonymous" defer></script>
  <script src="/js/index.js" defer></script>
  <script src="/js/prompt.js" defer></script>
  <script src="/js/keyboard.js" defer></script>
  <script src="/js/tab.js" defer></script>
  <script src="/js/commands.js" defer></script>
  <script src="/js/config.js" defer></script><script src="/config.js"></script><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="style.css"><link rel="stylesheet" href="/css/page.css"></head><body onkeydown="exec(event)" style="background-image: url(&quot;&#x2F;assets&#x2F;bg.jpg&quot;); "><main>
      <div class="files" id="files" tabindex="0">
<ul>

  <li class="file">
    <span><a href='https://ilikexff.cn/8-kuan-rang-ni-kai-fa-qi-fei-de-intellijidea-cha-jian/'
      tabindex="-2">  8款让你开发起飞的IntellijIDEA插件</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/aop-jie-mi-qie-mian-bian-cheng-de-zong-he-zhi-nan/'
      tabindex="-3">  AOP揭秘：切面编程的综合指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-mei-ju-pian-yi-wu-fan-wei-mei-ju/'
      tabindex="-4">  C++游戏开发基础-枚举篇一：无范围枚举</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-std-optional/'
      tabindex="-5">  C++游戏开发基础-深入解析std::optional</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shen-ru-jie-xi-thiszhi-zhen-de-ying-yong-yu-ji-qiao/'
      tabindex="-6">  C++游戏开发基础-深入解析this指针的应用与技巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-fu-zhi-gou-zao-han-shu/'
      tabindex="-7">  C++游戏开发基础-深入解析复制构造函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-mo-ban-he-can-shu-tui-dao-zhi-nan/'
      tabindex="-8">  C++游戏开发基础-类模版和参数推导指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/dockerbi-zhi-bi-hui/'
      tabindex="-9">  Docker必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/githithub-xiao-ce/'
      tabindex="-10">  GitGitHub小册</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/google-hacking/'
      tabindex="-11">  Google Hacking</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/googleguan-fang-ti-shi-gong-cheng-bai-pi-shu-zhong-wen-yi-ben/'
      tabindex="-12">  Google官方《提示工程白皮书（中文译本）》</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-dai-ma-bu-quan-ti-shi-gong-neng-xiao-shi-de-ji-chong-jie-jue-fang-an-re-geng-ban/'
      tabindex="-13">  IDEA代码补全&amp;提示功能消失的几种解决方案(热更版)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-chen-jin-shi-bian-cheng-ti-yan/'
      tabindex="-14">  IDEA沉浸式编程体验</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-han-shu-shi-bian-cheng/'
      tabindex="-15">  Java函数式编程</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-ji-he-yuan-ma-qian-xi/'
      tabindex="-16">  Java集合源码浅析</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mysql-shi-wu-te-xing-yu-ge-chi-ji-bie-xiang-jie/'
      tabindex="-17">  MySQL_事务特性与隔离级别详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ocao-zuo-fu-shi-xian-mei-ju-de-shu-ru-shu-chu/'
      tabindex="-18">  O操作符,实现枚举的输入输出</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/prdsuan-fa-ting-shuo-ni-xiang-ping-yun-qi-chou-yi-ke-rong-yao-shui-jing/'
      tabindex="-19">  PRD算法：听说你想凭运气抽一颗荣耀水晶?</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/picgo-pei-zhi-ge-chong-tu-chuang/'
      tabindex="-20">  PicGo配置各种图床</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/redis-bi-zhi-bi-hui/'
      tabindex="-21">  Redis必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-zhong-de-move-yu-yi-sui-bi/'
      tabindex="-22">  Rust中的move语义随笔</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ssm-kuang-jia-shi-xian-ji-cheng-duan-xin-yan-zheng-ma-gong-neng/'
      tabindex="-23">  SSM框架实现集成短信验证码功能</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/slf4jyu-logbackshi-yong-zhi-nan-ji-yu-gradle/'
      tabindex="-24">  Slf4j与Logback实用指南(基于Gradle)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/spring-security5-xdao-spring-security6-xde-qian-yi/'
      tabindex="-25">  Spring Security5.x到Spring Security6.x的迁移</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springboot-webkai-fa-jing-jie/'
      tabindex="-26">  SpringBoot Web开发精解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springsecurity/'
      tabindex="-27">  SpringSecurity</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/unity6xia-jia-zhong-guo-qu-tuan-jie-yin-qing-jie-bang-zhe-shi-fen-lie-huan-shi-ben-di-hua-de-kai-shi/'
      tabindex="-28">  Unity6下架中国区，团结引擎接棒：这是分裂，还是本地化的开始？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-cong-0-dao-1-da-zao-quan-yu-yan-zhi-chi-de-mo-neng-bian-ji-qi-yu-fa-pian/'
      tabindex="-29">  Vim从0到1打造全语言支持的万能编辑器-语法篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-tiao-tou-powershell-pian/'
      tabindex="-30">  Vim折腾之 PowerShell篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-di-zhi-chuan-di-xiang-jie/'
      tabindex="-31">  [C++游戏开发基础]:地址传递详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-yin-yong-fan-hui-he-di-zhi-fan-hui/'
      tabindex="-32">  [C++游戏开发基础]:引用返回和地址返回</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-he-const/'
      tabindex="-33">  [C++游戏开发基础]:指针和const</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shu-ju-feng-zhuang-yin-cang-de-hao-chu/'
      tabindex="-34">  [C++游戏开发基础]:数据封装(隐藏)的好处</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-gou-zao-han-shu-qian-xi-8000zi/'
      tabindex="-35">  [C++游戏开发基础]:构造函数浅析(8000字)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-li-jie-kong-zhi-zhen/'
      tabindex="-36">  [C++游戏开发基础]:理解空指针</a></span>
  </li><li class="file">
    <span><a class="selected"href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-zhong-de-fang-wen-han-shu/'
      tabindex="-37">  [C++游戏开发基础]:类中的访问函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-de-ji-ben-gai-nian-li-jie/'
      tabindex="-38">  [C++游戏开发基础]指针的基本概念理解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/fanatical-wu-yue-feng-kuang-te-hui-wei-ni-de-steam-ku-jia-dian-liao/'
      tabindex="-39">  _Fanatical 五月疯狂特惠：为你的 Steam 库加点料！</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-kai-yuan-mi-ma-gong-ju-xpwd-zhong-wen-ban-bian-geng-ri-zhi/'
      tabindex="-40">  _Rust开源密码工具xpwd中文版变更日志</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/readme/'
      tabindex="-41">  readme</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wblog-bo-ke-xian-shang-bu-shu/'
      tabindex="-42">  wblog博客线上部署</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/shang-gu-shen-qi-vim-su-cheng-bei-wang-lu/'
      tabindex="-43">  上古神器_Vim速成备忘录</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mian-fei-ji-huo-quan-ban-ben-typora-zui-xin-ban-wei-li/'
      tabindex="-44">  免费激活全版本Typora，最新版为例</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-lombokxian-wei-ren-zhi-de-ji-ge-qi-ji-yin-qiao/'
      tabindex="-45">  关于Lombok鲜为人知的几个奇技淫巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-jie-kou-xian-liu-de-yi-ci-jian-dan-shi-jian/'
      tabindex="-46">  关于接口限流的一次简单实践</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/tu-jie-er-jin-zhi/'
      tabindex="-47">  图解二进制</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ru-he-xie-de-yi-shou-you-ya-gui-fan-de-springboot-jie-kou/'
      tabindex="-48">  如何写得一手优雅规范的SpringBoot 接口？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/kai-fa-bi-hui-xi-lie-jwtqian-tan/'
      tabindex="-49">  开发必会系列_JWT浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ji-qiao-jiu-shi-xiao-lu-chatgpt-diao-jiao-zhi-bei/'
      tabindex="-50">  技巧就是效率，ChatGPT调教指北</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-sheng-intellij-kai-fa-xiao-lu-zhe-kuan-dai-ma-tu-ding-cha-jian-codepins-zhi-de-yi-shi/'
      tabindex="-51">  提升 IntelliJ 开发效率？这款代码图钉插件 CodePins 值得一试</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-wen-de-zhi-hui-zhuan-zai/'
      tabindex="-52">  提问的智慧转载</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiao-lu-gong-ju-markdown/'
      tabindex="-53">  效率工具Markdown</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wu-wei-bing-fa-rust-sheng-ming-zhou-qi-qian-tan/'
      tabindex="-54">  无畏并发_Rust 生命周期浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-yu-de-bei-sai-er-qu-xian-gan-shou-si-hua-de-shu-xue-zhi-mei/'
      tabindex="-55">  游戏开发与的贝塞尔曲线_感受丝滑的数学之美</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-bi-bei-gao-xiao-de-aabb-qiu-ti-he-obb-peng-zhuang-jian-ce-suan-fa/'
      tabindex="-56">  游戏开发必备：高效的 AABB、球体和 OBB 碰撞检测算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-suan-fa-ji-chu-a-xun-lu-suan-fa-chi-xu-wei-hu/'
      tabindex="-57">  游戏算法基础-深入解析A*寻路算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/du-li-you-xi-kai-fa-zhe-gong-ju-xiang-2025jing-xuan-tui-jian-yu-shi-yong-zhi-nan/'
      tabindex="-58">  独立游戏开发者工具箱：2025精选推荐与实用指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xu-huan-yin-qing-you-xi-kai-fa-xi-lie-zhuan-ti-guan-fang-bian-ma-biao-zhun-huo-gui-yue/'
      tabindex="-59">  虚幻引擎游戏开发系列专题-官方编码标准或规约</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiang-jie-she-ji-mo-shi-dan-li-de-jin-hua-zhi-lu/'
      tabindex="-60">  详解设计模式_单例的进化之路</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xie-e-de-fei-chang-liang-quan-ju-bian-liang/'
      tabindex="-61">  邪恶的非常量全局变量</a></span>
  </li>
</ul>
</div>
      <div class="viewer page" id="viewer" tabindex="0">
        <div class="tab">
<div class="file-manager" onclick='document.getElementById("files").classList.toggle("open"); document.getElementById("content").classList.toggle("close")'> </div>
<ul id="tabs">
</ul>


</div>
        <div class="content" id="content"><blockquote>
<p>本节内容默认你已经掌握了C++中的<code>public</code>和<code>private</code>的作用。类通常将其数据成员设置为私有,而私有成员不能被公共部分直接访问。</p>
</blockquote>
<p>考虑下面程序:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Date
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_year</span><span style="color:#eff1f5;">{ </span><span style="color:#d08770;">2020 </span><span style="color:#eff1f5;">};
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_month</span><span style="color:#eff1f5;">{ </span><span style="color:#d08770;">10 </span><span style="color:#eff1f5;">};
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_day</span><span style="color:#eff1f5;">{ </span><span style="color:#d08770;">14 </span><span style="color:#eff1f5;">};
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; </span><span style="color:#bf616a;">m_year </span><span>&lt;&lt; &#39;</span><span style="color:#a3be8c;">/</span><span>&#39; &lt;&lt; </span><span style="color:#bf616a;">m_month </span><span>&lt;&lt; &#39;</span><span style="color:#a3be8c;">/</span><span>&#39; &lt;&lt; </span><span style="color:#bf616a;">m_day </span><span>&lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Date </span><span style="color:#bf616a;">d</span><span>{};  </span><span style="color:#65737e;">// 创建一个Date 对象
</span><span>    d.</span><span style="color:#bf616a;">print</span><span>(); 
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>尽管在程序中,我们提供了一个<code>print()</code>成员函数来打印整个日期信息,但这可能不足以满足用户需求。比如,如果一个<code>Date</code>对象的用户需要获取年份,或者将年份更改为不同的值,就程序目前的设计来说,他们无法做到这一点,因为类的数据成员都是<code>private</code>级别的。</p>
<hr />
<h2 id="fang-wen-han-shu">访问函数</h2>
<p>访问函数是一个简单的公共成员函数,他们的作用就是获取或者更改成员变量的值。</p>
<p>访问函数有两种类型:获取器和设置器。获取函数(也可以称为访问函数)是公共的成员函数,用于返回私有成员的值。设置器(修改器函数)也是公共的成员函数,用来设置私有成员变量的值。</p>
<blockquote>
<p><code>getter()</code>通常被声明为<code>const</code>,这样它们就可以在<code>const</code>和非<code>const</code>对象上调用。<code>setter()</code>则应该是声明为非<code>const</code>的,这样才能修改数据成员。</p>
</blockquote>
<p>针对当前讨论的话题,我们尝试更新之前的示例程序:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include</span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Date
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_year {</span><span style="color:#d08770;">2025</span><span style="color:#eff1f5;">};
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_month {</span><span style="color:#d08770;">3</span><span style="color:#eff1f5;">};
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> m_day {</span><span style="color:#d08770;">20</span><span style="color:#eff1f5;">};
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span style="color:#eff1f5;">()
</span><span style="color:#eff1f5;">  {
</span><span style="color:#eff1f5;">      std::cout </span><span>&lt;&lt; </span><span style="color:#bf616a;">m_year </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">-</span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_month </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">-</span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_day </span><span>&lt;&lt;</span><span style="color:#eff1f5;"> std::endl;
</span><span style="color:#eff1f5;">  }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">  </span><span style="color:#65737e;">// 设置获取
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">getYear</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#eff1f5;">{</span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_year</span><span style="color:#eff1f5;">;}
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">getMonth</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#eff1f5;">{</span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_month</span><span style="color:#eff1f5;">;}
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">getDay</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#eff1f5;">{</span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_day</span><span style="color:#eff1f5;">;}
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">setMonth</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">month</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">  {
</span><span style="color:#eff1f5;">      </span><span style="color:#bf616a;">m_month </span><span>=</span><span style="color:#eff1f5;"> month;
</span><span style="color:#eff1f5;">  }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">setDay</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">day</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">  {
</span><span style="color:#eff1f5;">      </span><span style="color:#bf616a;">m_day </span><span>=</span><span style="color:#eff1f5;"> day;
</span><span style="color:#eff1f5;">  }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">setYear</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">year</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">  {
</span><span style="color:#eff1f5;">      </span><span style="color:#bf616a;">m_year </span><span>=</span><span style="color:#eff1f5;"> year;
</span><span style="color:#eff1f5;">  }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Date </span><span style="color:#bf616a;">d</span><span>{};
</span><span>    d.</span><span style="color:#bf616a;">setYear</span><span>(</span><span style="color:#d08770;">2026</span><span>);
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">The year is:</span><span>&quot; &lt;&lt; d.</span><span style="color:#bf616a;">getYear</span><span>() &lt;&lt;&#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<hr />
<h2 id="guan-yu-fang-wen-han-shu-de-ming-ming">关于访问函数的命名</h2>
<p>在C++中并没有对于访问函数命名的明确约定,也就是说,你可以自由的为它们命名。但是,有一些在用的命名约定值的参考:</p>
<ul>
<li>以<code>get</code>和<code>set</code>开头</li>
</ul>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">getDay</span><span>() </span><span style="color:#b48ead;">const </span><span>{ </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_day</span><span>; }  </span><span style="color:#65737e;">// getter
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">setDay</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">day</span><span>) { </span><span style="color:#bf616a;">m_day </span><span>= day; } </span><span style="color:#65737e;">// setter
</span></code></pre>
<p>使用这样带前缀的命名约定的好处是,这使得我们可以很明显的知道这是访问函数。有见名知意的效果。</p>
<ul>
<li>无前缀命名</li>
</ul>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">day</span><span>() </span><span style="color:#b48ead;">const </span><span>{ </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_day</span><span>; }  </span><span style="color:#65737e;">// getter
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">day</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">day</span><span>) { </span><span style="color:#bf616a;">m_day </span><span>= day; } </span><span style="color:#65737e;">// setter
</span></code></pre>
<p>相对于这种命名风格,可能大部分人更加熟悉的是第一种,特别是学过<code>Java</code>的同学。这第二种风格使用相同的名称作为获取器和设置器,相对来说更加简洁,C++标准库使用的就是这种风格。</p>
<p>无前缀命名约定的缺点是,可能在 <strong>见名知意</strong> 这点上并不明显。</p>
<blockquote>
<p>还有,使用“<code>m_</code>”前缀来私有数据成员的一个最好的原因是避免数据成员和获取器具有相同名称（<code>C++</code>不支持这种情况，尽管像<code> Java</code> 这样的其他语言支持）。</p>
</blockquote>
<ul>
<li>只针对设置器使用<code>set</code>前缀</li>
</ul>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">day</span><span>() </span><span style="color:#b48ead;">const </span><span>{ </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_day</span><span>; }     </span><span style="color:#65737e;">// getter
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">setDay</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">day</span><span>) { </span><span style="color:#bf616a;">m_day </span><span>= day; } </span><span style="color:#65737e;">// setter
</span></code></pre>
<p>上面这三种方式的选择完全取决于你自己的喜好,但是,就我个人而言比较建议使用第二种(可能我也是Java畜生);</p>
<hr />
<h2 id="guan-yu-fang-wen-han-shu-getter-he-setter-zai-lei-she-ji-zhong-de-shi-yong-wen-ti">关于 <strong>访问函数（getter 和 setter）</strong> 在类设计中的使用问题</h2>
<p>当你在创建类时,不妨考虑下面几点建议;</p>
<ol>
<li>
<p><strong>如果类没有不变式（invariants），并且需要大量访问函数</strong>，那么 <strong>考虑使用 struct 而不是 class</strong>，并且直接将成员变量设为 public。</p>
</li>
<li>
<p><strong>不变式（invariants）</strong> 指的是 <strong>类的某些属性必须始终满足的规则</strong>，例如“日期类中的月份必须在 1-12 之间”。</p>
</li>
<li>
<p>如果类的成员变量没有这样的规则限制，直接使用 <code>struct</code> 可能更简单和直观，而不需要访问函数。</p>
</li>
<li>
<p><strong>优先实现行为（行为驱动设计），而不是单纯的访问函数</strong>。</p>
<blockquote>
<p>例如，<strong>不要</strong> 设计 setAlive(bool) 这样简单的 setter，而是使用 kill() 和 revive() 这样的函数，这样代码的意图更清晰，逻辑也更集中。</p>
</blockquote>
</li>
<li>
<p><strong>只有在公有接口真正需要访问某个成员变量时，才提供访问函数</strong>。</p>
<blockquote>
<p>例如，如果外部代码需要读取 id 或 name，那么 getId() 或 getName() 是合理的。但如果数据成员仅用于内部计算或管理，不要暴露 getter/setter，而是让类自身管理数据。</p>
</blockquote>
</li>
</ol>
<p>针对上面几点,下面给出一些正反面示例:</p>
<p><strong>反面示例,滥用访问函数</strong></p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Character
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">bool</span><span style="color:#eff1f5;"> m_alive {};
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">setAlive</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">bool </span><span style="color:#bf616a;">alive</span><span style="color:#eff1f5;">) { </span><span style="color:#bf616a;">m_alive </span><span>=</span><span style="color:#eff1f5;"> alive; }  </span><span style="color:#65737e;">// ❌ 不推荐，外部能随意改动
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">bool </span><span style="color:#8fa1b3;">isAlive</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#eff1f5;">{ </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_alive</span><span style="color:#eff1f5;">; }
</span><span style="color:#eff1f5;">}</span><span>;
</span></code></pre>
<p><strong>正面示例,行为驱动</strong></p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Character
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">bool</span><span style="color:#eff1f5;"> m_alive { </span><span style="color:#d08770;">true </span><span style="color:#eff1f5;">};
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">kill</span><span style="color:#eff1f5;">() { </span><span style="color:#bf616a;">m_alive </span><span>= </span><span style="color:#d08770;">false</span><span style="color:#eff1f5;">; }  </span><span style="color:#65737e;">// ✅ 通过 kill() 明确角色死亡
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">revive</span><span style="color:#eff1f5;">() { </span><span style="color:#bf616a;">m_alive </span><span>= </span><span style="color:#d08770;">true</span><span style="color:#eff1f5;">; } </span><span style="color:#65737e;">// ✅ 通过 revive() 复活角色
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">bool </span><span style="color:#8fa1b3;">isAlive</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#eff1f5;">{ </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_alive</span><span style="color:#eff1f5;">; }
</span><span style="color:#eff1f5;">}</span><span>;
</span></code></pre>
<p>这种方式更符合 <strong>封装</strong> 和 <strong>面向对象设计</strong> 原则，让 Character 类更具自我管理能力，而不是让外部代码随意修改其状态。</p>
<hr />
<h2 id="tong-guo-zhi-fan-hui-shu-ju-cheng-yuan">通过值返回数据成员</h2>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Employee
</span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">	std::string </span><span style="color:#bf616a;">m_name</span><span style="color:#eff1f5;">{};
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">	</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">setName</span><span style="color:#eff1f5;">(std::string_view </span><span style="color:#bf616a;">name</span><span style="color:#eff1f5;">) { </span><span style="color:#bf616a;">m_name </span><span>=</span><span style="color:#eff1f5;"> name; }
</span><span style="color:#eff1f5;">	std::string </span><span style="color:#8fa1b3;">getName</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#eff1f5;">{ </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_name</span><span style="color:#eff1f5;">; } </span><span style="color:#65737e;">//  getter returns by value
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>	Employee </span><span style="color:#bf616a;">joe</span><span>{};
</span><span>	joe.</span><span style="color:#bf616a;">setName</span><span>(&quot;</span><span style="color:#a3be8c;">Joe</span><span>&quot;);
</span><span>	std::cout &lt;&lt; joe.</span><span style="color:#bf616a;">getName</span><span>();
</span><span>
</span><span>	</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>在这个例子中,<code>getName()</code>函数可以以<code>std::string m_name</code>的值返回,虽然这是最安全的做法,但是在之前的文章中提过,复制是一个高成本的操作,由于访问函数通常会被频繁的调用,因此这显然不是最佳的选择。</p>
<hr />
<h2 id="tong-guo-lvalueyin-yong-fan-hui-shu-ju-cheng-yuan">通过<code>lvalue</code>引用返回数据成员</h2>
<p>成员函数也可以通过<code>const</code>的左值返回数据成员。</p>
<p>数据成员与包含它们的对象具有相同的生命周期。</p>
<p>由于成员函数总是针对一个对象调用的,而该对象必须存在于调用者的作用域中因此通常情况下,成员函数可以通过<code>const</code>修饰的左值应用返回一个数据成员。</p>
<p>更新上面的示例:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Employee
</span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">	std::string </span><span style="color:#bf616a;">m_name</span><span style="color:#eff1f5;">{};
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">	</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">setName</span><span style="color:#eff1f5;">(std::string_view </span><span style="color:#bf616a;">name</span><span style="color:#eff1f5;">) { </span><span style="color:#bf616a;">m_name </span><span>=</span><span style="color:#eff1f5;"> name; }
</span><span style="color:#eff1f5;">	</span><span style="color:#b48ead;">const</span><span style="color:#eff1f5;"> std::string</span><span>&amp; </span><span style="color:#8fa1b3;">getName</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#eff1f5;">{ </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_name</span><span style="color:#eff1f5;">; } </span><span style="color:#65737e;">//  getter returns by const reference
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>	Employee </span><span style="color:#bf616a;">joe</span><span>{}; </span><span style="color:#65737e;">// joe 直到函数结束,对象依旧存在
</span><span>	joe.</span><span style="color:#bf616a;">setName</span><span>(&quot;</span><span style="color:#a3be8c;">Joe</span><span>&quot;);
</span><span>
</span><span>	std::cout &lt;&lt; joe.</span><span style="color:#bf616a;">getName</span><span>(); </span><span style="color:#65737e;">// 通过引用返回
</span><span>
</span><span>	</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>更新后的程序中,当<code>joe.getName()</code>被调用时,<code>m_name</code>将会通过引用返回给调用者,避免了复制操作。由于<code>joe</code>存在与调用者的范围会持续到<code>main</code>函数结束,所以<code>joe.m_name</code>的引用也具有等效的生命周期,因此,这样的调用没问题。</p>
<hr />
<h2 id="rvalue-yin-shi-dui-xiang-yu-fan-hui-yin-yong"><strong>Rvalue 隐式对象与返回引用</strong></h2>
<p>在 C++ 中，<strong>rvalue（右值）对象</strong> 是临时对象，它们的生命周期通常只存在于当前的<strong>完整表达式（full expression）</strong> 内。</p>
<p>一旦这个表达式执行完毕，rvalue 对象就会被销毁。如果我们返回对一个 rvalue 的成员的引用，该引用将指向一个已经销毁的对象，从而导致<strong>悬垂引用（dangling reference）</strong>，最终引发<strong>未定义行为（undefined behavior, UB）</strong>。
就像上面的例子,使用<code>Lvalue</code>返回引用是安全的,下面看一个<code>Rvalue</code>引用返回的错误例子:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Person
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    std::string </span><span style="color:#bf616a;">m_name</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Person</span><span style="color:#eff1f5;">(std::string </span><span style="color:#bf616a;">name</span><span style="color:#eff1f5;">) : </span><span style="color:#bf616a;">m_name</span><span style="color:#eff1f5;">{name} {}
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">const</span><span style="color:#eff1f5;"> std::string</span><span>&amp; </span><span style="color:#8fa1b3;">getName</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#eff1f5;">{ </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_name</span><span style="color:#eff1f5;">; }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span>Person </span><span style="color:#8fa1b3;">createPerson</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">Person</span><span>{&quot;</span><span style="color:#a3be8c;">Alice</span><span>&quot;}; </span><span style="color:#65737e;">// 返回一个临时对象（rvalue）
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">const</span><span> std::string&amp; name = </span><span style="color:#bf616a;">createPerson</span><span>().</span><span style="color:#bf616a;">getName</span><span>(); </span><span style="color:#65737e;">// name 变成悬垂引用
</span><span>    std::cout &lt;&lt; name &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;; </span><span style="color:#65737e;">// 未定义行为！
</span><span>}
</span></code></pre>
<p><strong>看看发生了什么</strong></p>
<blockquote>
<p>​	1.<code>createPerson()</code> 返回一个 <code>Person{"Alice"}</code> <strong>临时对象（rvalue）</strong>。</p>
<p>​	2.<code>getName() </code>返回 <code>m_name</code> 的<strong>引用</strong>。</p>
<p>​	3.但 <code>Person{"Alice"} </code><strong>在表达式结束后立刻被销毁</strong>，其 <code>m_name</code> 也随之销毁。</p>
<p>​	4.<code>name</code> 仍然存储 <code>m_name </code>的引用，但这个引用已经悬空了！</p>
<p>​	5.访问 <code>name </code>时，程序会产生未定义行为（<code>UB</code>）。</p>
</blockquote>
<p>基于此,最佳的实践是:</p>
<blockquote>
<p>建议立即使用返回引用的成员函数的返回值,以避免在隐式对象为右值时出现悬空引用的问题。</p>
</blockquote>
<hr />
<h2 id="bu-yao-fan-hui-si-you-shu-ju-cheng-yuan-de-fei-chang-liang-yin-yong">不要返回私有数据成员的非常量引用</h2>
<p>返回非常量引用的成员函数可以提供对该成员的直接访问,即使该成员是<code>private</code>私有的。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Foo
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_value</span><span style="color:#eff1f5;">{ </span><span style="color:#d08770;">4 </span><span style="color:#eff1f5;">}; </span><span style="color:#65737e;">// 私有成员变量，初始值为 4
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int</span><span>&amp; </span><span style="color:#8fa1b3;">value</span><span style="color:#eff1f5;">() { </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_value</span><span style="color:#eff1f5;">; } </span><span style="color:#65737e;">// 返回 m_value 的 **非 const 引用**（不推荐这样做）
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Foo </span><span style="color:#bf616a;">f</span><span>{};                </span><span style="color:#65737e;">// 创建 Foo 对象 f，m_value 被初始化为默认值 4
</span><span>    f.</span><span style="color:#bf616a;">value</span><span>() = </span><span style="color:#d08770;">5</span><span>;          </span><span style="color:#65737e;">// 等价于 f.m_value = 5，直接修改私有成员变量
</span><span>    std::cout &lt;&lt; f.</span><span style="color:#bf616a;">value</span><span>(); </span><span style="color:#65737e;">// 输出 5
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>因为 <code>value()</code> 返回了一个非常量引用到 <code>m_value</code> ，调用者可以通过这个引用直接访问（并修改 <code>m_value</code> 的值）。这使得调用者可以绕过访问控制系统去随意修改私有数据,是非常危险的操作。</p>
<p>同时,<strong>常成员函数</strong>（const 修饰的成员函数）<strong>不允许返回成员变量的非常量引用</strong>。如果允许常成员函数返回成员变量的非常量引用，那么调用者就可以<strong>直接修改</strong>该成员变量。这将<strong>破坏常成员函数的初衷</strong>，违反 const 关键字的设计目的。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">BankAccount
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">double </span><span style="color:#bf616a;">m_balance</span><span style="color:#eff1f5;">{</span><span style="color:#d08770;">1000.0</span><span style="color:#eff1f5;">}; </span><span style="color:#65737e;">// 账户余额
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// 错误：常成员函数返回非常量引用
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">double</span><span>&amp; </span><span style="color:#8fa1b3;">getBalance</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const 
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_balance</span><span style="color:#eff1f5;">; </span><span style="color:#65737e;">// 返回余额的非 const 引用
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">const</span><span> BankAccount </span><span style="color:#bf616a;">account</span><span>{}; </span><span style="color:#65737e;">// 创建一个常量对象
</span><span>
</span><span>    </span><span style="color:#65737e;">// 这里违反了 const 规则，因为 `getBalance()` 居然能修改 `m_balance`
</span><span>    account.</span><span style="color:#bf616a;">getBalance</span><span>() = </span><span style="color:#d08770;">500.0</span><span>; </span><span style="color:#65737e;">// ❌ 逻辑错误：修改了 const 对象的成员变量
</span><span>
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Account balance: </span><span>&quot; &lt;&lt; account.</span><span style="color:#bf616a;">getBalance</span><span>() &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>

        </div>
      </div>
      <div class="prompt" id="terminal"><input
    type="text"
    id="setter"
    onkeydown="writeit(this, event);moveIt(this.value.length, event)"
    onchange="writeit(this, event)"
    onkeyup="writeit(this, event)"
    onkeypress="writeit(this, event);"
    >
<label for="setter" id="writer"> </label><b class="cursor" id="cursor"></b></div>
      <footer class="footer">
        <div class="footer-content">
          <p class="icp-info">
            <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer">黔ICP备2021010295号</a>
          </p>
        </div>
      </footer>
    </main>
  </body>

</html>
