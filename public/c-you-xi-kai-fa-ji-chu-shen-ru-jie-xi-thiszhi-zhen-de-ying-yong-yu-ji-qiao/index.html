<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>慕予博客</title>
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"
    integrity="sha256-WCzAhd2P6gRJF9Hv3oOOd+hFJi/QJbv+Azn4CGB8gfY=" crossorigin="anonymous" defer></script>
  <script src="/js/index.js" defer></script>
  <script src="/js/prompt.js" defer></script>
  <script src="/js/keyboard.js" defer></script>
  <script src="/js/tab.js" defer></script>
  <script src="/js/commands.js" defer></script>
  <script src="/js/config.js" defer></script><script src="/config.js"></script><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="style.css"><link rel="stylesheet" href="/css/page.css"></head><body onkeydown="exec(event)" style="background-image: url(&quot;&#x2F;assets&#x2F;bg.jpg&quot;); "><main>
      <div class="files" id="files" tabindex="0">
<ul>

  <li class="file">
    <span><a href='https://ilikexff.cn/8-kuan-rang-ni-kai-fa-qi-fei-de-intellijidea-cha-jian/'
      tabindex="-2">  8款让你开发起飞的IntellijIDEA插件</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/aop-jie-mi-qie-mian-bian-cheng-de-zong-he-zhi-nan/'
      tabindex="-3">  AOP揭秘：切面编程的综合指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-mei-ju-pian-yi-wu-fan-wei-mei-ju/'
      tabindex="-4">  C++游戏开发基础-枚举篇一：无范围枚举</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-std-optional/'
      tabindex="-5">  C++游戏开发基础-深入解析std::optional</a></span>
  </li><li class="file">
    <span><a class="selected"href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shen-ru-jie-xi-thiszhi-zhen-de-ying-yong-yu-ji-qiao/'
      tabindex="-6">  C++游戏开发基础-深入解析this指针的应用与技巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-fu-zhi-gou-zao-han-shu/'
      tabindex="-7">  C++游戏开发基础-深入解析复制构造函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-mo-ban-he-can-shu-tui-dao-zhi-nan/'
      tabindex="-8">  C++游戏开发基础-类模版和参数推导指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/dockerbi-zhi-bi-hui/'
      tabindex="-9">  Docker必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/githithub-xiao-ce/'
      tabindex="-10">  GitGitHub小册</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/google-hacking/'
      tabindex="-11">  Google Hacking</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/googleguan-fang-ti-shi-gong-cheng-bai-pi-shu-zhong-wen-yi-ben/'
      tabindex="-12">  Google官方《提示工程白皮书（中文译本）》</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-dai-ma-bu-quan-ti-shi-gong-neng-xiao-shi-de-ji-chong-jie-jue-fang-an-re-geng-ban/'
      tabindex="-13">  IDEA代码补全&amp;提示功能消失的几种解决方案(热更版)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-chen-jin-shi-bian-cheng-ti-yan/'
      tabindex="-14">  IDEA沉浸式编程体验</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-han-shu-shi-bian-cheng/'
      tabindex="-15">  Java函数式编程</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-ji-he-yuan-ma-qian-xi/'
      tabindex="-16">  Java集合源码浅析</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mysql-shi-wu-te-xing-yu-ge-chi-ji-bie-xiang-jie/'
      tabindex="-17">  MySQL_事务特性与隔离级别详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ocao-zuo-fu-shi-xian-mei-ju-de-shu-ru-shu-chu/'
      tabindex="-18">  O操作符,实现枚举的输入输出</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/prdsuan-fa-ting-shuo-ni-xiang-ping-yun-qi-chou-yi-ke-rong-yao-shui-jing/'
      tabindex="-19">  PRD算法：听说你想凭运气抽一颗荣耀水晶?</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/picgo-pei-zhi-ge-chong-tu-chuang/'
      tabindex="-20">  PicGo配置各种图床</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/redis-bi-zhi-bi-hui/'
      tabindex="-21">  Redis必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-zhong-de-move-yu-yi-sui-bi/'
      tabindex="-22">  Rust中的move语义随笔</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ssm-kuang-jia-shi-xian-ji-cheng-duan-xin-yan-zheng-ma-gong-neng/'
      tabindex="-23">  SSM框架实现集成短信验证码功能</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/slf4jyu-logbackshi-yong-zhi-nan-ji-yu-gradle/'
      tabindex="-24">  Slf4j与Logback实用指南(基于Gradle)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/spring-security5-xdao-spring-security6-xde-qian-yi/'
      tabindex="-25">  Spring Security5.x到Spring Security6.x的迁移</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springboot-webkai-fa-jing-jie/'
      tabindex="-26">  SpringBoot Web开发精解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springsecurity/'
      tabindex="-27">  SpringSecurity</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/unity6xia-jia-zhong-guo-qu-tuan-jie-yin-qing-jie-bang-zhe-shi-fen-lie-huan-shi-ben-di-hua-de-kai-shi/'
      tabindex="-28">  Unity6下架中国区，团结引擎接棒：这是分裂，还是本地化的开始？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-cong-0-dao-1-da-zao-quan-yu-yan-zhi-chi-de-mo-neng-bian-ji-qi-yu-fa-pian/'
      tabindex="-29">  Vim从0到1打造全语言支持的万能编辑器-语法篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-tiao-tou-powershell-pian/'
      tabindex="-30">  Vim折腾之 PowerShell篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-di-zhi-chuan-di-xiang-jie/'
      tabindex="-31">  [C++游戏开发基础]:地址传递详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-yin-yong-fan-hui-he-di-zhi-fan-hui/'
      tabindex="-32">  [C++游戏开发基础]:引用返回和地址返回</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-he-const/'
      tabindex="-33">  [C++游戏开发基础]:指针和const</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shu-ju-feng-zhuang-yin-cang-de-hao-chu/'
      tabindex="-34">  [C++游戏开发基础]:数据封装(隐藏)的好处</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-gou-zao-han-shu-qian-xi-8000zi/'
      tabindex="-35">  [C++游戏开发基础]:构造函数浅析(8000字)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-li-jie-kong-zhi-zhen/'
      tabindex="-36">  [C++游戏开发基础]:理解空指针</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-zhong-de-fang-wen-han-shu/'
      tabindex="-37">  [C++游戏开发基础]:类中的访问函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-de-ji-ben-gai-nian-li-jie/'
      tabindex="-38">  [C++游戏开发基础]指针的基本概念理解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/fanatical-wu-yue-feng-kuang-te-hui-wei-ni-de-steam-ku-jia-dian-liao/'
      tabindex="-39">  _Fanatical 五月疯狂特惠：为你的 Steam 库加点料！</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-kai-yuan-mi-ma-gong-ju-xpwd-zhong-wen-ban-bian-geng-ri-zhi/'
      tabindex="-40">  _Rust开源密码工具xpwd中文版变更日志</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/readme/'
      tabindex="-41">  readme</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wblog-bo-ke-xian-shang-bu-shu/'
      tabindex="-42">  wblog博客线上部署</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/shang-gu-shen-qi-vim-su-cheng-bei-wang-lu/'
      tabindex="-43">  上古神器_Vim速成备忘录</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mian-fei-ji-huo-quan-ban-ben-typora-zui-xin-ban-wei-li/'
      tabindex="-44">  免费激活全版本Typora，最新版为例</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-lombokxian-wei-ren-zhi-de-ji-ge-qi-ji-yin-qiao/'
      tabindex="-45">  关于Lombok鲜为人知的几个奇技淫巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-jie-kou-xian-liu-de-yi-ci-jian-dan-shi-jian/'
      tabindex="-46">  关于接口限流的一次简单实践</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/tu-jie-er-jin-zhi/'
      tabindex="-47">  图解二进制</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ru-he-xie-de-yi-shou-you-ya-gui-fan-de-springboot-jie-kou/'
      tabindex="-48">  如何写得一手优雅规范的SpringBoot 接口？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/kai-fa-bi-hui-xi-lie-jwtqian-tan/'
      tabindex="-49">  开发必会系列_JWT浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ji-qiao-jiu-shi-xiao-lu-chatgpt-diao-jiao-zhi-bei/'
      tabindex="-50">  技巧就是效率，ChatGPT调教指北</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-sheng-intellij-kai-fa-xiao-lu-zhe-kuan-dai-ma-tu-ding-cha-jian-codepins-zhi-de-yi-shi/'
      tabindex="-51">  提升 IntelliJ 开发效率？这款代码图钉插件 CodePins 值得一试</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-wen-de-zhi-hui-zhuan-zai/'
      tabindex="-52">  提问的智慧转载</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiao-lu-gong-ju-markdown/'
      tabindex="-53">  效率工具Markdown</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wu-wei-bing-fa-rust-sheng-ming-zhou-qi-qian-tan/'
      tabindex="-54">  无畏并发_Rust 生命周期浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-yu-de-bei-sai-er-qu-xian-gan-shou-si-hua-de-shu-xue-zhi-mei/'
      tabindex="-55">  游戏开发与的贝塞尔曲线_感受丝滑的数学之美</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-bi-bei-gao-xiao-de-aabb-qiu-ti-he-obb-peng-zhuang-jian-ce-suan-fa/'
      tabindex="-56">  游戏开发必备：高效的 AABB、球体和 OBB 碰撞检测算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-suan-fa-ji-chu-a-xun-lu-suan-fa-chi-xu-wei-hu/'
      tabindex="-57">  游戏算法基础-深入解析A*寻路算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/du-li-you-xi-kai-fa-zhe-gong-ju-xiang-2025jing-xuan-tui-jian-yu-shi-yong-zhi-nan/'
      tabindex="-58">  独立游戏开发者工具箱：2025精选推荐与实用指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xu-huan-yin-qing-you-xi-kai-fa-xi-lie-zhuan-ti-guan-fang-bian-ma-biao-zhun-huo-gui-yue/'
      tabindex="-59">  虚幻引擎游戏开发系列专题-官方编码标准或规约</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiang-jie-she-ji-mo-shi-dan-li-de-jin-hua-zhi-lu/'
      tabindex="-60">  详解设计模式_单例的进化之路</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xie-e-de-fei-chang-liang-quan-ju-bian-liang/'
      tabindex="-61">  邪恶的非常量全局变量</a></span>
  </li>
</ul>
</div>
      <div class="viewer page" id="viewer" tabindex="0">
        <div class="tab">
<div class="file-manager" onclick='document.getElementById("files").classList.toggle("open"); document.getElementById("content").classList.toggle("close")'> </div>
<ul id="tabs">
</ul>


</div>
        <div class="content" id="content"><p>如果你没有其他面向对象的编程语言基础,比如<code>Java</code>、<code>c#</code>等,那么你在学习C++面向对象时可能会好奇,当一个成员函数被调用的时候,C++是如何跟踪它被调用的对象的?</p>
<p>考虑下面的程序:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Simple
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_id</span><span style="color:#eff1f5;">{};
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Simple</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">id</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">        : </span><span style="color:#bf616a;">m_id</span><span style="color:#eff1f5;">{ id }
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">getID</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#eff1f5;">{ </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_id</span><span style="color:#eff1f5;">; }
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">setID</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">id</span><span style="color:#eff1f5;">) { </span><span style="color:#bf616a;">m_id </span><span>=</span><span style="color:#eff1f5;"> id; }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#eff1f5;">{ std::cout </span><span>&lt;&lt; </span><span style="color:#bf616a;">m_id</span><span style="color:#eff1f5;">; }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Simple </span><span style="color:#bf616a;">simple</span><span>{</span><span style="color:#d08770;">1</span><span>};
</span><span>    simple.</span><span style="color:#bf616a;">setID</span><span>(</span><span style="color:#d08770;">2</span><span>);
</span><span>
</span><span>    simple.</span><span style="color:#bf616a;">print</span><span>();
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>对于上述代码,当我们调用 <code>simple.setID（2）;</code> 时，C++知道函数 <code>setID（）</code> 应该对对象 <code>simple 进行</code>操作，并且 <code>m_id</code> 实际上引用了 <code>simple.m_id</code>。</p>
<p>为什么会这样?这因为C++使用了一个名为<code>this</code>的隐藏指针。</p>
<hr />
<h2 id="yin-cang-de-thiszhi-zhen">隐藏的this指针</h2>
<p>在每一个成员函数中,关键字<code>this</code>是一个常量指针,它保存当前隐式对象的地址。因此,下面两种写法是等效的;</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span>() </span><span style="color:#b48ead;">const </span><span>{std::cout &lt;&lt;</span><span style="color:#bf616a;">m_id</span><span>;}
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span>() </span><span style="color:#b48ead;">const </span><span>{std::cout &lt;&lt;</span><span style="color:#bf616a;">this</span><span>-&gt;</span><span style="color:#bf616a;">m_id</span><span>;}
</span></code></pre>
<p>但是事实证明,前者是后者的简写。当我们程序编译时,编译器将隐式地在引用隐式对象的任何成员前面加上<code>this-&gt;</code> 。 这有助于我们的代码跟更简洁,而不需要一遍遍的重复<code>this-&gt;</code></p>
<blockquote>
<p>我们使用 <code>-&gt;</code> 从指向对象的指针中选择成员。<code>this-&gt;m_id</code> 相当于 <code>（*this）.m_id</code>。</p>
</blockquote>
<hr />
<h2 id="thisdi-ceng-shi-xian">this底层实现</h2>
<p>回顾下面函数的调用:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>simple.</span><span style="color:#bf616a;">setID</span><span>(</span><span style="color:#d08770;">2</span><span>);
</span></code></pre>
<p>虽然对函数<code>setID(2)</code>的调用表面上看起来好像就一个参数,但实际上有两个。在编译时,编译器会重写表达式<code>simple.setID(2)</code>:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>Simple::</span><span style="color:#8fa1b3;">simple</span><span>(&amp;</span><span style="color:#bf616a;">simple</span><span>,</span><span style="color:#d08770;">2</span><span>);
</span></code></pre>
<p>同理,由于函数的调用现在增加了一个参数,那么成员函数定义也需要进行调整以适应接受此参数。下面是<code>setID()</code>的原始定义:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">setID</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">id</span><span>) {</span><span style="color:#bf616a;">m_id </span><span>= id;}
</span></code></pre>
<p>编译器重写之后的结果可能是下面这样的:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">static void </span><span style="color:#8fa1b3;">setID</span><span>(Simple* </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">this</span><span>,</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">id</span><span>)
</span><span>{
</span><span>  </span><span style="color:#bf616a;">this</span><span>-&gt;</span><span style="color:#bf616a;">m_id </span><span>= id;
</span><span>}
</span></code></pre>
<p>⚠️注意,重写后的函数参数多了一个<code>this</code>参数,它是一个常量指针。使用<code>this</code>指针,<code>m_id</code>成员也被重写为<code>this-&gt;m_id</code>;</p>
<blockquote>
<p>在这种情况下,关键字<code>static</code>意味着函数与类的对象无关,而是被视为类作用域内的普通函数。</p>
</blockquote>
<p>所以总结一下就是:</p>
<ul>
<li>当我们调用 <code>simple.setID（2）</code> 时，编译器实际上调用 <code>Simple：：setID（simple，2）</code>，<code>simple</code> 通过地址传递给函数。</li>
<li>函数有一个名为 <code>this 的</code>隐藏参数，它接收 <code>simple</code> 的地址。</li>
<li><code>setID（）</code>中的成员变量以 <code>this-&gt; 为</code>前缀，它指向 <code>simple</code>。因此，当编译器<code>计算</code>-&gt;m_id时 ，它实际上是解析为 <code>simple.m_id</code>。</li>
</ul>
<blockquote>
<p>在 C++ 中，所有非静态成员函数（即类的成员函数）都有一个隐含的指针 this，它指向当前对象（即调用该成员函数的对象）的地址。</p>
</blockquote>
<p><strong>非静态成员函数</strong>：</p>
<p>非静态成员函数是与某个具体对象相关的函数，它们依赖于对象的状态（成员变量）。这些函数不能独立于类的对象存在，需要通过对象来调用。</p>
<hr />
<h2 id="xian-shi-de-yin-yong-this">显式的引用this</h2>
<p>大多数时候,我们不需要显式的引用<code>this</code>。 但是,在一些特定情况下这样做是个不错的选择。</p>
<p>首先,如果你有一个成员函数,它有一个与数据成员同名的参数,那么你可以通过这种方式来消除歧义:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">struct </span><span>Something
</span><span>{
</span><span>    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">data</span><span>{}; 
</span><span>
</span><span>    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">setData</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">data</span><span>)
</span><span>    {
</span><span>        </span><span style="color:#bf616a;">this</span><span>-&gt;</span><span style="color:#bf616a;">data </span><span>= data; 
</span><span>    }
</span><span>};
</span></code></pre>
<p>这个 <code>Something</code> 类有一个名为 <code>data 的</code>成员。<code>setData（）</code> 的函数参数也被命名为 <code>data</code>。在 <code>setData（）</code> 函数中，<code>data</code> 引用函数参数（因为函数参数隐藏了数据成员），所以如果我们想引用<code>数据</code>成员，可以使用 <code>this-&gt;data</code>。</p>
<p>有些程序员习惯使用这样的写法,可能是由于Java的习惯,但是在C++中,并不建议这样做,还是推荐之前说过的使用<code>m_</code>前缀来区分私有成员和非成员变量。</p>
<p>其次,有时让成员函数将隐式对象作为返回值返回也是很有用的。这样做的主要原因是允许成员函数可以被链式调用。</p>
<p>这被称为 <strong>函数链或者方法链</strong> ;</p>
<p>考虑下面的例子:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Calc
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_value</span><span style="color:#eff1f5;">{};
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">add</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">value</span><span style="color:#eff1f5;">) { </span><span style="color:#bf616a;">m_value </span><span>+=</span><span style="color:#eff1f5;"> value; }
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">sub</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">value</span><span style="color:#eff1f5;">) { </span><span style="color:#bf616a;">m_value </span><span>-=</span><span style="color:#eff1f5;"> value; }
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">mult</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">value</span><span style="color:#eff1f5;">) { </span><span style="color:#bf616a;">m_value </span><span>*=</span><span style="color:#eff1f5;"> value; }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">getValue</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#eff1f5;">{ </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_value</span><span style="color:#eff1f5;">; }
</span><span style="color:#eff1f5;">}</span><span>;
</span></code></pre>
<p>基于上述写法,如果你现在想要执行加6减2乘以3,那么你必须这样做:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Calc </span><span style="color:#bf616a;">calc</span><span>{};
</span><span>    calc.</span><span style="color:#bf616a;">add</span><span>(</span><span style="color:#d08770;">2</span><span>); 
</span><span>    calc.</span><span style="color:#bf616a;">sub</span><span>(</span><span style="color:#d08770;">2</span><span>); 
</span><span>    calc.</span><span style="color:#bf616a;">mult</span><span>(</span><span style="color:#d08770;">3</span><span>); 
</span><span>
</span><span>    std::cout &lt;&lt; calc.</span><span style="color:#bf616a;">getValue</span><span>() &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>但是,如果我们通过引用使每个函数返回<code>*this</code>,就可以将调用链接在一起。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Calc
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_value</span><span style="color:#eff1f5;">{};
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    Calc</span><span>&amp; </span><span style="color:#8fa1b3;">add</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">value</span><span style="color:#eff1f5;">) { </span><span style="color:#bf616a;">m_value </span><span>+=</span><span style="color:#eff1f5;"> value; </span><span style="color:#b48ead;">return </span><span>*</span><span style="color:#bf616a;">this</span><span style="color:#eff1f5;">; }
</span><span style="color:#eff1f5;">    Calc</span><span>&amp; </span><span style="color:#8fa1b3;">sub</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">value</span><span style="color:#eff1f5;">) { </span><span style="color:#bf616a;">m_value </span><span>-=</span><span style="color:#eff1f5;"> value; </span><span style="color:#b48ead;">return </span><span>*</span><span style="color:#bf616a;">this</span><span style="color:#eff1f5;">; }
</span><span style="color:#eff1f5;">    Calc</span><span>&amp; </span><span style="color:#8fa1b3;">mult</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">value</span><span style="color:#eff1f5;">) { </span><span style="color:#bf616a;">m_value </span><span>*=</span><span style="color:#eff1f5;"> value; </span><span style="color:#b48ead;">return </span><span>*</span><span style="color:#bf616a;">this</span><span style="color:#eff1f5;">; }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">getValue</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#eff1f5;">{ </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_value</span><span style="color:#eff1f5;">; }
</span><span style="color:#eff1f5;">}</span><span>;
</span></code></pre>
<p>因此,我们可以像下面这样进行链式调用:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Calc </span><span style="color:#bf616a;">calc</span><span>{};
</span><span>    calc.</span><span style="color:#bf616a;">add</span><span>(</span><span style="color:#d08770;">6</span><span>).</span><span style="color:#bf616a;">sub</span><span>(</span><span style="color:#d08770;">2</span><span>).</span><span style="color:#bf616a;">mult</span><span>(</span><span style="color:#d08770;">3</span><span>); 
</span><span>
</span><span>    std::cout &lt;&lt; calc.</span><span style="color:#bf616a;">getValue</span><span>() &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>首先，调用 <code>calc.add（5）</code>，它将 <code>m_value</code> 加上 <code>5</code>。<code>add（）</code> 然后返回一个对 <code>*this 的</code>引用，这是对隐式对象 <code>calc</code> 的引用，因此 <code>calc</code> 将是后续计算中使用的对象。下一个 <code>calc.sub（3）</code> 求值，从 <code>m_value</code> 中减去 <code>3</code>，并再次返回 <code>calc . sub</code>（3）。最后，<code>calc.mult（4）</code> 将 <code>m_value</code> 乘以 <code>4</code> 并返回 <code>calc</code>，它不会被进一步使用，因此被忽略。</p>
<p>由于每个函数在执行时都会修改 <code>calc</code>，<code> 因此 calc</code> 的 <code>m_value</code> 现在包含值（0 + 5）- 3）* 4），即 <code>8</code>。</p>
<blockquote>
<p>因为<code>它</code>总是指向隐式对象，所以在解引用它之前，我们不需要检查它是否是空指针。</p>
</blockquote>
<hr />
<h2 id="zhong-zhi-lei-de-mo-ren-zhuang-tai">重置类的默认状态</h2>
<p>如果你的类有一个默认的构造函数,你可能会提供一种方法来将现有的对象重置到它默认的状态。但是之前说过,构造函数仅用于初始化新对象,不应直接调用。这样做会导致意外的行为。</p>
<p>所以要实现上面重置状态的需求,最佳的方法是创建一个类似于<code>reset()</code>这样的函数, 让该函数创建一个新对象(使用默认构造函数),然后将该新对象复制给当前隐式对象。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">reset</span><span>()
</span><span>{
</span><span>  *</span><span style="color:#bf616a;">this </span><span>= {};
</span><span>}
</span></code></pre>
<p>下面是一个完整的示例:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Calc
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">m_value</span><span style="color:#eff1f5;">{};
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    Calc</span><span>&amp; </span><span style="color:#8fa1b3;">add</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">value</span><span style="color:#eff1f5;">) { </span><span style="color:#bf616a;">m_value </span><span>+=</span><span style="color:#eff1f5;"> value; </span><span style="color:#b48ead;">return </span><span>*</span><span style="color:#bf616a;">this</span><span style="color:#eff1f5;">; }
</span><span style="color:#eff1f5;">    Calc</span><span>&amp; </span><span style="color:#8fa1b3;">sub</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">value</span><span style="color:#eff1f5;">) { </span><span style="color:#bf616a;">m_value </span><span>-=</span><span style="color:#eff1f5;"> value; </span><span style="color:#b48ead;">return </span><span>*</span><span style="color:#bf616a;">this</span><span style="color:#eff1f5;">; }
</span><span style="color:#eff1f5;">    Calc</span><span>&amp; </span><span style="color:#8fa1b3;">mult</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">value</span><span style="color:#eff1f5;">) { </span><span style="color:#bf616a;">m_value </span><span>*=</span><span style="color:#eff1f5;"> value; </span><span style="color:#b48ead;">return </span><span>*</span><span style="color:#bf616a;">this</span><span style="color:#eff1f5;">; }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">getValue</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#eff1f5;">{ </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_value</span><span style="color:#eff1f5;">; }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">reset</span><span style="color:#eff1f5;">() { </span><span>*</span><span style="color:#bf616a;">this </span><span>= </span><span style="color:#eff1f5;">{}; }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Calc </span><span style="color:#bf616a;">calc</span><span>{};
</span><span>    calc.</span><span style="color:#bf616a;">add</span><span>(</span><span style="color:#d08770;">5</span><span>).</span><span style="color:#bf616a;">sub</span><span>(</span><span style="color:#d08770;">3</span><span>).</span><span style="color:#bf616a;">mult</span><span>(</span><span style="color:#d08770;">4</span><span>);
</span><span>
</span><span>    std::cout &lt;&lt; calc.</span><span style="color:#bf616a;">getValue</span><span>() &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;; </span><span style="color:#65737e;">// prints 8
</span><span>
</span><span>    calc.</span><span style="color:#bf616a;">reset</span><span>();
</span><span>
</span><span>    std::cout &lt;&lt; calc.</span><span style="color:#bf616a;">getValue</span><span>() &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;; </span><span style="color:#65737e;">// prints 0
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<hr />
<h2 id="thishe-constdui-xiang-de-guan-xi">this和const对象的关系</h2>
<ul>
<li>
<p>对于非<code>const</code>成员函数,<code>this</code>是一个指向非<code>const</code>值的<code>cosn</code>指针。(这意味着<code>this</code>不能指向其他对象,但指向的对象可以被修改)。</p>
</li>
<li>
<p>对于<code>const</code>成员函数,<code>this</code>是一个指向<code>const</code>值的<code>const</code>指针(意味着指针不能指向其他对象,也不能修改被指向的对象)。</p>
</li>
</ul>
<h2 id="wei-shen-me-thisshi-zhi-zhen-er-bu-shi-yin-yong">为什么this是指针而不是引用?</h2>
<p>和Java以及C#不同,<code>this</code>在C++中出现的时候,<code>C++</code>还没有引入引用这种东西(🤪)!</p>
<hr />
<h2 id="wang-qi-tui-jian">往期推荐</h2>
<ul>
<li><a class="" href="https://www.ilikexff.cn/articles/163">游戏算法基础- A星寻路</a></li>
<li><a class="" href="https://www.ilikexff.cn/articles/161">构造函数8000字长文浅析</a></li>
</ul>

        </div>
      </div>
      <div class="prompt" id="terminal"><input
    type="text"
    id="setter"
    onkeydown="writeit(this, event);moveIt(this.value.length, event)"
    onchange="writeit(this, event)"
    onkeyup="writeit(this, event)"
    onkeypress="writeit(this, event);"
    >
<label for="setter" id="writer"> </label><b class="cursor" id="cursor"></b></div>
      <footer class="footer">
        <div class="footer-content">
          <p class="icp-info">
            <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer">黔ICP备2021010295号</a>
          </p>
        </div>
      </footer>
    </main>
  </body>

</html>
