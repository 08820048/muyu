<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>慕予博客</title>
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"
    integrity="sha256-WCzAhd2P6gRJF9Hv3oOOd+hFJi/QJbv+Azn4CGB8gfY=" crossorigin="anonymous" defer></script>
  <script src="/js/index.js" defer></script>
  <script src="/js/prompt.js" defer></script>
  <script src="/js/keyboard.js" defer></script>
  <script src="/js/tab.js" defer></script>
  <script src="/js/commands.js" defer></script>
  <script src="/js/config.js" defer></script><script src="/config.js"></script><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="style.css"><link rel="stylesheet" href="/css/page.css"></head><body onkeydown='exec(event)' style='background-image: url("/assets/background.jpg");'><main>
      <div class="files" id="files" tabindex="0">
<ul>

  <li class="file">
    <span><a href='https://ilikexff.cn/8-kuan-rang-ni-kai-fa-qi-fei-de-intellijidea-cha-jian/'
      tabindex="-2">  8款让你开发起飞的IntellijIDEA插件</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/aop-jie-mi-qie-mian-bian-cheng-de-zong-he-zhi-nan/'
      tabindex="-3">  AOP揭秘：切面编程的综合指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-mei-ju-pian-yi-wu-fan-wei-mei-ju/'
      tabindex="-4">  C++游戏开发基础-枚举篇一：无范围枚举</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-std-optional/'
      tabindex="-5">  C++游戏开发基础-深入解析std::optional</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shen-ru-jie-xi-thiszhi-zhen-de-ying-yong-yu-ji-qiao/'
      tabindex="-6">  C++游戏开发基础-深入解析this指针的应用与技巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-fu-zhi-gou-zao-han-shu/'
      tabindex="-7">  C++游戏开发基础-深入解析复制构造函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-mo-ban-he-can-shu-tui-dao-zhi-nan/'
      tabindex="-8">  C++游戏开发基础-类模版和参数推导指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/dockerbi-zhi-bi-hui/'
      tabindex="-9">  Docker必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/githithub-xiao-ce/'
      tabindex="-10">  GitGitHub小册</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/google-hacking/'
      tabindex="-11">  Google Hacking</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/googleguan-fang-ti-shi-gong-cheng-bai-pi-shu-zhong-wen-yi-ben/'
      tabindex="-12">  Google官方《提示工程白皮书（中文译本）》</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-dai-ma-bu-quan-ti-shi-gong-neng-xiao-shi-de-ji-chong-jie-jue-fang-an-re-geng-ban/'
      tabindex="-13">  IDEA代码补全&amp;提示功能消失的几种解决方案(热更版)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-chen-jin-shi-bian-cheng-ti-yan/'
      tabindex="-14">  IDEA沉浸式编程体验</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-han-shu-shi-bian-cheng/'
      tabindex="-15">  Java函数式编程</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-ji-he-yuan-ma-qian-xi/'
      tabindex="-16">  Java集合源码浅析</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mysql-shi-wu-te-xing-yu-ge-chi-ji-bie-xiang-jie/'
      tabindex="-17">  MySQL_事务特性与隔离级别详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ocao-zuo-fu-shi-xian-mei-ju-de-shu-ru-shu-chu/'
      tabindex="-18">  O操作符,实现枚举的输入输出</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/prdsuan-fa-ting-shuo-ni-xiang-ping-yun-qi-chou-yi-ke-rong-yao-shui-jing/'
      tabindex="-19">  PRD算法：听说你想凭运气抽一颗荣耀水晶?</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/picgo-pei-zhi-ge-chong-tu-chuang/'
      tabindex="-20">  PicGo配置各种图床</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/redis-bi-zhi-bi-hui/'
      tabindex="-21">  Redis必知必会</a></span>
  </li><li class="file">
    <span><a class="selected"href='https://ilikexff.cn/rust-zhong-de-move-yu-yi-sui-bi/'
      tabindex="-22">  Rust中的move语义随笔</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ssm-kuang-jia-shi-xian-ji-cheng-duan-xin-yan-zheng-ma-gong-neng/'
      tabindex="-23">  SSM框架实现集成短信验证码功能</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/slf4jyu-logbackshi-yong-zhi-nan-ji-yu-gradle/'
      tabindex="-24">  Slf4j与Logback实用指南(基于Gradle)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/spring-security5-xdao-spring-security6-xde-qian-yi/'
      tabindex="-25">  Spring Security5.x到Spring Security6.x的迁移</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springboot-webkai-fa-jing-jie/'
      tabindex="-26">  SpringBoot Web开发精解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springsecurity/'
      tabindex="-27">  SpringSecurity</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/unity6xia-jia-zhong-guo-qu-tuan-jie-yin-qing-jie-bang-zhe-shi-fen-lie-huan-shi-ben-di-hua-de-kai-shi/'
      tabindex="-28">  Unity6下架中国区，团结引擎接棒：这是分裂，还是本地化的开始？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-cong-0-dao-1-da-zao-quan-yu-yan-zhi-chi-de-mo-neng-bian-ji-qi-yu-fa-pian/'
      tabindex="-29">  Vim从0到1打造全语言支持的万能编辑器-语法篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-tiao-tou-powershell-pian/'
      tabindex="-30">  Vim折腾之 PowerShell篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-di-zhi-chuan-di-xiang-jie/'
      tabindex="-31">  [C++游戏开发基础]:地址传递详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-yin-yong-fan-hui-he-di-zhi-fan-hui/'
      tabindex="-32">  [C++游戏开发基础]:引用返回和地址返回</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-he-const/'
      tabindex="-33">  [C++游戏开发基础]:指针和const</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shu-ju-feng-zhuang-yin-cang-de-hao-chu/'
      tabindex="-34">  [C++游戏开发基础]:数据封装(隐藏)的好处</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-gou-zao-han-shu-qian-xi-8000zi/'
      tabindex="-35">  [C++游戏开发基础]:构造函数浅析(8000字)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-li-jie-kong-zhi-zhen/'
      tabindex="-36">  [C++游戏开发基础]:理解空指针</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-zhong-de-fang-wen-han-shu/'
      tabindex="-37">  [C++游戏开发基础]:类中的访问函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-de-ji-ben-gai-nian-li-jie/'
      tabindex="-38">  [C++游戏开发基础]指针的基本概念理解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/fanatical-wu-yue-feng-kuang-te-hui-wei-ni-de-steam-ku-jia-dian-liao/'
      tabindex="-39">  _Fanatical 五月疯狂特惠：为你的 Steam 库加点料！</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-kai-yuan-mi-ma-gong-ju-xpwd-zhong-wen-ban-bian-geng-ri-zhi/'
      tabindex="-40">  _Rust开源密码工具xpwd中文版变更日志</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/readme/'
      tabindex="-41">  readme</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wblog-bo-ke-xian-shang-bu-shu/'
      tabindex="-42">  wblog博客线上部署</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/shang-gu-shen-qi-vim-su-cheng-bei-wang-lu/'
      tabindex="-43">  上古神器_Vim速成备忘录</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mian-fei-ji-huo-quan-ban-ben-typora-zui-xin-ban-wei-li/'
      tabindex="-44">  免费激活全版本Typora，最新版为例</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-lombokxian-wei-ren-zhi-de-ji-ge-qi-ji-yin-qiao/'
      tabindex="-45">  关于Lombok鲜为人知的几个奇技淫巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-jie-kou-xian-liu-de-yi-ci-jian-dan-shi-jian/'
      tabindex="-46">  关于接口限流的一次简单实践</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/tu-jie-er-jin-zhi/'
      tabindex="-47">  图解二进制</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ru-he-xie-de-yi-shou-you-ya-gui-fan-de-springboot-jie-kou/'
      tabindex="-48">  如何写得一手优雅规范的SpringBoot 接口？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/kai-fa-bi-hui-xi-lie-jwtqian-tan/'
      tabindex="-49">  开发必会系列_JWT浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ji-qiao-jiu-shi-xiao-lu-chatgpt-diao-jiao-zhi-bei/'
      tabindex="-50">  技巧就是效率，ChatGPT调教指北</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-sheng-intellij-kai-fa-xiao-lu-zhe-kuan-dai-ma-tu-ding-cha-jian-codepins-zhi-de-yi-shi/'
      tabindex="-51">  提升 IntelliJ 开发效率？这款代码图钉插件 CodePins 值得一试</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-wen-de-zhi-hui-zhuan-zai/'
      tabindex="-52">  提问的智慧转载</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiao-lu-gong-ju-markdown/'
      tabindex="-53">  效率工具Markdown</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wu-wei-bing-fa-rust-sheng-ming-zhou-qi-qian-tan/'
      tabindex="-54">  无畏并发_Rust 生命周期浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-yu-de-bei-sai-er-qu-xian-gan-shou-si-hua-de-shu-xue-zhi-mei/'
      tabindex="-55">  游戏开发与的贝塞尔曲线_感受丝滑的数学之美</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-bi-bei-gao-xiao-de-aabb-qiu-ti-he-obb-peng-zhuang-jian-ce-suan-fa/'
      tabindex="-56">  游戏开发必备：高效的 AABB、球体和 OBB 碰撞检测算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-suan-fa-ji-chu-a-xun-lu-suan-fa-chi-xu-wei-hu/'
      tabindex="-57">  游戏算法基础-深入解析A*寻路算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/du-li-you-xi-kai-fa-zhe-gong-ju-xiang-2025jing-xuan-tui-jian-yu-shi-yong-zhi-nan/'
      tabindex="-58">  独立游戏开发者工具箱：2025精选推荐与实用指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xu-huan-yin-qing-you-xi-kai-fa-xi-lie-zhuan-ti-guan-fang-bian-ma-biao-zhun-huo-gui-yue/'
      tabindex="-59">  虚幻引擎游戏开发系列专题-官方编码标准或规约</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiang-jie-she-ji-mo-shi-dan-li-de-jin-hua-zhi-lu/'
      tabindex="-60">  详解设计模式_单例的进化之路</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xie-e-de-fei-chang-liang-quan-ju-bian-liang/'
      tabindex="-61">  邪恶的非常量全局变量</a></span>
  </li>
</ul>
</div>
      <div class="viewer page" id="viewer" tabindex="0">
        <div class="tab">
<div class="file-manager" onclick='document.getElementById("files").classList.toggle("open"); document.getElementById("content").classList.toggle("close")'> </div>
<ul id="tabs">
</ul>


</div>
        <div class="content" id="content"><p>在Rust中，“move 语义” 涉及将所有权（ownership）从一个变量转移到另一个变量的概念。当将一个值赋给另一个变量时，默认情况下会发生移动操作，这意味着原始变量不再拥有该值，而新变量成为该值的所有者。这种操作可以防止数据竞争和内存安全问题，并在编译时捕获潜在的错误。Move 语义是 Rust 的核心概念之一，有助于确保代码的安全性和并发性，因此，非常有必要单独拎出来强化强化。</p>
<hr />
<h2 id="1-mo-ren-yi-dong">1. 默认移动</h2>
<p>默认移动意味着在<code>Rust</code>中，当你将一个值分配给另一个新变量或者说作为参数传递到函数中时这个过程使用的是<code>move</code>而非<code>clone</code>.这代表者该值的所有权也会随之被转移到新的变量中。</p>
<p>考虑下面的代码：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">struct </span><span>Hi {
</span><span>    </span><span style="color:#bf616a;">message</span><span>: String,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> h1 = Hi {
</span><span>        message: String::from(&quot;</span><span style="color:#a3be8c;">Hello!</span><span>&quot;),
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> h2 = h1;
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">h1:</span><span style="color:#d08770;">{}</span><span>&quot;, h1.message);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">h2:</span><span style="color:#d08770;">{}</span><span>&quot;, h2.message);
</span><span>}
</span></code></pre>
<p><img src="https://images.waer.ltd/notes/image-20240529110455074.png" alt="image-20240529110455074" loading="lazy" decoding="async" /></p>
<p>上面的代码中，我们创建了一个结构体，在第一步（箭头）中，执行了<code>h2=h1</code>时，此时<code>h1</code>的所有权就已经被移动到了<code>h2</code>中，<code>h1</code>随之失效，当我们再次使用<code>h1</code>时会编译失败。</p>
<p><img src="https://images.waer.ltd/notes/image-20240529110802394.png" alt="image-20240529110802394" loading="lazy" decoding="async" /></p>
<blockquote>
<p>这些操作都是<code>Rust</code>中默认的。</p>
</blockquote>
<hr />
<h2 id="">2. 作为函数参数时</h2>
<p>当我们将 <code>struct </code>实例作为参数传递给函数时，该 <code>struct </code>被移动到函数中。这意味着传递的原始变量不再有效，不能再次使用。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">struct </span><span>User {
</span><span>    </span><span style="color:#bf616a;">name</span><span>: String,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">say</span><span>(</span><span style="color:#bf616a;">user</span><span>: User) {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Hi,</span><span style="color:#d08770;">{}</span><span>&quot;, user.name);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> user = User {
</span><span>        name: String::from(&quot;</span><span style="color:#a3be8c;">马超</span><span>&quot;),
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#96b5b4;">say</span><span>(user);
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">user:</span><span style="color:#d08770;">{:?}</span><span>&quot;, user);
</span><span>}
</span></code></pre>
<p>我们定义了一个<code>User</code>结构体，并创建了一个函数<code>say</code>，它的参数就是这个结构体。函数功能很简单，就是打印结构体中字段的内容。</p>
<p>在主函数中，构建了<code>User</code>结构体之后将它传递给函数使用。这之后，我们尝试打印这个结构体，但是编译无法通过，这是因为我们的结构体的所有权已经转移到了函数中，不能被再次使用。</p>
<p>那么，如果我们还是需要继续这个结构体怎么办呢？可以通过使用引用传递参数的方式，或者说使用<code>clone</code>，这样可以避免所有权的转移。</p>
<ul>
<li>传递引用</li>
</ul>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span style="color:#b48ead;">struct </span><span>User {
</span><span>    </span><span style="color:#bf616a;">name</span><span>: String,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">say</span><span>(</span><span style="color:#bf616a;">user</span><span>: &amp;User) {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Hi,</span><span style="color:#d08770;">{}</span><span>&quot;, user.name);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> user = User {
</span><span>        name: String::from(&quot;</span><span style="color:#a3be8c;">马超</span><span>&quot;),
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#96b5b4;">say</span><span>(&amp;user);
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">user:</span><span style="color:#d08770;">{:?}</span><span>&quot;, user);
</span><span>}
</span></code></pre>
<ul>
<li>clone</li>
</ul>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug, Clone)]
</span><span style="color:#b48ead;">struct </span><span>User {
</span><span>    </span><span style="color:#bf616a;">name</span><span>: String,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">say</span><span>(</span><span style="color:#bf616a;">user</span><span>: User) {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Hi,</span><span style="color:#d08770;">{}</span><span>&quot;, user.name);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> user = User {
</span><span>        name: String::from(&quot;</span><span style="color:#a3be8c;">马超</span><span>&quot;),
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#96b5b4;">say</span><span>(user.</span><span style="color:#96b5b4;">clone</span><span>());
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">user:</span><span style="color:#d08770;">{:?}</span><span>&quot;, user);
</span><span>}
</span></code></pre>
<hr />
<h2 id="-1">3. 返回中的转移</h2>
<p>在Rust中，当一个函数返回一个结构体时，结构体的所有权会从函数的作用域转移到调用作用域。这意味着结构体从函数的作用域移动到调用作用域。以下是一个示例来演示这种行为：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span style="color:#b48ead;">struct </span><span>MyStruct {
</span><span>    </span><span style="color:#bf616a;">data</span><span>: String,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">create_struct</span><span>() -&gt; MyStruct {
</span><span>    </span><span style="color:#b48ead;">let</span><span> data = String::from(&quot;</span><span style="color:#a3be8c;">Hello</span><span>&quot;);
</span><span>    MyStruct { data }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> my_struct = </span><span style="color:#96b5b4;">create_struct</span><span>();
</span><span>    println!(&quot;</span><span style="color:#d08770;">{:?}</span><span>&quot;, my_struct); </span><span style="color:#65737e;">// 这行代码可以正常工作
</span><span>
</span><span>    </span><span style="color:#65737e;">// 下面这行代码会导致编译错误，因为my_struct已经被移动
</span><span>    </span><span style="color:#65737e;">// println!(&quot;{:?}&quot;, my_struct);
</span><span>}
</span></code></pre>
<p>在这个示例中，<code>create_struct</code>函数创建一个<code>MyStruct</code>实例并返回它。当在<code>main</code>函数中将<code>my_struct</code>赋值为<code>create_struct</code>的返回值时，结构体的所有权转移到了<code>my_struct</code>。因此，你可以打印<code>my_struct</code>一次，但如果在结构体已经被移动后尝试再次使用<code>my_struct</code>，将会导致编译错误。</p>
<p>如果您需要在函数调用后继续使用结构体，可以返回结构体的引用而不是结构体本身。这样，所有权不会被转移，原始结构体仍然有效。</p>
<hr />
<h2 id="-2">4. Move关键字</h2>
<p><code>move</code>关键字会显式的触发所有权的强制转移。注意，这里说的是转移、而不是复制。</p>
<p>举个<code>move</code>在闭包中使用的栗子：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">do_sth</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> x = String::from(&quot;</span><span style="color:#a3be8c;">Hello</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> y = String::from(&quot;</span><span style="color:#a3be8c;">World</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> closure = </span><span style="color:#b48ead;">move </span><span>|| {
</span><span>        println!(&quot;</span><span style="color:#d08770;">{} {}</span><span>&quot;, x, y);
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#96b5b4;">closure</span><span>();
</span><span>
</span><span>    </span><span style="color:#65737e;">// println!(&quot;x :{}&quot;, x);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#96b5b4;">do_sth</span><span>();
</span><span>}
</span></code></pre>
<blockquote>
<ol>
<li><strong>定义 <code>do_sth</code> 函数</strong>：
<ul>
<li>函数 <code>do_sth</code> 定义了两个可变字符串变量 <code>x</code> 和 <code>y</code>，分别初始化为 <code>"Hello"</code> 和 <code>"World"</code>。</li>
</ul>
</li>
<li><strong>创建并立即执行带 <code>move</code> 的闭包</strong>：
<ul>
<li>在 <code>do_sth</code> 函数内部，定义了一个匿名闭包（通过 <code>|| { ... }</code> 形式）并赋值给了变量 <code>closure</code>。</li>
<li>闭包前面的 <code>move</code> 关键字是重点。它指示闭包在其被调用时，会“移动”捕获的变量（在这里是 <code>x</code> 和 <code>y</code>）的所有权进入闭包内部，而不是仅仅借用它们。这意味着一旦闭包执行完毕，原始变量 <code>x</code> 和 <code>y</code> 将不再可用，因为它们的所有权已经被转移给了闭包。</li>
<li>闭包体内的代码是打印 <code>x</code> 和 <code>y</code> 的内容。</li>
</ul>
</li>
<li><strong>调用闭包</strong>：
<ul>
<li>通过 <code>closure();</code> 来执行这个闭包，输出结果为 <code>"Hello World"</code>。</li>
</ul>
</li>
<li><strong>注释掉的 println!</strong>：
<ul>
<li>之后有一行被注释掉的代码 <code>// println!("x :{}", x);</code>。由于闭包使用了 <code>move</code>，变量 <code>x</code> 和 <code>y</code> 的所有权已经被转移给闭包，所以在闭包执行后，尝试访问 <code>x</code> 会引发编译错误，因为 <code>x</code> 已不再有效。</li>
</ul>
</li>
<li><strong>在 <code>main</code> 函数中调用 <code>do_sth</code></strong>：
<ul>
<li><code>main</code> 函数简单调用了 <code>do_sth()</code>，执行上述过程。最终程序输出 <code>"Hello World"</code>，且不会尝试访问已被移动的变量。</li>
</ul>
</li>
</ol>
</blockquote>
<hr />
<h2 id="-3">5. Copy trait</h2>
<p>在<code>Rust</code>中，某些类型是默认实现了<code>Copy trait</code>的，这意味着他们的值在被移动是发生的是复制，源值将保留不变。这些类型包括了诸如整数、浮点、布尔、字符等基本数据类型；</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> x = </span><span style="color:#d08770;">3</span><span>;
</span><span>    </span><span style="color:#b48ead;">let</span><span> y = x;
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">x is </span><span style="color:#d08770;">{}</span><span>&quot;, x);
</span><span>}
</span></code></pre>
<p>上面的代码中，虽然我们执行了<code>y=x</code>的赋值操作，但由于基本类型实现了<code>Copy trait</code>,所以源值<code>x</code>还是3；</p>
<p>与之对比的是没有实现<code>Copy trait</code> 的<code>String</code>类型；</p>
<p>``rust
fn main() {
let x = 3;
let y = x;</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>println!(&quot;x is {}&quot;, x);
</span></code></pre>
<p>}</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>
</span><span>![image-20240529164255374](https://images.waer.ltd/notes/image-20240529164255374.png)
</span><span>
</span><span>&gt; 在这里， 操作`y = x` 执行后 `x`被移动 。 `x` 移动后不再有效。并且编译报错信息也给出了提示，该类型没有实现`Copy trait`;
</span><span>
</span><span>注意，任何完全由复制类型组成的类型也是具有`Copy`属性的。 例如：
</span><span>
</span><span>```rust
</span><span>#[derive(Debug, Copy, Clone)]
</span><span>struct Point {
</span><span>    x: i32,
</span><span>    y: i32,
</span><span>}
</span><span>
</span><span>fn main() {
</span><span>    let origin = Point { x: 1, y: 2 };
</span><span>
</span><span>    let point = origin;
</span><span>
</span><span>    println!(&quot;origin is {:?}&quot;, origin);
</span><span>}
</span></code></pre>
<blockquote>
<p>上述例子中，由于结构体中的字段都是<code>i32</code>的整型，而整型默认实现了<code>Copy trait</code>，此时这个结构体也默认拥有了该特性，当我们执行了<code>let point = origin;</code>之后打印<code>origin</code>的值依旧是原来的结构体，说明它执行了复制操作。</p>
</blockquote>
<hr />
<h2 id="-4">6. 小结</h2>
<p><code>Rust</code>中采取移动的一些优势：</p>
<ul>
<li>性能：移动不需要值得副本，因此速度很快。</li>
<li>内存：如果不移动，则每当传递或者重新分配值时，就需要更多得内存分配；</li>
<li>唯一性：移动可以强制保持所有权得惟一，确定在给定时间只有一个变量拥有该值，也为内存安全提供了保证；</li>
</ul>

        </div>
      </div>
      <div class="prompt" id="terminal"><input
    type="text"
    id="setter"
    onkeydown="writeit(this, event);moveIt(this.value.length, event)"
    onchange="writeit(this, event)"
    onkeyup="writeit(this, event)"
    onkeypress="writeit(this, event);"
    >
<label for="setter" id="writer"> </label><b class="cursor" id="cursor"></b></div>
      <footer class="footer">
        <div class="footer-content">
          <p class="icp-info">
            <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer">黔ICP备2021010295号</a>
          </p>
        </div>
      </footer>
    </main>
  </body>

</html>
