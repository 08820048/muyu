<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>慕予博客</title>
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"
    integrity="sha256-WCzAhd2P6gRJF9Hv3oOOd+hFJi/QJbv+Azn4CGB8gfY=" crossorigin="anonymous" defer></script>
  <script src="/js/index.js" defer></script>
  <script src="/js/prompt.js" defer></script>
  <script src="/js/keyboard.js" defer></script>
  <script src="/js/tab.js" defer></script>
  <script src="/js/commands.js" defer></script>
  <script src="/js/config.js" defer></script><script src="/config.js"></script><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="style.css"><link rel="stylesheet" href="/css/page.css"></head><body onkeydown='exec(event)' style='background-image: url("/assets/background.jpg");'><main>
      <div class="files" id="files" tabindex="0">
<ul>

  <li class="file">
    <span><a href='https://ilikexff.cn/8-kuan-rang-ni-kai-fa-qi-fei-de-intellijidea-cha-jian/'
      tabindex="-2">  8款让你开发起飞的IntellijIDEA插件</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/aop-jie-mi-qie-mian-bian-cheng-de-zong-he-zhi-nan/'
      tabindex="-3">  AOP揭秘：切面编程的综合指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-mei-ju-pian-yi-wu-fan-wei-mei-ju/'
      tabindex="-4">  C++游戏开发基础-枚举篇一：无范围枚举</a></span>
  </li><li class="file">
    <span><a class="selected"href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-std-optional/'
      tabindex="-5">  C++游戏开发基础-深入解析std::optional</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shen-ru-jie-xi-thiszhi-zhen-de-ying-yong-yu-ji-qiao/'
      tabindex="-6">  C++游戏开发基础-深入解析this指针的应用与技巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-fu-zhi-gou-zao-han-shu/'
      tabindex="-7">  C++游戏开发基础-深入解析复制构造函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-mo-ban-he-can-shu-tui-dao-zhi-nan/'
      tabindex="-8">  C++游戏开发基础-类模版和参数推导指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/dockerbi-zhi-bi-hui/'
      tabindex="-9">  Docker必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/githithub-xiao-ce/'
      tabindex="-10">  GitGitHub小册</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/google-hacking/'
      tabindex="-11">  Google Hacking</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/googleguan-fang-ti-shi-gong-cheng-bai-pi-shu-zhong-wen-yi-ben/'
      tabindex="-12">  Google官方《提示工程白皮书（中文译本）》</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-dai-ma-bu-quan-ti-shi-gong-neng-xiao-shi-de-ji-chong-jie-jue-fang-an-re-geng-ban/'
      tabindex="-13">  IDEA代码补全&amp;提示功能消失的几种解决方案(热更版)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-chen-jin-shi-bian-cheng-ti-yan/'
      tabindex="-14">  IDEA沉浸式编程体验</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-han-shu-shi-bian-cheng/'
      tabindex="-15">  Java函数式编程</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-ji-he-yuan-ma-qian-xi/'
      tabindex="-16">  Java集合源码浅析</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mysql-shi-wu-te-xing-yu-ge-chi-ji-bie-xiang-jie/'
      tabindex="-17">  MySQL_事务特性与隔离级别详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ocao-zuo-fu-shi-xian-mei-ju-de-shu-ru-shu-chu/'
      tabindex="-18">  O操作符,实现枚举的输入输出</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/prdsuan-fa-ting-shuo-ni-xiang-ping-yun-qi-chou-yi-ke-rong-yao-shui-jing/'
      tabindex="-19">  PRD算法：听说你想凭运气抽一颗荣耀水晶?</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/picgo-pei-zhi-ge-chong-tu-chuang/'
      tabindex="-20">  PicGo配置各种图床</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/redis-bi-zhi-bi-hui/'
      tabindex="-21">  Redis必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-zhong-de-move-yu-yi-sui-bi/'
      tabindex="-22">  Rust中的move语义随笔</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ssm-kuang-jia-shi-xian-ji-cheng-duan-xin-yan-zheng-ma-gong-neng/'
      tabindex="-23">  SSM框架实现集成短信验证码功能</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/slf4jyu-logbackshi-yong-zhi-nan-ji-yu-gradle/'
      tabindex="-24">  Slf4j与Logback实用指南(基于Gradle)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/spring-security5-xdao-spring-security6-xde-qian-yi/'
      tabindex="-25">  Spring Security5.x到Spring Security6.x的迁移</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springboot-webkai-fa-jing-jie/'
      tabindex="-26">  SpringBoot Web开发精解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springsecurity/'
      tabindex="-27">  SpringSecurity</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/unity6xia-jia-zhong-guo-qu-tuan-jie-yin-qing-jie-bang-zhe-shi-fen-lie-huan-shi-ben-di-hua-de-kai-shi/'
      tabindex="-28">  Unity6下架中国区，团结引擎接棒：这是分裂，还是本地化的开始？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-cong-0-dao-1-da-zao-quan-yu-yan-zhi-chi-de-mo-neng-bian-ji-qi-yu-fa-pian/'
      tabindex="-29">  Vim从0到1打造全语言支持的万能编辑器-语法篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-tiao-tou-powershell-pian/'
      tabindex="-30">  Vim折腾之 PowerShell篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-di-zhi-chuan-di-xiang-jie/'
      tabindex="-31">  [C++游戏开发基础]:地址传递详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-yin-yong-fan-hui-he-di-zhi-fan-hui/'
      tabindex="-32">  [C++游戏开发基础]:引用返回和地址返回</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-he-const/'
      tabindex="-33">  [C++游戏开发基础]:指针和const</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shu-ju-feng-zhuang-yin-cang-de-hao-chu/'
      tabindex="-34">  [C++游戏开发基础]:数据封装(隐藏)的好处</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-gou-zao-han-shu-qian-xi-8000zi/'
      tabindex="-35">  [C++游戏开发基础]:构造函数浅析(8000字)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-li-jie-kong-zhi-zhen/'
      tabindex="-36">  [C++游戏开发基础]:理解空指针</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-zhong-de-fang-wen-han-shu/'
      tabindex="-37">  [C++游戏开发基础]:类中的访问函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-de-ji-ben-gai-nian-li-jie/'
      tabindex="-38">  [C++游戏开发基础]指针的基本概念理解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/fanatical-wu-yue-feng-kuang-te-hui-wei-ni-de-steam-ku-jia-dian-liao/'
      tabindex="-39">  _Fanatical 五月疯狂特惠：为你的 Steam 库加点料！</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-kai-yuan-mi-ma-gong-ju-xpwd-zhong-wen-ban-bian-geng-ri-zhi/'
      tabindex="-40">  _Rust开源密码工具xpwd中文版变更日志</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/readme/'
      tabindex="-41">  readme</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wblog-bo-ke-xian-shang-bu-shu/'
      tabindex="-42">  wblog博客线上部署</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/shang-gu-shen-qi-vim-su-cheng-bei-wang-lu/'
      tabindex="-43">  上古神器_Vim速成备忘录</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mian-fei-ji-huo-quan-ban-ben-typora-zui-xin-ban-wei-li/'
      tabindex="-44">  免费激活全版本Typora，最新版为例</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-lombokxian-wei-ren-zhi-de-ji-ge-qi-ji-yin-qiao/'
      tabindex="-45">  关于Lombok鲜为人知的几个奇技淫巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-jie-kou-xian-liu-de-yi-ci-jian-dan-shi-jian/'
      tabindex="-46">  关于接口限流的一次简单实践</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/tu-jie-er-jin-zhi/'
      tabindex="-47">  图解二进制</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ru-he-xie-de-yi-shou-you-ya-gui-fan-de-springboot-jie-kou/'
      tabindex="-48">  如何写得一手优雅规范的SpringBoot 接口？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/kai-fa-bi-hui-xi-lie-jwtqian-tan/'
      tabindex="-49">  开发必会系列_JWT浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ji-qiao-jiu-shi-xiao-lu-chatgpt-diao-jiao-zhi-bei/'
      tabindex="-50">  技巧就是效率，ChatGPT调教指北</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-sheng-intellij-kai-fa-xiao-lu-zhe-kuan-dai-ma-tu-ding-cha-jian-codepins-zhi-de-yi-shi/'
      tabindex="-51">  提升 IntelliJ 开发效率？这款代码图钉插件 CodePins 值得一试</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-wen-de-zhi-hui-zhuan-zai/'
      tabindex="-52">  提问的智慧转载</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiao-lu-gong-ju-markdown/'
      tabindex="-53">  效率工具Markdown</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wu-wei-bing-fa-rust-sheng-ming-zhou-qi-qian-tan/'
      tabindex="-54">  无畏并发_Rust 生命周期浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-yu-de-bei-sai-er-qu-xian-gan-shou-si-hua-de-shu-xue-zhi-mei/'
      tabindex="-55">  游戏开发与的贝塞尔曲线_感受丝滑的数学之美</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-bi-bei-gao-xiao-de-aabb-qiu-ti-he-obb-peng-zhuang-jian-ce-suan-fa/'
      tabindex="-56">  游戏开发必备：高效的 AABB、球体和 OBB 碰撞检测算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-suan-fa-ji-chu-a-xun-lu-suan-fa-chi-xu-wei-hu/'
      tabindex="-57">  游戏算法基础-深入解析A*寻路算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/du-li-you-xi-kai-fa-zhe-gong-ju-xiang-2025jing-xuan-tui-jian-yu-shi-yong-zhi-nan/'
      tabindex="-58">  独立游戏开发者工具箱：2025精选推荐与实用指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xu-huan-yin-qing-you-xi-kai-fa-xi-lie-zhuan-ti-guan-fang-bian-ma-biao-zhun-huo-gui-yue/'
      tabindex="-59">  虚幻引擎游戏开发系列专题-官方编码标准或规约</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiang-jie-she-ji-mo-shi-dan-li-de-jin-hua-zhi-lu/'
      tabindex="-60">  详解设计模式_单例的进化之路</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xie-e-de-fei-chang-liang-quan-ju-bian-liang/'
      tabindex="-61">  邪恶的非常量全局变量</a></span>
  </li>
</ul>
</div>
      <div class="viewer page" id="viewer" tabindex="0">
        <div class="tab">
<div class="file-manager" onclick='document.getElementById("files").classList.toggle("open"); document.getElementById("content").classList.toggle("close")'> </div>
<ul id="tabs">
</ul>


</div>
        <div class="content" id="content"><p>考虑下面这样一个函数:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">doIntDivision</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span>, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">y</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">return</span><span> x / y;
</span><span>}
</span></code></pre>
<p>如果调用者传入一个语义上无效的值（例如 <code>y</code> = <code>0</code> ），此函数无法计算一个返回值（因为除以 0 在数学上是未定义的）。在这种情况下我们该怎么办？</p>
<p>这种情况下,通常的做法是让函数检测错误,然后将错误返回给调用者以适当的方式处理。比如;</p>
<ul>
<li>函数返回一个bool值类型,表示成功或者失败!</li>
<li>让一个有返回值的函数返回一个哨兵值（一个特殊的值，该值不会出现在函数可能返回的其他值的集合中），以此来指示错误。</li>
</ul>
<p>以下示例中， <code>reciprocal()</code> 函数在用户为 <code>x</code> 传递语义上无效的参数时返回值 <code>0.0</code> （这种情况在其他情况下不会发生）</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">double </span><span style="color:#8fa1b3;">reciprocal</span><span>(</span><span style="color:#b48ead;">double </span><span style="color:#bf616a;">x</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">if </span><span>(x == </span><span style="color:#d08770;">0.0</span><span>) </span><span style="color:#65737e;">// 如果x在语义上无效
</span><span>       </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0.0</span><span>; </span><span style="color:#65737e;">// 返回0.0作为前哨指示发生错误的哨兵标识
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1.0 </span><span>/ x;
</span><span>}
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">testReciprocal</span><span>(</span><span style="color:#b48ead;">double </span><span style="color:#bf616a;">d</span><span>)
</span><span>{
</span><span>     </span><span style="color:#b48ead;">double </span><span style="color:#bf616a;">result </span><span>{ </span><span style="color:#bf616a;">reciprocal</span><span>(d) };
</span><span>     std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">The reciprocal of </span><span>&quot; &lt;&lt; d &lt;&lt; &quot;</span><span style="color:#a3be8c;"> is </span><span>&quot;;
</span><span>     </span><span style="color:#b48ead;">if </span><span>(result != </span><span style="color:#d08770;">0.0</span><span>)
</span><span>         std::cout &lt;&lt; result &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>     </span><span style="color:#b48ead;">else
</span><span>         std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">undefined</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#bf616a;">testReciprocal</span><span>(</span><span style="color:#d08770;">5.0</span><span>);
</span><span>    </span><span style="color:#bf616a;">testReciprocal</span><span>(-</span><span style="color:#d08770;">4.0</span><span>);
</span><span>    </span><span style="color:#bf616a;">testReciprocal</span><span>(</span><span style="color:#d08770;">0.0</span><span>);
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>尽管这是一个不错的解决方案,但也存在一些潜在的不足:</p>
<ul>
<li>作为程序员必须知道函数使用哪个哨兵值来表示错误;</li>
<li>同一个函数的不同版本可能会使用不同的哨兵值;</li>
<li>此方法不适用于所有可能的哨兵值都是有效返回值的函数。</li>
</ul>
<p>再考虑我们上面的 <code>doIntDivision()</code> 函数。如果用户传入 <code>0</code> 作为 <code>y</code> 的值，它可能返回什么值？我们不能使用 <code>0</code> ，因为 <code>0</code> 除以任何数都不会得到 <code>0</code> 作为有效结果。实际上，并不存在我们无法返回且无法自然出现的值。</p>
<p>那么,如果要使用哨兵值表示法,我们可以选择一些不常见的返回值作为哨兵,并用它来表示错误信息的标识;比如,采用指定类型的极值。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">limits</span><span>&gt;
</span><span>
</span><span>std::optional&lt;</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#8fa1b3;">doIntDivision</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">a</span><span>,</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">b</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">if</span><span>(b == </span><span style="color:#d08770;">0</span><span>)
</span><span>        </span><span style="color:#b48ead;">return</span><span> std::numeric_limits&lt;</span><span style="color:#b48ead;">int</span><span>&gt;::</span><span style="color:#bf616a;">lowest</span><span>();
</span><span>    </span><span style="color:#b48ead;">return</span><span> a / b;
</span><span>}
</span></code></pre>
<p><code>std::numeric_limits&lt;T&gt;::lowest()</code> 是一个返回类型 <code>T</code> 的最负值的函数,相对应的还有<code>std::numeric_limits&lt;T&gt;::max()</code> 对应函数（<code>std::numeric_limits&lt;T&gt;::max()</code> 函数返回类型 <code>T</code> 的最大正值）</p>
<p>在上面的实例中,如果 <code>doIntDivision()</code> 无法继续执行，我们返回 <code>std::numeric_limits&lt;int&gt;::lowest()</code> ，这将返回最负的整数值给调用者以指示函数执行失败。</p>
<p>虽然这是可行的一种方式,当它存在两个缺点:</p>
<ul>
<li>每次调用这个函数时，都需要测试返回值是否与 <code>std::numeric_limits&lt;int&gt;::lowest()</code> 相等以判断是否失败。这既繁琐又难看。</li>
<li>考虑这样一种情况,如果用户调用 <code>doIntDivision(std::numeric_limits&lt;int&gt;::lowest(), 1)</code> ，返回的结果 <code>std::numeric_limits&lt;int&gt;::lowest()</code> 将无法明确地表明函数是成功还是失败。当然这种问题的出现取决于实际的使用方式,也许出现的几率不是很大,但不得不作为一个可能导致程序出现一些潜在危险的途径。</li>
</ul>
<p>其次,你可能也想到了,我们可以放弃使用这种返回哨兵值的方式来标识错误返回,并使用异常机制来进行。然而,异常本身也有其复杂性和性能开销,并不一定合适每一种类似的场景,起码对于我们正在讨论的这种情况来说未免有些过于繁琐了。</p>
<hr />
<h2 id="std-optional">std::optional</h2>
<p>基于上面讨论的情况和各种解决方案,你可能也想到了,既然使用返回单个哨兵值的方式存在局限,那么我们是不是可以考虑返回两个值呢?一个用来标识函数是否成功,一个用于存储实际的返回值(取决于函数的执行结果)。</p>
<p>在C++17中引入了<code>std::optional</code>,这是一个类模版类型,实现了 可选值。也即是说,一个 <code>std::optional&lt;T&gt;</code> 可以有类型为T的值,或者没有值。我们可以使用这个特性来实现上面这种双返回值的方案。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">optional</span><span>&gt; </span><span style="color:#65737e;">// for std::optional (C++17)
</span><span>
</span><span>
</span><span>std::optional&lt;</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#8fa1b3;">doIntDivision</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">a</span><span>, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">b</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">if </span><span>(b == </span><span style="color:#d08770;">0</span><span>)
</span><span>        </span><span style="color:#b48ead;">return </span><span>{}; </span><span style="color:#65737e;">// or return std::nullopt
</span><span>    </span><span style="color:#b48ead;">return</span><span> a / b;
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    std::optional&lt;</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">result1 </span><span>{ </span><span style="color:#bf616a;">doIntDivision</span><span>(</span><span style="color:#d08770;">20</span><span>, </span><span style="color:#d08770;">5</span><span>) };
</span><span>    </span><span style="color:#b48ead;">if </span><span>(result1) 
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Result 1: </span><span>&quot; &lt;&lt; *result1 &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;; 
</span><span>    </span><span style="color:#b48ead;">else
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Result 1: failed</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>
</span><span>    std::optional&lt;</span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">result2 </span><span>{ </span><span style="color:#bf616a;">doIntDivision</span><span>(</span><span style="color:#d08770;">5</span><span>, </span><span style="color:#d08770;">0</span><span>) };
</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span>(result2)
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Result 2: </span><span>&quot; &lt;&lt; *result2 &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>    </span><span style="color:#b48ead;">else
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Result 2: failed</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>使用 <code>std::optional</code> 非常容易。我们可以使用下面三种方式来初始化构造一个 <code>std::optional&lt;T&gt;</code> ：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>std::optional&lt;</span><span style="color:#b48ead;">int</span><span>&gt; o1 {</span><span style="color:#d08770;">6</span><span>};
</span><span>std::optional&lt;</span><span style="color:#b48ead;">int</span><span>&gt; o2 {};
</span><span>std::optional&lt;</span><span style="color:#b48ead;">int</span><span>&gt; o3 {std::nullopt};
</span></code></pre>
<p>要检查一个<code>std::optional</code>是否有值,我们可以选择下面方式之一:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">if </span><span>(o1.</span><span style="color:#bf616a;">has_value</span><span>()) </span><span style="color:#65737e;">// 1.使用has_value()函数检查
</span><span style="color:#b48ead;">if</span><span>(o2) </span><span style="color:#65737e;">//2.使用隐式转换进行bool以检查O2是否具有值  
</span></code></pre>
<p>同样,要从<code>std::optional</code>中获取值,我们可以选择以下方式之一:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>std::cout &lt;&lt; *o1; </span><span style="color:#65737e;">//1. 解引用以获取存储在 o1 中的值（如果 o1 中没有值，则会导致未定义行为）。
</span><span>std::cout &lt;&lt; o2.</span><span style="color:#bf616a;">value</span><span>(); </span><span style="color:#65737e;">//2. 调用 value() 以获取存储在 o2 中的值（如果 o2 中没有值，则会抛出 std::bad_optional_access 异常）。
</span><span>std::cout &lt;&lt; o3.</span><span style="color:#bf616a;">value_or</span><span>(</span><span style="color:#d08770;">5</span><span>); </span><span style="color:#65737e;">// 3.调用 value_or() 以获取存储在 o3 中的值（如果 o3 中没有值，则返回一个指定的默认值,这里返回5）。
</span></code></pre>
<p><code>std::optional</code>用法看起来和指针有些相似,但是从语义上讲,他们存在不小的差异:</p>
<ul>
<li>指针具有引用语义,意味着它引用其他对象,赋值时复制的是指针,而不是对象。如果我们通过地址返回指针,复制回去的是指针本身而不是被指向的对象。 这就意味着我们不能通过地址返回局部对象,因为这会将该对象的地址复制回调用者,然后该对象会被销毁,导致返回的指针成为悬空指针。下面是一个简单的例子:</li>
</ul>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">int</span><span>* </span><span style="color:#8fa1b3;">getPtr</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">int</span><span> lovalVal = </span><span style="color:#d08770;">10</span><span>;
</span><span>    </span><span style="color:#b48ead;">return </span><span>&amp;localVal;
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">int</span><span>* ptr = </span><span style="color:#bf616a;">getPtr</span><span>();
</span><span>    std::cout &lt;&lt; *ptr &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<ul>
<li><code>std::optional</code> 具有值语义，意味着它实际上包含其值，并且赋值会复制该值。如果我们按值返回一个 <code>std::optional</code> ，那么 <code>std::optional</code> （包括其中包含的值）会被复制回调用者。这意味着我们可以使用 <code>std::optional</code> 从函数返回一个值给调用者。</li>
</ul>
<blockquote>
<p>考虑到这一点，让我们看看我们的示例是如何工作的。我们的 <code>doIntDivision()</code> 现在返回一个 <code>std::optional&lt;int&gt;</code> ，而不是一个 <code>int</code> 。在函数体内，如果我们检测到错误，我们将返回 <code>{}</code> ，这会隐式返回一个 <code>std::optional</code> ，其中不包含任何值。如果我们有一个值，我们将返回该值，这会隐式返回一个 <code>std::optional</code> ，其中包含该值。</p>
<p>在 <code>main()</code> 中，我们使用隐式转换为 bool 来检查我们返回的 <code>std::optional</code> 是否有值。如果有值，我们解引用 <code>std::optional</code> 对象以获取值。如果没有值，我们执行错误条件。</p>
</blockquote>
<hr />
<h2 id="fan-hui-std-optionalde-you-que-dian">返回<code>std::optional</code>的优缺点</h2>
<p>好处多多:</p>
<ul>
<li>
<p>有效使用<code> std::optional</code> 可以明确地表示一个函数可能返回一个值，也可能不返回值。</p>
</li>
<li>
<p>不需要记住哪个值是作为哨兵值返回的;</p>
</li>
<li>
<p>语法简洁直观。</p>
</li>
</ul>
<p>一些缺点:</p>
<ul>
<li>我们必须确保<code>std::optional</code>包含一个值再去执行获取的操作,否则解引用一个不包含值的<code>std::optional</code>将会发生为定义行为。</li>
<li><code>std::optional</code>无法提供关于函数失败原因的信息。</li>
</ul>
<p><strong>最佳实践</strong></p>
<blockquote>
<p>如果需要,请返回一个 <code>std::optional</code> （而不是哨兵值），除非你的函数需要返回有关失败原因的额外信息。</p>
</blockquote>
<hr />
<h2 id="shi-yong-std-optional-zuo-wei-ke-xuan-han-shu-can-shu"><strong>使用</strong> <code>std::optional</code> <strong>作为可选函数参数</strong></h2>
<p>在之前的文章中提到过,如何使用通过地址传递来允许函数接受一个“可选”的参数（即调用者可以传递 <code>nullptr</code> 来表示“没有参数”或一个对象）。然而，这种方法的一个缺点是，非 nullptr 参数必须是 lvalue(左值)（以便其地址可以传递给函数）。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">processValue</span><span>(</span><span style="color:#b48ead;">int</span><span>* </span><span style="color:#bf616a;">ptr</span><span>) {
</span><span>    </span><span style="color:#b48ead;">if </span><span>(ptr) {
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Value: </span><span>&quot; &lt;&lt; *ptr &lt;&lt; std::endl;
</span><span>    } </span><span style="color:#b48ead;">else </span><span>{
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">No value provided.</span><span>&quot; &lt;&lt; std::endl;
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">int</span><span> x = </span><span style="color:#d08770;">10</span><span>;
</span><span>    </span><span style="color:#bf616a;">processValue</span><span>(&amp;x);    </span><span style="color:#65737e;">// 传入一个左值的地址
</span><span>    </span><span style="color:#bf616a;">processValue</span><span>(</span><span style="color:#d08770;">nullptr</span><span>); </span><span style="color:#65737e;">// 传入 nullptr 表示无参数
</span><span>
</span><span>    </span><span style="color:#65737e;">// 错误示例: 传入右值（临时值）的地址
</span><span>    </span><span style="color:#65737e;">// processValue(&amp;5); // 编译错误，5 是一个右值，没有地址
</span><span>}
</span></code></pre>
<p>更好的做法是,使用 <code>std::optional</code> 使参数可选，而不需要依赖 <code>nullptr</code> 和指针传递。例如：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">optional</span><span>&gt;
</span><span>
</span><span style="color:#65737e;">// 打印用户的ID号，如果未提供ID号，则输出“未知”
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">printIDNumber</span><span>(std::optional&lt;</span><span style="color:#b48ead;">const int</span><span>&gt; </span><span style="color:#bf616a;">id </span><span>= std::nullopt)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">if </span><span>(id)
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Your ID number is </span><span>&quot; &lt;&lt; *id &lt;&lt; &quot;</span><span style="color:#a3be8c;">.</span><span style="color:#96b5b4;">\n</span><span>&quot;; </span><span style="color:#65737e;">// 如果提供了ID，解引用并打印
</span><span>    </span><span style="color:#b48ead;">else
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Your ID number is not known.</span><span style="color:#96b5b4;">\n</span><span>&quot;; </span><span style="color:#65737e;">// 如果没有提供ID，输出“未知”
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#bf616a;">printIDNumber</span><span>(); </span><span style="color:#65737e;">// 我们还不知道用户的ID号
</span><span>
</span><span>    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">userid </span><span>{ </span><span style="color:#d08770;">34 </span><span>};
</span><span>    </span><span style="color:#bf616a;">printIDNumber</span><span>(userid); </span><span style="color:#65737e;">// 现在我们知道用户的ID号
</span><span>
</span><span>    </span><span style="color:#bf616a;">printIDNumber</span><span>(</span><span style="color:#d08770;">62</span><span>); </span><span style="color:#65737e;">// 我们也可以传递一个右值
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>这种用法有两个优点;</p>
<ol>
<li>它有效的说明了该参数是可选的。</li>
<li>我们以传递一个右值,因为<code>std::optional</code>会生成一个副本。</li>
</ol>
<blockquote>
<p>然而，因为 <code>std::optional</code> 会复制其参数，当 <code>T</code> 是一个复制成本高的类型（比如 <code>std::string</code> ）时，这就会变得有问题。在使用普通函数参数时，我们通过将参数改为 <code>const lvalue reference</code> 的方式来解决这个问题，这样就不会进行复制。不幸的是，截至 C++23， <code>std::optional</code> 仍然不支持引用。</p>
</blockquote>
<p><code>std::optional&lt;T&gt;</code> 适合用于小而简单的类型（如<code>int、float、enum</code>等）作为可选参数，因为它会将值直接存储在 <code>optional </code>对象内部。</p>
<ul>
<li>
<p>对于较大的对象或复杂类型（如大型结构体、类对象），按值传递（pass by value）会导致拷贝整个对象，可能影响性能。</p>
</li>
<li>
<p>当 <code>T</code> 是复杂对象时，更好的选择是使用指针（<code>const T*</code>），这样只传递对象的地址，而不是对象本身，避免了不必要的拷贝。</p>
</li>
<li>
<p><code>const T*</code> 同样可以使用 <code>nullptr</code> 表示“无值”的情况，实现可选参数的效果。</p>
</li>
</ul>
<p>因此，建议仅在通常会按值传递 <code>T</code> 时，使用 <code>std::optional&lt;T&gt;</code> 作为可选参数。否则，请使用 <code>const T*</code> 。</p>
<p><strong>最佳实践:</strong></p>
<blockquote>
<p>优先使用函数重载处理可选函数参数（如果可能）。否则，对于可选参数，使用 <code>std::optional&lt;T&gt;</code> 。如果 <code>T</code> 的复制代价高昂，请优先使用 <code>const T*</code> 。</p>
</blockquote>

        </div>
      </div>
      <div class="prompt" id="terminal"><input
    type="text"
    id="setter"
    onkeydown="writeit(this, event);moveIt(this.value.length, event)"
    onchange="writeit(this, event)"
    onkeyup="writeit(this, event)"
    onkeypress="writeit(this, event);"
    >
<label for="setter" id="writer"> </label><b class="cursor" id="cursor"></b></div>
      <footer class="footer">
        <div class="footer-content">
          <p class="icp-info">
            <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer">黔ICP备2021010295号</a>
          </p>
        </div>
      </footer>
    </main>
  </body>

</html>
