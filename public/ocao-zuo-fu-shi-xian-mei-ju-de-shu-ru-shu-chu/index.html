<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>慕予博客</title>
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"
    integrity="sha256-WCzAhd2P6gRJF9Hv3oOOd+hFJi/QJbv+Azn4CGB8gfY=" crossorigin="anonymous" defer></script>
  <script src="/js/index.js" defer></script>
  <script src="/js/prompt.js" defer></script>
  <script src="/js/keyboard.js" defer></script>
  <script src="/js/tab.js" defer></script>
  <script src="/js/commands.js" defer></script>
  <script src="/js/config.js" defer></script><script src="/config.js"></script><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="style.css"><link rel="stylesheet" href="/css/page.css"></head><body onkeydown='exec(event)' style='background-image: url("/assets/background.jpg");'><main>
      <div class="files" id="files" tabindex="0">
<ul>

  <li class="file">
    <span><a href='https://ilikexff.cn/8-kuan-rang-ni-kai-fa-qi-fei-de-intellijidea-cha-jian/'
      tabindex="-2">  8款让你开发起飞的IntellijIDEA插件</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/aop-jie-mi-qie-mian-bian-cheng-de-zong-he-zhi-nan/'
      tabindex="-3">  AOP揭秘：切面编程的综合指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-mei-ju-pian-yi-wu-fan-wei-mei-ju/'
      tabindex="-4">  C++游戏开发基础-枚举篇一：无范围枚举</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-std-optional/'
      tabindex="-5">  C++游戏开发基础-深入解析std::optional</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shen-ru-jie-xi-thiszhi-zhen-de-ying-yong-yu-ji-qiao/'
      tabindex="-6">  C++游戏开发基础-深入解析this指针的应用与技巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-fu-zhi-gou-zao-han-shu/'
      tabindex="-7">  C++游戏开发基础-深入解析复制构造函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-mo-ban-he-can-shu-tui-dao-zhi-nan/'
      tabindex="-8">  C++游戏开发基础-类模版和参数推导指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/dockerbi-zhi-bi-hui/'
      tabindex="-9">  Docker必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/githithub-xiao-ce/'
      tabindex="-10">  GitGitHub小册</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/google-hacking/'
      tabindex="-11">  Google Hacking</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/googleguan-fang-ti-shi-gong-cheng-bai-pi-shu-zhong-wen-yi-ben/'
      tabindex="-12">  Google官方《提示工程白皮书（中文译本）》</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-dai-ma-bu-quan-ti-shi-gong-neng-xiao-shi-de-ji-chong-jie-jue-fang-an-re-geng-ban/'
      tabindex="-13">  IDEA代码补全&amp;提示功能消失的几种解决方案(热更版)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-chen-jin-shi-bian-cheng-ti-yan/'
      tabindex="-14">  IDEA沉浸式编程体验</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-han-shu-shi-bian-cheng/'
      tabindex="-15">  Java函数式编程</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-ji-he-yuan-ma-qian-xi/'
      tabindex="-16">  Java集合源码浅析</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mysql-shi-wu-te-xing-yu-ge-chi-ji-bie-xiang-jie/'
      tabindex="-17">  MySQL_事务特性与隔离级别详解</a></span>
  </li><li class="file">
    <span><a class="selected"href='https://ilikexff.cn/ocao-zuo-fu-shi-xian-mei-ju-de-shu-ru-shu-chu/'
      tabindex="-18">  O操作符,实现枚举的输入输出</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/prdsuan-fa-ting-shuo-ni-xiang-ping-yun-qi-chou-yi-ke-rong-yao-shui-jing/'
      tabindex="-19">  PRD算法：听说你想凭运气抽一颗荣耀水晶?</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/picgo-pei-zhi-ge-chong-tu-chuang/'
      tabindex="-20">  PicGo配置各种图床</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/redis-bi-zhi-bi-hui/'
      tabindex="-21">  Redis必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-zhong-de-move-yu-yi-sui-bi/'
      tabindex="-22">  Rust中的move语义随笔</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ssm-kuang-jia-shi-xian-ji-cheng-duan-xin-yan-zheng-ma-gong-neng/'
      tabindex="-23">  SSM框架实现集成短信验证码功能</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/slf4jyu-logbackshi-yong-zhi-nan-ji-yu-gradle/'
      tabindex="-24">  Slf4j与Logback实用指南(基于Gradle)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/spring-security5-xdao-spring-security6-xde-qian-yi/'
      tabindex="-25">  Spring Security5.x到Spring Security6.x的迁移</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springboot-webkai-fa-jing-jie/'
      tabindex="-26">  SpringBoot Web开发精解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springsecurity/'
      tabindex="-27">  SpringSecurity</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/unity6xia-jia-zhong-guo-qu-tuan-jie-yin-qing-jie-bang-zhe-shi-fen-lie-huan-shi-ben-di-hua-de-kai-shi/'
      tabindex="-28">  Unity6下架中国区，团结引擎接棒：这是分裂，还是本地化的开始？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-cong-0-dao-1-da-zao-quan-yu-yan-zhi-chi-de-mo-neng-bian-ji-qi-yu-fa-pian/'
      tabindex="-29">  Vim从0到1打造全语言支持的万能编辑器-语法篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-tiao-tou-powershell-pian/'
      tabindex="-30">  Vim折腾之 PowerShell篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-di-zhi-chuan-di-xiang-jie/'
      tabindex="-31">  [C++游戏开发基础]:地址传递详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-yin-yong-fan-hui-he-di-zhi-fan-hui/'
      tabindex="-32">  [C++游戏开发基础]:引用返回和地址返回</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-he-const/'
      tabindex="-33">  [C++游戏开发基础]:指针和const</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shu-ju-feng-zhuang-yin-cang-de-hao-chu/'
      tabindex="-34">  [C++游戏开发基础]:数据封装(隐藏)的好处</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-gou-zao-han-shu-qian-xi-8000zi/'
      tabindex="-35">  [C++游戏开发基础]:构造函数浅析(8000字)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-li-jie-kong-zhi-zhen/'
      tabindex="-36">  [C++游戏开发基础]:理解空指针</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-zhong-de-fang-wen-han-shu/'
      tabindex="-37">  [C++游戏开发基础]:类中的访问函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-de-ji-ben-gai-nian-li-jie/'
      tabindex="-38">  [C++游戏开发基础]指针的基本概念理解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/fanatical-wu-yue-feng-kuang-te-hui-wei-ni-de-steam-ku-jia-dian-liao/'
      tabindex="-39">  _Fanatical 五月疯狂特惠：为你的 Steam 库加点料！</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-kai-yuan-mi-ma-gong-ju-xpwd-zhong-wen-ban-bian-geng-ri-zhi/'
      tabindex="-40">  _Rust开源密码工具xpwd中文版变更日志</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/readme/'
      tabindex="-41">  readme</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wblog-bo-ke-xian-shang-bu-shu/'
      tabindex="-42">  wblog博客线上部署</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/shang-gu-shen-qi-vim-su-cheng-bei-wang-lu/'
      tabindex="-43">  上古神器_Vim速成备忘录</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mian-fei-ji-huo-quan-ban-ben-typora-zui-xin-ban-wei-li/'
      tabindex="-44">  免费激活全版本Typora，最新版为例</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-lombokxian-wei-ren-zhi-de-ji-ge-qi-ji-yin-qiao/'
      tabindex="-45">  关于Lombok鲜为人知的几个奇技淫巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-jie-kou-xian-liu-de-yi-ci-jian-dan-shi-jian/'
      tabindex="-46">  关于接口限流的一次简单实践</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/tu-jie-er-jin-zhi/'
      tabindex="-47">  图解二进制</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ru-he-xie-de-yi-shou-you-ya-gui-fan-de-springboot-jie-kou/'
      tabindex="-48">  如何写得一手优雅规范的SpringBoot 接口？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/kai-fa-bi-hui-xi-lie-jwtqian-tan/'
      tabindex="-49">  开发必会系列_JWT浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ji-qiao-jiu-shi-xiao-lu-chatgpt-diao-jiao-zhi-bei/'
      tabindex="-50">  技巧就是效率，ChatGPT调教指北</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-sheng-intellij-kai-fa-xiao-lu-zhe-kuan-dai-ma-tu-ding-cha-jian-codepins-zhi-de-yi-shi/'
      tabindex="-51">  提升 IntelliJ 开发效率？这款代码图钉插件 CodePins 值得一试</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-wen-de-zhi-hui-zhuan-zai/'
      tabindex="-52">  提问的智慧转载</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiao-lu-gong-ju-markdown/'
      tabindex="-53">  效率工具Markdown</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wu-wei-bing-fa-rust-sheng-ming-zhou-qi-qian-tan/'
      tabindex="-54">  无畏并发_Rust 生命周期浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-yu-de-bei-sai-er-qu-xian-gan-shou-si-hua-de-shu-xue-zhi-mei/'
      tabindex="-55">  游戏开发与的贝塞尔曲线_感受丝滑的数学之美</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-bi-bei-gao-xiao-de-aabb-qiu-ti-he-obb-peng-zhuang-jian-ce-suan-fa/'
      tabindex="-56">  游戏开发必备：高效的 AABB、球体和 OBB 碰撞检测算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-suan-fa-ji-chu-a-xun-lu-suan-fa-chi-xu-wei-hu/'
      tabindex="-57">  游戏算法基础-深入解析A*寻路算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/du-li-you-xi-kai-fa-zhe-gong-ju-xiang-2025jing-xuan-tui-jian-yu-shi-yong-zhi-nan/'
      tabindex="-58">  独立游戏开发者工具箱：2025精选推荐与实用指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xu-huan-yin-qing-you-xi-kai-fa-xi-lie-zhuan-ti-guan-fang-bian-ma-biao-zhun-huo-gui-yue/'
      tabindex="-59">  虚幻引擎游戏开发系列专题-官方编码标准或规约</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiang-jie-she-ji-mo-shi-dan-li-de-jin-hua-zhi-lu/'
      tabindex="-60">  详解设计模式_单例的进化之路</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xie-e-de-fei-chang-liang-quan-ju-bian-liang/'
      tabindex="-61">  邪恶的非常量全局变量</a></span>
  </li>
</ul>
</div>
      <div class="viewer page" id="viewer" tabindex="0">
        <div class="tab">
<div class="file-manager" onclick='document.getElementById("files").classList.toggle("open"); document.getElementById("content").classList.toggle("close")'> </div>
<ul id="tabs">
</ul>


</div>
        <div class="content" id="content"><p>在上一篇关于枚举的文章<a class="" href="https://www.ilikexff.cn/articles/154">[通俗易懂C++]:枚举篇一,无范围枚举</a>中,我们提到了一个例子,使用一个函数将枚举转换为等效字符串的方法:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string_view</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">enum </span><span>Color
</span><span>{
</span><span>    black,
</span><span>    red,
</span><span>    blue,
</span><span>};
</span><span>
</span><span style="color:#b48ead;">constexpr</span><span> std::string_view </span><span style="color:#8fa1b3;">getColorName</span><span>(Color </span><span style="color:#bf616a;">color</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">switch </span><span>(color)
</span><span>    {
</span><span>    </span><span style="color:#b48ead;">case</span><span> black: </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">black</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">case</span><span> red:   </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">red</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">case</span><span> blue:  </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">blue</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">default</span><span>:    </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">???</span><span>&quot;;
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">constexpr</span><span> Color </span><span style="color:#bf616a;">shirt</span><span>{ blue };
</span><span>
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Your shirt is </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">getColorName</span><span>(shirt) &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>尽管上面的例子可以正常实现需求,但存在一些不足:</p>
<ul>
<li>我们必须记住创建的函数名称;</li>
<li>每次输出时必须调用这样一个函数才能打印我们需要的枚举字符串,这会给单纯的输出语句造成混乱。</li>
</ul>
<p>一种比较理想的情况是,如果我们可以使用像系统提供的<code>std::cout&lt;&lt;</code>类似的方法来输出枚举,岂不是美滋滋?</p>
<hr />
<h2 id="cao-zuo-fu-zhong-zai-jian-jie">操作符重载简介</h2>
<p>在C++中,使用函数重载,我们可以创建一个同名函数的变体,这些变体可以处理不同的数据类型,而不必为每一个变体起一个唯一的名称。</p>
<p>类似地,C++也支持运算符的重载, 这允许我们定义现有运算符的重载格式,以便于我们可以使这些运算符与我们的程序定义的数据类型一起工作。</p>
<p>需要注意的是,这里暂不会详细介绍运算符的重载,更详细的内容也许会在后面的文章中介绍。</p>
<p>基本的运算符重载相当简单:</p>
<ul>
<li>使用运算符的名称来作为函数名称定义函数。</li>
<li>为每一个运算符添加适当类型的参数(从左到右的顺序)。其中一个参数必须是用户定义的类型(比如类类型或者枚举类型),否则编译器会出错。</li>
<li>返回类型可以设置为任何有意义的类型。</li>
<li>使用<code>return</code>返回运算结果。</li>
</ul>
<blockquote>
<p>当编译器在表达式中遇到对应的运算符并且存在一个或者多个操作数是用户定义的类型时,编译器会检查是否存在一个重载的运算符来解析该调用。例如,对于表达式<code>x+y</code>,编译器会使用函数重载解析来查看是否存在一个<code>operator+(x, y)</code>函数来实现该操作。如果能找到一个唯一性的<code>operator+</code>函数,那它就会被调用并将结果作为返回值返回。</p>
</blockquote>
<hr />
<h2 id="zhong-zai-yun-suan-fu-da-yin-mei-ju">重载<code>&lt;&lt;</code>运算符打印枚举</h2>
<p>在正片开始之前,我们先快速回顾一下运算符&lt;&lt;在被用于输出时的工作方式。</p>
<p>考虑像<code>std::cout &lt;&lt; 10</code>这样的简单输出表达式。其中的<code>std::cout</code>的类型为<code>std::ostream</code>(标准库中的用户定义类型),而10是<code>int</code>基本数据类型。</p>
<p>在计算这个表达式时,编译器将查找可以处理<code>std：：ostream</code>和<code>int</code>类型参数的<code>operator&lt;&lt;</code>重载函数。由于这个函数确实在I/O标准库中实现了,所以它将会被 调用。在该函数中,这个<code>std::cout</code>用于将x输出到控制台,最后,<code>operator&lt;&lt;</code>函数返回其左操作数（在本例中为<code>std：：cout</code>），以便于支持链式调用。</p>
<p>基于此,让我们实现一个<code>operator&lt;&lt;</code>的重载来打印<code>Color</code>：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string_view</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">enum </span><span>Color
</span><span>{
</span><span>	black,
</span><span>	red,
</span><span>	blue,
</span><span>};
</span><span>
</span><span style="color:#b48ead;">constexpr</span><span> std::string_view </span><span style="color:#8fa1b3;">getColorName</span><span>(Color </span><span style="color:#bf616a;">color</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">switch </span><span>(color)
</span><span>    {
</span><span>    </span><span style="color:#b48ead;">case</span><span> black: </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">black</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">case</span><span> red:   </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">red</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">case</span><span> blue:  </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">blue</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">default</span><span>:    </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">???</span><span>&quot;;
</span><span>    }
</span><span>}
</span><span style="color:#65737e;">// operator&lt;&lt; 如何打印 Color 类型
</span><span style="color:#65737e;">// 返回类型和参数类型是引用（以防止创建副本）
</span><span>std::ostream&amp; </span><span style="color:#8fa1b3;">operator&lt;&lt;</span><span>(std::ostream&amp; </span><span style="color:#bf616a;">out</span><span>,Color </span><span style="color:#bf616a;">color</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">return</span><span> out &lt;&lt; </span><span style="color:#bf616a;">getColorName</span><span>(color);
</span><span>};
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Color </span><span style="color:#bf616a;">shirt </span><span>{blue};
</span><span>    std::cout &lt;&lt;&quot;</span><span style="color:#a3be8c;">Your shirt is </span><span>&quot; &lt;&lt; shirt &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span> }
</span></code></pre>
<p><img src="https://images.waer.ltd/notes/202503111501353.png" alt="image-20250311150019525" loading="lazy" decoding="async" /></p>
<p>让我们稍微解析一下这个重载的运算符函数。</p>
<ul>
<li>首先，函数的名称是 <code>operator&lt;&lt;</code>，因为我们正在重载 <code>&lt;&lt;</code> 运算符。<code>operator&lt;&lt;</code> 有两个参数。</li>
<li>左侧的参数（与左操作数匹配）是我们的输出流，类型为 <code>std::ostream</code>。我们使用 <strong>非 const 引用</strong> 传递它，因为我们不希望在调用函数时复制 <code>std::ostream</code> 对象。右侧的参数（与右操作数匹配）是我们的 <code>Color</code>枚举类型对象。</li>
</ul>
<blockquote>
<p>当我们使用 std::ostream 输出操作时，例如通过 &lt;&lt; 运算符写入数据到输出流时，std::ostream 对象的内部状态会发生变化。例如，数据可能会被存入缓冲区或修改流的状态（如错误标志）。为了在调用者中看到这些变化，必须传递非 const 引用，而不是复制或常量引用。因为输出操作会修改这个流的内部状态，所以我们需要它是可修改的。</p>
</blockquote>
<p>回过来看看我们的实现,本质上就是使用<code>std::ostream</code>对象使用操作符<code>&lt;&lt;</code>来打印一个<code>std：：string_view</code>。所以<code>out &lt;&lt; getColorName（color）</code>只是获取我们的颜色名称作为<code>std：：string_view</code>，然后将其打印到输出流。</p>
<p>所以,当我们调用<code>std：：cout &lt;&lt; shirt</code>时，编译器将看到我们重载了<code>operator&lt;&lt;</code>来处理<code>Color</code>类型的对象。然后调用重载的<code>operator&lt;&lt;</code>函数，使用<code>std：：cout</code>作为<code>out</code>参数，使用<code>shirt</code>变量（值为<code>blue</code>）作为<code>color参数</code>。由于<code>out</code>是对<code>std：：cout</code>的引用，而<code>color</code>是枚举数<code>blue</code>的副本，因此表达式<code>out &lt;&lt; getColorName（color）</code>将<code>“blue”</code>打印到控制台。最后，<code>out</code>返回给调用者，便于后续的链式调用。</p>
<hr />
<h2 id="">重载&gt;&gt;运算符,实现枚举的输入</h2>
<p>类似于上面重载<code>&lt;&lt;</code>输出枚举一样,下面是对枚举输入的重载实现:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">limits</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">optional</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string_view</span><span>&gt;
</span><span>
</span><span style="color:#65737e;">// 定义一个枚举类型 Pet，表示不同的宠物
</span><span style="color:#b48ead;">enum </span><span>Pet
</span><span>{
</span><span>    cat,   </span><span style="color:#65737e;">// 0
</span><span>    dog,   </span><span style="color:#65737e;">// 1
</span><span>    pig,   </span><span style="color:#65737e;">// 2
</span><span>    whale, </span><span style="color:#65737e;">// 3
</span><span>};
</span><span>
</span><span style="color:#65737e;">// 这个函数根据 Pet 枚举值返回对应的宠物名称
</span><span style="color:#b48ead;">constexpr</span><span> std::string_view </span><span style="color:#8fa1b3;">getPetName</span><span>(Pet </span><span style="color:#bf616a;">pet</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">switch </span><span>(pet)
</span><span>    {
</span><span>    </span><span style="color:#b48ead;">case</span><span> cat:   </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">cat</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">case</span><span> dog:   </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">dog</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">case</span><span> pig:   </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">pig</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">case</span><span> whale: </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">whale</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">default</span><span>:    </span><span style="color:#b48ead;">return </span><span>&quot;</span><span style="color:#a3be8c;">???</span><span>&quot;; </span><span style="color:#65737e;">// 未知的宠物类型
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#65737e;">// 这个函数根据字符串返回对应的 Pet 枚举值，如果找不到匹配项，返回 std::nullopt
</span><span style="color:#b48ead;">constexpr</span><span> std::optional&lt;Pet&gt; </span><span style="color:#8fa1b3;">getPetFromString</span><span>(std::string_view </span><span style="color:#bf616a;">sv</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">if </span><span>(sv == &quot;</span><span style="color:#a3be8c;">cat</span><span>&quot;)   </span><span style="color:#b48ead;">return</span><span> cat;
</span><span>    </span><span style="color:#b48ead;">if </span><span>(sv == &quot;</span><span style="color:#a3be8c;">dog</span><span>&quot;)   </span><span style="color:#b48ead;">return</span><span> dog;
</span><span>    </span><span style="color:#b48ead;">if </span><span>(sv == &quot;</span><span style="color:#a3be8c;">pig</span><span>&quot;)   </span><span style="color:#b48ead;">return</span><span> pig;
</span><span>    </span><span style="color:#b48ead;">if </span><span>(sv == &quot;</span><span style="color:#a3be8c;">whale</span><span>&quot;) </span><span style="color:#b48ead;">return</span><span> whale;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span>{}; </span><span style="color:#65737e;">// 返回空值，表示没有找到匹配的 Pet
</span><span>}
</span><span>
</span><span>std::istream&amp; </span><span style="color:#8fa1b3;">operator&gt;&gt;</span><span>(std::istream&amp; </span><span style="color:#bf616a;">in</span><span>,Pet&amp; </span><span style="color:#bf616a;">pet</span><span>)
</span><span>{
</span><span>    std::string </span><span style="color:#bf616a;">s </span><span>{};
</span><span>    in &gt;&gt; s;
</span><span>    std::optional&lt;Pet&gt; </span><span style="color:#bf616a;">match </span><span>{</span><span style="color:#bf616a;">getPetFromString</span><span>(s)};
</span><span>    </span><span style="color:#b48ead;">if </span><span>(match)
</span><span>    {
</span><span>        pet = *match;
</span><span>        </span><span style="color:#b48ead;">return</span><span> in;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// 如果输入无效（没有找到匹配项）
</span><span>    </span><span style="color:#65737e;">// 将输入流状态设置为失败状态（failbit）
</span><span>    in.</span><span style="color:#bf616a;">setstate</span><span>(std::ios_base::failbit);
</span><span>    </span><span style="color:#b48ead;">return</span><span> in;
</span><span>}
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Enter a pet: cat, dog, pig, or whale: </span><span>&quot;;
</span><span>       Pet </span><span style="color:#bf616a;">pet</span><span>{};
</span><span>       std::cin &gt;&gt; pet; </span><span style="color:#65737e;">// 读取用户输入
</span><span>
</span><span>       </span><span style="color:#b48ead;">if </span><span>(std::cin) </span><span style="color:#65737e;">// 如果输入有效（找到了匹配项）
</span><span>           std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">You chose: </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">getPetName</span><span>(pet) &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>       </span><span style="color:#b48ead;">else
</span><span>       {
</span><span>           std::cin.</span><span style="color:#bf616a;">clear</span><span>(); </span><span style="color:#65737e;">// 重置输入流，使其恢复到可用状态
</span><span>           std::cin.</span><span style="color:#bf616a;">ignore</span><span>(std::numeric_limits&lt;std::streamsize&gt;::</span><span style="color:#bf616a;">max</span><span>(), &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;); </span><span style="color:#65737e;">// 忽略剩余输入
</span><span>           std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Your pet was not valid</span><span style="color:#96b5b4;">\n</span><span>&quot;; </span><span style="color:#65737e;">// 提示用户输入无效
</span><span>       }
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span> }
</span><span>
</span></code></pre>
<p><img src="https://images.waer.ltd/notes/202503111524108.png" alt="image-20250311152402041" loading="lazy" decoding="async" /></p>
<p>这里有一些与输出情况的不同之处值得注意。首先，<code>std：：cin</code>的类型是<code>std：：istream</code>，所以我们使用<code>std：：istream&amp;</code>作为左参数和返回值的类型，而不是<code>std：：ostream&amp;</code>。其次，<code>pet</code>参数是一个非常量引用。这允许我们的运算符<code>&gt;&gt;</code>修改右操作数的值，如果我们的提取结果匹配，则传入右操作数。</p>
<ul>
<li>在函数内部，我们使用<code>operator&gt;&gt;</code>来输入一个<code>std：：string</code>（它已经知道如何做）。如果用户输入的值与我们的一个pet匹配，那么我们可以为<code>pet</code>分配适当的枚举数并返回左操作数（<code>in</code>）。</li>
<li>如果用户没有输入一个有效的pet，那么我们通过将<code>std：：cin</code>设置为“failure mode”来处理这种情况。这是提取失败时<code>std：：cin</code>通常进入的状态。然后调用者可以检查<code>std：：cin</code>以查看提取成功还是失败。</li>
</ul>

        </div>
      </div>
      <div class="prompt" id="terminal"><input
    type="text"
    id="setter"
    onkeydown="writeit(this, event);moveIt(this.value.length, event)"
    onchange="writeit(this, event)"
    onkeyup="writeit(this, event)"
    onkeypress="writeit(this, event);"
    >
<label for="setter" id="writer"> </label><b class="cursor" id="cursor"></b></div>
      <footer class="footer">
        <div class="footer-content">
          <p class="icp-info">
            <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer">黔ICP备2021010295号</a>
          </p>
        </div>
      </footer>
    </main>
  </body>

</html>
