<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>慕予博客</title>
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"
    integrity="sha256-WCzAhd2P6gRJF9Hv3oOOd+hFJi/QJbv+Azn4CGB8gfY=" crossorigin="anonymous" defer></script>
  <script src="/js/index.js" defer></script>
  <script src="/js/prompt.js" defer></script>
  <script src="/js/keyboard.js" defer></script>
  <script src="/js/tab.js" defer></script>
  <script src="/js/commands.js" defer></script>
  <script src="/js/config.js" defer></script><script src="/config.js"></script><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="style.css"><link rel="stylesheet" href="/css/page.css"></head><body onkeydown="exec(event)" style="background-image: url(&quot;&#x2F;assets&#x2F;bg.jpg&quot;); "><main>
      <div class="files" id="files" tabindex="0">
<ul>

  <li class="file">
    <span><a href='https://ilikexff.cn/8-kuan-rang-ni-kai-fa-qi-fei-de-intellijidea-cha-jian/'
      tabindex="-2">  8款让你开发起飞的IntellijIDEA插件</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/aop-jie-mi-qie-mian-bian-cheng-de-zong-he-zhi-nan/'
      tabindex="-3">  AOP揭秘：切面编程的综合指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-mei-ju-pian-yi-wu-fan-wei-mei-ju/'
      tabindex="-4">  C++游戏开发基础-枚举篇一：无范围枚举</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-std-optional/'
      tabindex="-5">  C++游戏开发基础-深入解析std::optional</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shen-ru-jie-xi-thiszhi-zhen-de-ying-yong-yu-ji-qiao/'
      tabindex="-6">  C++游戏开发基础-深入解析this指针的应用与技巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-fu-zhi-gou-zao-han-shu/'
      tabindex="-7">  C++游戏开发基础-深入解析复制构造函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-mo-ban-he-can-shu-tui-dao-zhi-nan/'
      tabindex="-8">  C++游戏开发基础-类模版和参数推导指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/dockerbi-zhi-bi-hui/'
      tabindex="-9">  Docker必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/githithub-xiao-ce/'
      tabindex="-10">  GitGitHub小册</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/google-hacking/'
      tabindex="-11">  Google Hacking</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/googleguan-fang-ti-shi-gong-cheng-bai-pi-shu-zhong-wen-yi-ben/'
      tabindex="-12">  Google官方《提示工程白皮书（中文译本）》</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-dai-ma-bu-quan-ti-shi-gong-neng-xiao-shi-de-ji-chong-jie-jue-fang-an-re-geng-ban/'
      tabindex="-13">  IDEA代码补全&amp;提示功能消失的几种解决方案(热更版)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-chen-jin-shi-bian-cheng-ti-yan/'
      tabindex="-14">  IDEA沉浸式编程体验</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-han-shu-shi-bian-cheng/'
      tabindex="-15">  Java函数式编程</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-ji-he-yuan-ma-qian-xi/'
      tabindex="-16">  Java集合源码浅析</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mysql-shi-wu-te-xing-yu-ge-chi-ji-bie-xiang-jie/'
      tabindex="-17">  MySQL_事务特性与隔离级别详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ocao-zuo-fu-shi-xian-mei-ju-de-shu-ru-shu-chu/'
      tabindex="-18">  O操作符,实现枚举的输入输出</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/prdsuan-fa-ting-shuo-ni-xiang-ping-yun-qi-chou-yi-ke-rong-yao-shui-jing/'
      tabindex="-19">  PRD算法：听说你想凭运气抽一颗荣耀水晶?</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/picgo-pei-zhi-ge-chong-tu-chuang/'
      tabindex="-20">  PicGo配置各种图床</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/redis-bi-zhi-bi-hui/'
      tabindex="-21">  Redis必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-zhong-de-move-yu-yi-sui-bi/'
      tabindex="-22">  Rust中的move语义随笔</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ssm-kuang-jia-shi-xian-ji-cheng-duan-xin-yan-zheng-ma-gong-neng/'
      tabindex="-23">  SSM框架实现集成短信验证码功能</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/slf4jyu-logbackshi-yong-zhi-nan-ji-yu-gradle/'
      tabindex="-24">  Slf4j与Logback实用指南(基于Gradle)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/spring-security5-xdao-spring-security6-xde-qian-yi/'
      tabindex="-25">  Spring Security5.x到Spring Security6.x的迁移</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springboot-webkai-fa-jing-jie/'
      tabindex="-26">  SpringBoot Web开发精解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springsecurity/'
      tabindex="-27">  SpringSecurity</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/unity6xia-jia-zhong-guo-qu-tuan-jie-yin-qing-jie-bang-zhe-shi-fen-lie-huan-shi-ben-di-hua-de-kai-shi/'
      tabindex="-28">  Unity6下架中国区，团结引擎接棒：这是分裂，还是本地化的开始？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-cong-0-dao-1-da-zao-quan-yu-yan-zhi-chi-de-mo-neng-bian-ji-qi-yu-fa-pian/'
      tabindex="-29">  Vim从0到1打造全语言支持的万能编辑器-语法篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-tiao-tou-powershell-pian/'
      tabindex="-30">  Vim折腾之 PowerShell篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-di-zhi-chuan-di-xiang-jie/'
      tabindex="-31">  [C++游戏开发基础]:地址传递详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-yin-yong-fan-hui-he-di-zhi-fan-hui/'
      tabindex="-32">  [C++游戏开发基础]:引用返回和地址返回</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-he-const/'
      tabindex="-33">  [C++游戏开发基础]:指针和const</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shu-ju-feng-zhuang-yin-cang-de-hao-chu/'
      tabindex="-34">  [C++游戏开发基础]:数据封装(隐藏)的好处</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-gou-zao-han-shu-qian-xi-8000zi/'
      tabindex="-35">  [C++游戏开发基础]:构造函数浅析(8000字)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-li-jie-kong-zhi-zhen/'
      tabindex="-36">  [C++游戏开发基础]:理解空指针</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-zhong-de-fang-wen-han-shu/'
      tabindex="-37">  [C++游戏开发基础]:类中的访问函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-de-ji-ben-gai-nian-li-jie/'
      tabindex="-38">  [C++游戏开发基础]指针的基本概念理解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/fanatical-wu-yue-feng-kuang-te-hui-wei-ni-de-steam-ku-jia-dian-liao/'
      tabindex="-39">  _Fanatical 五月疯狂特惠：为你的 Steam 库加点料！</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-kai-yuan-mi-ma-gong-ju-xpwd-zhong-wen-ban-bian-geng-ri-zhi/'
      tabindex="-40">  _Rust开源密码工具xpwd中文版变更日志</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/readme/'
      tabindex="-41">  readme</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wblog-bo-ke-xian-shang-bu-shu/'
      tabindex="-42">  wblog博客线上部署</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/shang-gu-shen-qi-vim-su-cheng-bei-wang-lu/'
      tabindex="-43">  上古神器_Vim速成备忘录</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mian-fei-ji-huo-quan-ban-ben-typora-zui-xin-ban-wei-li/'
      tabindex="-44">  免费激活全版本Typora，最新版为例</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-lombokxian-wei-ren-zhi-de-ji-ge-qi-ji-yin-qiao/'
      tabindex="-45">  关于Lombok鲜为人知的几个奇技淫巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-jie-kou-xian-liu-de-yi-ci-jian-dan-shi-jian/'
      tabindex="-46">  关于接口限流的一次简单实践</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/tu-jie-er-jin-zhi/'
      tabindex="-47">  图解二进制</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ru-he-xie-de-yi-shou-you-ya-gui-fan-de-springboot-jie-kou/'
      tabindex="-48">  如何写得一手优雅规范的SpringBoot 接口？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/kai-fa-bi-hui-xi-lie-jwtqian-tan/'
      tabindex="-49">  开发必会系列_JWT浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ji-qiao-jiu-shi-xiao-lu-chatgpt-diao-jiao-zhi-bei/'
      tabindex="-50">  技巧就是效率，ChatGPT调教指北</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-sheng-intellij-kai-fa-xiao-lu-zhe-kuan-dai-ma-tu-ding-cha-jian-codepins-zhi-de-yi-shi/'
      tabindex="-51">  提升 IntelliJ 开发效率？这款代码图钉插件 CodePins 值得一试</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-wen-de-zhi-hui-zhuan-zai/'
      tabindex="-52">  提问的智慧转载</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiao-lu-gong-ju-markdown/'
      tabindex="-53">  效率工具Markdown</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wu-wei-bing-fa-rust-sheng-ming-zhou-qi-qian-tan/'
      tabindex="-54">  无畏并发_Rust 生命周期浅谈</a></span>
  </li><li class="file">
    <span><a class="selected"href='https://ilikexff.cn/you-xi-kai-fa-yu-de-bei-sai-er-qu-xian-gan-shou-si-hua-de-shu-xue-zhi-mei/'
      tabindex="-55">  游戏开发与的贝塞尔曲线_感受丝滑的数学之美</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-bi-bei-gao-xiao-de-aabb-qiu-ti-he-obb-peng-zhuang-jian-ce-suan-fa/'
      tabindex="-56">  游戏开发必备：高效的 AABB、球体和 OBB 碰撞检测算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-suan-fa-ji-chu-a-xun-lu-suan-fa-chi-xu-wei-hu/'
      tabindex="-57">  游戏算法基础-深入解析A*寻路算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/du-li-you-xi-kai-fa-zhe-gong-ju-xiang-2025jing-xuan-tui-jian-yu-shi-yong-zhi-nan/'
      tabindex="-58">  独立游戏开发者工具箱：2025精选推荐与实用指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xu-huan-yin-qing-you-xi-kai-fa-xi-lie-zhuan-ti-guan-fang-bian-ma-biao-zhun-huo-gui-yue/'
      tabindex="-59">  虚幻引擎游戏开发系列专题-官方编码标准或规约</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiang-jie-she-ji-mo-shi-dan-li-de-jin-hua-zhi-lu/'
      tabindex="-60">  详解设计模式_单例的进化之路</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xie-e-de-fei-chang-liang-quan-ju-bian-liang/'
      tabindex="-61">  邪恶的非常量全局变量</a></span>
  </li>
</ul>
</div>
      <div class="viewer page" id="viewer" tabindex="0">
        <div class="tab">
<div class="file-manager" onclick='document.getElementById("files").classList.toggle("open"); document.getElementById("content").classList.toggle("close")'> </div>
<ul id="tabs">
</ul>


</div>
        <div class="content" id="content"><h2 id="jie-shao">介绍</h2>
<p>贝塞尔曲线是计算机图形学中最重要的概念之一，以其在表示曲线时的灵活性和精确性而闻名。广泛应用于计算机图形学、动画、路径规划等领域的数学曲线。</p>
<p>贝塞尔曲线的数学原理基础是1912年成立的伯恩斯坦多项式。</p>
<p>简单来说,贝塞尔曲线是通过可变数量的点定义的。当控制点只有两个时,绘制出来的是一条直线,也称为<strong>线性贝塞尔曲线</strong>。</p>
<p>具有三个控制点的贝塞尔曲线是 <strong>二次贝塞尔曲线</strong>,四个点控制的则是三次贝塞尔曲线,以此类推。</p>
<p>其中,二次和三次贝塞尔曲线比较常用,也是比较受欢迎的两种。因为他们在计算简单性和能够表示无限范围的曲线之间取得了平衡。</p>
<hr />
<h2 id="qu-xian-fang-cheng">曲线方程</h2>
<p>贝塞尔曲线方程可以表示为:</p>
<p><img src="https://images.waer.ltd/notes/202503301949531.png" alt="image" loading="lazy" decoding="async" /></p>
<p>其中,$B(t)$ 是贝塞尔曲线在参数 t 上的点。</p>
<p>$n$是贝塞尔曲线的次数</p>
<p>$P_i$是控制点。</p>
<p>更具体的,对于<strong>一阶贝塞尔曲线</strong>,公式如下:</p>
<p>$B(t) = (1 - t) P_0 + t P_1 \quad \text{，其中 } t \in [0, 1]$</p>
<blockquote>
<p>其中的$P_0$,$P_1$是两个控制点,曲线从$P_0$出发,经过$P_1$,且为一条直线。</p>
</blockquote>
<p><strong>二次贝塞尔曲线</strong>有三个控制点，通常用于平滑的路径绘制。该曲线依赖于一个控制点来弯曲直线,这种操作相比很多人都不陌生,我们在很多绘图软件中需要用到曲线或者带箭头的曲线时,都会通过鼠标拖动头尾之外的中间点来实现想要的弯曲效果。</p>
<p>$B(t) = (1 - t)^2 P_0 + 2(1 - t)t P_1 + t^2 P_2 \quad \text{，其中 } t \in [0, 1]$</p>
<blockquote>
<p>$P_0$ 和 $P_2$  是起始点和终点，$P_1$  是控制点，影响曲线的弯曲度。</p>
</blockquote>
<p><strong>三次贝塞尔曲线</strong>有四个控制点，常用于图形和字体的平滑曲线，尤其是在矢量图形软件中。</p>
<p>$B(t) = (1 - t)^3 P_0 + 3(1 - t)^2 t P_1 + 3(1 - t) t^2 P_2 + t^3 P_3 \quad \text{，其中 } t \in [0, 1]$</p>
<blockquote>
<p>类似的,其中的$p_0$和$p_3$作为起点和终点,其余两个参数作为曲线控制参数,分别控制曲线的起始和终止方向。</p>
</blockquote>
<p>对于更高阶的贝塞尔曲线（如四次、五次等）可以用于更复杂的曲线绘制，它们的公式类似于三次贝塞尔曲线，只是控制点数量和计算复杂度增加。</p>
<p>$B(t) = \sum_{i=0}^{n} \binom{n}{i} (1 - t)^{n-i} t^i P_i$</p>
<blockquote>
<p>这里$ \binom{n}{i}$ 是二项式系数，控制点的数量为 $n+1$,对这个公式展开后就是上面一开始给出的方程了。</p>
</blockquote>
<hr />
<h2 id="">尝试实现</h2>
<p>这一节中尝试探讨一下贝塞尔曲线的实现,采用<code>C++</code>和``javascript`代码进行实践。需要说明的是,出于学习的目的,我们这里直接采用递归的实现方法,当然,对于复杂、大数值的贝塞尔曲线,递归可能不够高效,还可能出现栈溢出的问题,因此可以采用迭代的方式,由于我们这里只实现常用的二次和三次曲线,因此就直接使用递归了。</p>
<p>需要说明的是,我们最终需要的是通过代码绘制出来一条贝塞尔曲线,因此就不能通过普通的方法去实现,需要借助一些可以绘图的工具,在<code>C++</code>中,可以使用<code>SFML</code>或者<code>UE</code>等游戏引擎,当然,出于懒惰,趁我<code>UE</code>还没关就直接用它来实现了。</p>
<p>对于<code>JS</code>语言,可以借助<code>Css</code>来配合实现可视化。</p>
<h3 id="-1">基于C++在UE5中的实现</h3>
<blockquote>
<p>出于简单的目的,这里直接采用UE中的图形化调试类<code>DrawDebugHelpers</code>来实现了,但这不代表实现方式唯一,仅供参考。</p>
</blockquote>
<ul>
<li><code>ABezierCurveActor.h</code></li>
</ul>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#pragma</span><span> once
</span><span>
</span><span style="color:#b48ead;">#include </span><span>&quot;</span><span style="color:#a3be8c;">CoreMinimal.h</span><span>&quot;
</span><span style="color:#b48ead;">#include </span><span>&quot;</span><span style="color:#a3be8c;">GameFramework/Actor.h</span><span>&quot;
</span><span style="color:#b48ead;">#include </span><span>&quot;</span><span style="color:#a3be8c;">BezierCurveActor.generated.h</span><span>&quot;
</span><span>
</span><span style="color:#bf616a;">UCLASS</span><span>()
</span><span style="color:#b48ead;">class </span><span style="color:#eff1f5;">LEARN_1_API </span><span style="color:#ebcb8b;">ABezierCurveActor </span><span style="color:#eff1f5;">: </span><span style="color:#b48ead;">public </span><span style="color:#a3be8c;">AActor
</span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">	</span><span style="color:#bf616a;">GENERATED_BODY</span><span style="color:#eff1f5;">()
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">	</span><span style="color:#bf616a;">UPROPERTY</span><span style="color:#eff1f5;">(EditAnywhere, BlueprintReadWrite, Category </span><span>= &quot;</span><span style="color:#a3be8c;">Bezier</span><span>&quot;</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">	TArray&lt;FVector&gt; ControlPoints;
</span><span style="color:#eff1f5;">	</span><span style="color:#8fa1b3;">ABezierCurveActor</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">	</span><span style="color:#bf616a;">UFUNCTION</span><span style="color:#eff1f5;">(BlueprintCallable, Category </span><span>= &quot;</span><span style="color:#a3be8c;">Bezier</span><span>&quot;</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">	FVector </span><span style="color:#8fa1b3;">Bezier</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">const</span><span style="color:#eff1f5;"> TArray&lt;FVector&gt;</span><span>&amp; </span><span style="color:#bf616a;">Points</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">float </span><span style="color:#bf616a;">t</span><span style="color:#eff1f5;">);
</span><span style="color:#b48ead;">protected</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">	</span><span style="color:#b48ead;">virtual void </span><span style="color:#8fa1b3;">BeginPlay</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">override</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:	
</span><span style="color:#eff1f5;">	</span><span style="color:#b48ead;">virtual void </span><span style="color:#8fa1b3;">Tick</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">float </span><span style="color:#bf616a;">DeltaTime</span><span style="color:#eff1f5;">) </span><span style="color:#b48ead;">override</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span></code></pre>
<ul>
<li><code>ABezierCurveActor.cpp</code></li>
</ul>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#65737e;">// Fill out your copyright notice in the Description page of Project Settings.
</span><span>
</span><span style="color:#b48ead;">#include </span><span>&quot;</span><span style="color:#a3be8c;">BezierCurveActor.h</span><span>&quot;
</span><span style="color:#b48ead;">#include </span><span>&quot;</span><span style="color:#a3be8c;">DrawDebugHelpers.h</span><span>&quot;
</span><span>
</span><span style="color:#65737e;">// 构造函数
</span><span>ABezierCurveActor::</span><span style="color:#8fa1b3;">ABezierCurveActor</span><span>()
</span><span>{
</span><span>	</span><span style="color:#65737e;">// 启用 Tick，使该 Actor 在每帧调用 Tick() 函数
</span><span>	PrimaryActorTick.</span><span style="color:#bf616a;">bCanEverTick </span><span>= </span><span style="color:#d08770;">true</span><span>;
</span><span>
</span><span>	</span><span style="color:#65737e;">// 初始化控制点，定义三次贝塞尔曲线
</span><span>	ControlPoints =
</span><span>	{
</span><span>		</span><span style="color:#bf616a;">FVector</span><span>(</span><span style="color:#d08770;">0</span><span>,</span><span style="color:#d08770;">0</span><span>,</span><span style="color:#d08770;">0</span><span>),       </span><span style="color:#65737e;">// 起点
</span><span>		</span><span style="color:#bf616a;">FVector</span><span>(</span><span style="color:#d08770;">100</span><span>,</span><span style="color:#d08770;">200</span><span>,</span><span style="color:#d08770;">0</span><span>),   </span><span style="color:#65737e;">// 控制点1
</span><span>		</span><span style="color:#bf616a;">FVector</span><span>(</span><span style="color:#d08770;">200</span><span>,</span><span style="color:#d08770;">300</span><span>,</span><span style="color:#d08770;">0</span><span>),   </span><span style="color:#65737e;">// 控制点2
</span><span>		</span><span style="color:#bf616a;">FVector</span><span>(</span><span style="color:#d08770;">300</span><span>,</span><span style="color:#d08770;">0</span><span>,</span><span style="color:#d08770;">0</span><span>)      </span><span style="color:#65737e;">// 终点
</span><span>	};
</span><span>}
</span><span>
</span><span style="color:#65737e;">// 游戏开始时调用
</span><span style="color:#b48ead;">void </span><span>ABezierCurveActor::</span><span style="color:#8fa1b3;">BeginPlay</span><span>()
</span><span>{
</span><span>	Super::</span><span style="color:#bf616a;">BeginPlay</span><span>();
</span><span>}
</span><span>
</span><span style="color:#65737e;">// 递归计算贝塞尔曲线上的点
</span><span style="color:#65737e;">// 使用 De Casteljau 算法逐步插值计算贝塞尔曲线
</span><span>FVector ABezierCurveActor::</span><span style="color:#8fa1b3;">Bezier</span><span>(</span><span style="color:#b48ead;">const</span><span> TArray&lt;FVector&gt;&amp; </span><span style="color:#bf616a;">Points</span><span>, </span><span style="color:#b48ead;">float </span><span style="color:#bf616a;">t</span><span>)
</span><span>{
</span><span>	</span><span style="color:#65737e;">// 递归终止条件：当只剩下一个点时，返回该点
</span><span>	</span><span style="color:#b48ead;">if </span><span>(Points.</span><span style="color:#bf616a;">Num</span><span>() == </span><span style="color:#d08770;">1</span><span>) </span><span style="color:#b48ead;">return</span><span> Points[</span><span style="color:#d08770;">0</span><span>];
</span><span>
</span><span>	</span><span style="color:#65737e;">// 存储新计算的插值点
</span><span>	TArray&lt;FVector&gt; NewPoints;
</span><span>
</span><span>	</span><span style="color:#65737e;">// 对当前点集进行线性插值，计算新的点集
</span><span>	</span><span style="color:#b48ead;">for </span><span>(int32 </span><span style="color:#bf616a;">i </span><span>{</span><span style="color:#d08770;">0</span><span>}; i &lt; Points.</span><span style="color:#bf616a;">Num</span><span>() - </span><span style="color:#d08770;">1</span><span>; ++i)
</span><span>	{
</span><span>		NewPoints.</span><span style="color:#bf616a;">Add</span><span>(FMath::</span><span style="color:#bf616a;">Lerp</span><span>(Points[i], Points[i+</span><span style="color:#d08770;">1</span><span>], t));
</span><span>	}
</span><span>
</span><span>	</span><span style="color:#65737e;">// 递归计算直到收敛到一个点
</span><span>	</span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">Bezier</span><span>(NewPoints, t);
</span><span>}
</span><span>
</span><span style="color:#65737e;">// 每帧调用，用于动态绘制贝塞尔曲线
</span><span style="color:#b48ead;">void </span><span>ABezierCurveActor::</span><span style="color:#8fa1b3;">Tick</span><span>(</span><span style="color:#b48ead;">float </span><span style="color:#bf616a;">DeltaTime</span><span>)
</span><span>{
</span><span>	Super::</span><span style="color:#bf616a;">Tick</span><span>(DeltaTime);
</span><span>
</span><span>	</span><span style="color:#65737e;">// 细分曲线，决定曲线的平滑度
</span><span>	</span><span style="color:#b48ead;">const</span><span> int32 </span><span style="color:#bf616a;">NumSegments </span><span>{</span><span style="color:#d08770;">50</span><span>};
</span><span>
</span><span>	</span><span style="color:#65737e;">// 计算曲线起始点
</span><span>	FVector LastPoint = </span><span style="color:#bf616a;">Bezier</span><span>(ControlPoints, </span><span style="color:#d08770;">0.0</span><span style="color:#b48ead;">f</span><span>);
</span><span>
</span><span>	</span><span style="color:#65737e;">// 逐步计算曲线上的点，并绘制线段
</span><span>	</span><span style="color:#b48ead;">for </span><span>(int32 </span><span style="color:#bf616a;">i </span><span>{</span><span style="color:#d08770;">1</span><span>}; i &lt;= NumSegments; ++i)
</span><span>	{
</span><span>		</span><span style="color:#65737e;">// 计算当前插值参数 t，范围为 [0,1]
</span><span>		</span><span style="color:#b48ead;">float</span><span> t = i / static_cast&lt;</span><span style="color:#b48ead;">float</span><span>&gt;(NumSegments);
</span><span>
</span><span>		</span><span style="color:#65737e;">// 计算贝塞尔曲线在 t 处的点
</span><span>		FVector NewPoint = </span><span style="color:#bf616a;">Bezier</span><span>(ControlPoints, t);
</span><span>
</span><span>		</span><span style="color:#65737e;">// 在世界中绘制线段，连接上一个点与当前点
</span><span>		</span><span style="color:#bf616a;">DrawDebugLine</span><span>(</span><span style="color:#bf616a;">GetWorld</span><span>(), LastPoint, NewPoint, FColor::Green, </span><span style="color:#d08770;">false</span><span>, -</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">2.0</span><span style="color:#b48ead;">f</span><span>);
</span><span>
</span><span>		</span><span style="color:#65737e;">// 更新 LastPoint，作为下一段线段的起点
</span><span>		LastPoint = NewPoint;
</span><span>	}
</span><span>}
</span></code></pre>
<p><img src="https://images.waer.ltd/notes/202503301832448.png" alt="image-20250330183234228" loading="lazy" decoding="async" /></p>
<p>对于这种实现方式,虽然写的是三次耳塞尔的实现,但是可以通过调整<code>ControlPoints</code>的参数来实现二次和三次的转变,因为我们的方法是通用的(理论上支持任意阶的贝塞尔曲线,但是在实际应用中,更高阶的曲线建议使用迭代方式实现)。</p>
<p>比如,对于二次贝塞尔曲线,我们需要三个控制点,那么参数可能是下面这样的:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>ControlPoints = {
</span><span>    </span><span style="color:#bf616a;">FVector</span><span>(</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>),      </span><span style="color:#65737e;">// 起点
</span><span>    </span><span style="color:#bf616a;">FVector</span><span>(</span><span style="color:#d08770;">100</span><span>, </span><span style="color:#d08770;">200</span><span>, </span><span style="color:#d08770;">0</span><span>),  </span><span style="color:#65737e;">// 控制点
</span><span>    </span><span style="color:#bf616a;">FVector</span><span>(</span><span style="color:#d08770;">200</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>)     </span><span style="color:#65737e;">// 终点
</span><span>};
</span></code></pre>
<hr />
<h3 id="-2">使用JavaScript配合Canvas API实现</h3>
<blockquote>
<p>这种方式的好处是门槛低,简单的前端三剑客就可以实现,并且交互也不错。</p>
</blockquote>
<p>本来是想花点时间做个分步骤教程的,但是想想好像没必要,有点小题大做了,所以这就直接贴一下完整代码好了。</p>
<pre data-lang="html" style="background-color:#2b303b;color:#c0c5ce;" class="language-html "><code class="language-html" data-lang="html"><span>&lt;!</span><span style="color:#b48ead;">DOCTYPE </span><span style="color:#d08770;">html</span><span>&gt;
</span><span>&lt;</span><span style="color:#bf616a;">html </span><span style="color:#d08770;">lang</span><span>=&quot;</span><span style="color:#a3be8c;">zh</span><span>&quot;&gt;
</span><span>&lt;</span><span style="color:#bf616a;">head</span><span>&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">meta </span><span style="color:#d08770;">charset</span><span>=&quot;</span><span style="color:#a3be8c;">UTF-8</span><span>&quot;&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">meta </span><span style="color:#d08770;">name</span><span>=&quot;</span><span style="color:#a3be8c;">viewport</span><span>&quot; </span><span style="color:#d08770;">content</span><span>=&quot;</span><span style="color:#a3be8c;">width=device-width, initial-scale=1.0</span><span>&quot;&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">title</span><span>&gt;贝塞尔曲线可视化&lt;/</span><span style="color:#bf616a;">title</span><span>&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">style</span><span>&gt;
</span><span>        </span><span style="color:#bf616a;">body </span><span>{ text-align: center; }
</span><span>        </span><span style="color:#bf616a;">canvas </span><span>{
</span><span>            border: </span><span style="color:#d08770;">1px </span><span>solid black;
</span><span>            cursor: pointer;
</span><span>        }
</span><span>    &lt;/</span><span style="color:#bf616a;">style</span><span>&gt;
</span><span>&lt;/</span><span style="color:#bf616a;">head</span><span>&gt;
</span><span>&lt;</span><span style="color:#bf616a;">body</span><span>&gt;
</span><span>
</span><span>&lt;</span><span style="color:#bf616a;">h2</span><span>&gt;贝塞尔曲线可视化 (支持二次 &amp; 三次)&lt;/</span><span style="color:#bf616a;">h2</span><span>&gt;
</span><span>&lt;</span><span style="color:#bf616a;">label</span><span>&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">input </span><span style="color:#d08770;">type</span><span>=&quot;</span><span style="color:#a3be8c;">radio</span><span>&quot; </span><span style="color:#d08770;">name</span><span>=&quot;</span><span style="color:#a3be8c;">degree</span><span>&quot; </span><span style="color:#d08770;">value</span><span>=&quot;</span><span style="color:#a3be8c;">quadratic</span><span>&quot; </span><span style="color:#d08770;">checked</span><span>&gt; 二次贝塞尔
</span><span>&lt;/</span><span style="color:#bf616a;">label</span><span>&gt;
</span><span>&lt;</span><span style="color:#bf616a;">label</span><span>&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">input </span><span style="color:#d08770;">type</span><span>=&quot;</span><span style="color:#a3be8c;">radio</span><span>&quot; </span><span style="color:#d08770;">name</span><span>=&quot;</span><span style="color:#a3be8c;">degree</span><span>&quot; </span><span style="color:#d08770;">value</span><span>=&quot;</span><span style="color:#a3be8c;">cubic</span><span>&quot;&gt; 三次贝塞尔
</span><span>&lt;/</span><span style="color:#bf616a;">label</span><span>&gt;
</span><span>&lt;</span><span style="color:#bf616a;">br</span><span>&gt;&lt;</span><span style="color:#bf616a;">br</span><span>&gt;
</span><span>&lt;</span><span style="color:#bf616a;">canvas </span><span style="color:#8fa1b3;">id</span><span>=&quot;</span><span style="color:#a3be8c;">bezierCanvas</span><span>&quot; </span><span style="color:#d08770;">width</span><span>=&quot;</span><span style="color:#a3be8c;">500</span><span>&quot; </span><span style="color:#d08770;">height</span><span>=&quot;</span><span style="color:#a3be8c;">500</span><span>&quot;&gt;&lt;/</span><span style="color:#bf616a;">canvas</span><span>&gt;
</span><span>
</span><span>&lt;</span><span style="color:#bf616a;">script</span><span>&gt;
</span><span>    </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">canvas </span><span>= document.</span><span style="color:#bf616a;">getElementById</span><span>(&quot;</span><span style="color:#a3be8c;">bezierCanvas</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">ctx </span><span>= </span><span style="color:#bf616a;">canvas</span><span>.</span><span style="color:#bf616a;">getContext</span><span>(&quot;</span><span style="color:#a3be8c;">2d</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#65737e;">// 控制点（默认二次贝塞尔）
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">controlPoints </span><span>= [
</span><span>        { x: </span><span style="color:#d08770;">100</span><span>, y: </span><span style="color:#d08770;">400 </span><span>}, </span><span style="color:#65737e;">// 起点
</span><span>        { x: </span><span style="color:#d08770;">250</span><span>, y: </span><span style="color:#d08770;">100 </span><span>}, </span><span style="color:#65737e;">// 控制点
</span><span>        { x: </span><span style="color:#d08770;">400</span><span>, y: </span><span style="color:#d08770;">400 </span><span>}  </span><span style="color:#65737e;">// 终点
</span><span>    ];
</span><span>
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">draggingPoint </span><span>= </span><span style="color:#d08770;">null</span><span>;
</span><span>
</span><span>    </span><span style="color:#65737e;">// 计算贝塞尔曲线（递归）
</span><span>    </span><span style="color:#b48ead;">function </span><span style="color:#8fa1b3;">bezier</span><span>(points, t) {
</span><span>        </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">points</span><span>.length === </span><span style="color:#d08770;">1</span><span>) </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">points</span><span>[</span><span style="color:#d08770;">0</span><span>]; </span><span style="color:#65737e;">// 递归终止
</span><span>
</span><span>        </span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">newPoints </span><span>= [];
</span><span>        </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">i </span><span>= </span><span style="color:#d08770;">0</span><span>; </span><span style="color:#bf616a;">i </span><span>&lt; </span><span style="color:#bf616a;">points</span><span>.length - </span><span style="color:#d08770;">1</span><span>; </span><span style="color:#bf616a;">i</span><span>++) {
</span><span>            </span><span style="color:#bf616a;">newPoints</span><span>.</span><span style="color:#bf616a;">push</span><span>({
</span><span>                x: (</span><span style="color:#d08770;">1 </span><span>- </span><span style="color:#bf616a;">t</span><span>) * </span><span style="color:#bf616a;">points</span><span>[</span><span style="color:#bf616a;">i</span><span>].x + </span><span style="color:#bf616a;">t </span><span>* </span><span style="color:#bf616a;">points</span><span>[</span><span style="color:#bf616a;">i </span><span>+ </span><span style="color:#d08770;">1</span><span>].x,
</span><span>                y: (</span><span style="color:#d08770;">1 </span><span>- </span><span style="color:#bf616a;">t</span><span>) * </span><span style="color:#bf616a;">points</span><span>[</span><span style="color:#bf616a;">i</span><span>].y + </span><span style="color:#bf616a;">t </span><span>* </span><span style="color:#bf616a;">points</span><span>[</span><span style="color:#bf616a;">i </span><span>+ </span><span style="color:#d08770;">1</span><span>].y
</span><span>            });
</span><span>        }
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">bezier</span><span>(</span><span style="color:#bf616a;">newPoints</span><span>, </span><span style="color:#bf616a;">t</span><span>);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// 绘制曲线
</span><span>    </span><span style="color:#b48ead;">function </span><span style="color:#8fa1b3;">drawBezierCurve</span><span>() {
</span><span>        </span><span style="color:#bf616a;">ctx</span><span>.</span><span style="color:#bf616a;">clearRect</span><span>(</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#bf616a;">canvas</span><span>.width, </span><span style="color:#bf616a;">canvas</span><span>.height);
</span><span>
</span><span>        </span><span style="color:#65737e;">// 画控制点连线
</span><span>        </span><span style="color:#bf616a;">ctx</span><span>.strokeStyle = &quot;</span><span style="color:#a3be8c;">gray</span><span>&quot;;
</span><span>        </span><span style="color:#bf616a;">ctx</span><span>.</span><span style="color:#bf616a;">beginPath</span><span>();
</span><span>        </span><span style="color:#bf616a;">ctx</span><span>.</span><span style="color:#bf616a;">moveTo</span><span>(</span><span style="color:#bf616a;">controlPoints</span><span>[</span><span style="color:#d08770;">0</span><span>].x, </span><span style="color:#bf616a;">controlPoints</span><span>[</span><span style="color:#d08770;">0</span><span>].y);
</span><span>        </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">i </span><span>= </span><span style="color:#d08770;">1</span><span>; </span><span style="color:#bf616a;">i </span><span>&lt; </span><span style="color:#bf616a;">controlPoints</span><span>.length; </span><span style="color:#bf616a;">i</span><span>++) {
</span><span>            </span><span style="color:#bf616a;">ctx</span><span>.</span><span style="color:#bf616a;">lineTo</span><span>(</span><span style="color:#bf616a;">controlPoints</span><span>[</span><span style="color:#bf616a;">i</span><span>].x, </span><span style="color:#bf616a;">controlPoints</span><span>[</span><span style="color:#bf616a;">i</span><span>].y);
</span><span>        }
</span><span>        </span><span style="color:#bf616a;">ctx</span><span>.</span><span style="color:#bf616a;">stroke</span><span>();
</span><span>
</span><span>        </span><span style="color:#65737e;">// 画控制点
</span><span>        </span><span style="color:#bf616a;">ctx</span><span>.fillStyle = &quot;</span><span style="color:#a3be8c;">red</span><span>&quot;;
</span><span>        </span><span style="color:#bf616a;">controlPoints</span><span>.</span><span style="color:#bf616a;">forEach</span><span>(p </span><span style="color:#b48ead;">=&gt; </span><span>{
</span><span>            </span><span style="color:#bf616a;">ctx</span><span>.</span><span style="color:#bf616a;">beginPath</span><span>();
</span><span>            </span><span style="color:#bf616a;">ctx</span><span>.</span><span style="color:#bf616a;">arc</span><span>(</span><span style="color:#bf616a;">p</span><span>.x, </span><span style="color:#bf616a;">p</span><span>.y, </span><span style="color:#d08770;">5</span><span>, </span><span style="color:#d08770;">0</span><span>, Math.PI * </span><span style="color:#d08770;">2</span><span>);
</span><span>            </span><span style="color:#bf616a;">ctx</span><span>.</span><span style="color:#bf616a;">fill</span><span>();
</span><span>        });
</span><span>
</span><span>        </span><span style="color:#65737e;">// 画贝塞尔曲线
</span><span>        </span><span style="color:#bf616a;">ctx</span><span>.strokeStyle = &quot;</span><span style="color:#a3be8c;">blue</span><span>&quot;;
</span><span>        </span><span style="color:#bf616a;">ctx</span><span>.</span><span style="color:#bf616a;">beginPath</span><span>();
</span><span>        </span><span style="color:#bf616a;">ctx</span><span>.</span><span style="color:#bf616a;">moveTo</span><span>(</span><span style="color:#bf616a;">controlPoints</span><span>[</span><span style="color:#d08770;">0</span><span>].x, </span><span style="color:#bf616a;">controlPoints</span><span>[</span><span style="color:#d08770;">0</span><span>].y);
</span><span>        </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">t </span><span>= </span><span style="color:#d08770;">0</span><span>; </span><span style="color:#bf616a;">t </span><span>&lt;= </span><span style="color:#d08770;">1</span><span>; </span><span style="color:#bf616a;">t </span><span>+= </span><span style="color:#d08770;">0.01</span><span>) {
</span><span>            </span><span style="color:#b48ead;">let </span><span>{ </span><span style="color:#bf616a;">x</span><span>, </span><span style="color:#bf616a;">y </span><span>} = </span><span style="color:#bf616a;">bezier</span><span>(</span><span style="color:#bf616a;">controlPoints</span><span>, </span><span style="color:#bf616a;">t</span><span>);
</span><span>            </span><span style="color:#bf616a;">ctx</span><span>.</span><span style="color:#bf616a;">lineTo</span><span>(</span><span style="color:#bf616a;">x</span><span>, </span><span style="color:#bf616a;">y</span><span>);
</span><span>        }
</span><span>        </span><span style="color:#bf616a;">ctx</span><span>.</span><span style="color:#bf616a;">stroke</span><span>();
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// 监听鼠标拖动控制点
</span><span>    </span><span style="color:#bf616a;">canvas</span><span>.</span><span style="color:#bf616a;">addEventListener</span><span>(&quot;</span><span style="color:#a3be8c;">mousedown</span><span>&quot;, (e) </span><span style="color:#b48ead;">=&gt; </span><span>{
</span><span>        </span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">mouseX </span><span>= </span><span style="color:#bf616a;">e</span><span>.offsetX, </span><span style="color:#bf616a;">mouseY </span><span>= </span><span style="color:#bf616a;">e</span><span>.offsetY;
</span><span>        </span><span style="color:#bf616a;">draggingPoint </span><span>= </span><span style="color:#bf616a;">controlPoints</span><span>.</span><span style="color:#bf616a;">find</span><span>(p </span><span style="color:#b48ead;">=&gt; </span><span>Math.</span><span style="color:#96b5b4;">hypot</span><span>(</span><span style="color:#bf616a;">p</span><span>.x - </span><span style="color:#bf616a;">mouseX</span><span>, </span><span style="color:#bf616a;">p</span><span>.y - </span><span style="color:#bf616a;">mouseY</span><span>) &lt; </span><span style="color:#d08770;">10</span><span>);
</span><span>    });
</span><span>
</span><span>    </span><span style="color:#bf616a;">canvas</span><span>.</span><span style="color:#bf616a;">addEventListener</span><span>(&quot;</span><span style="color:#a3be8c;">mousemove</span><span>&quot;, (e) </span><span style="color:#b48ead;">=&gt; </span><span>{
</span><span>        </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">draggingPoint</span><span>) {
</span><span>            </span><span style="color:#bf616a;">draggingPoint</span><span>.x = </span><span style="color:#bf616a;">e</span><span>.offsetX;
</span><span>            </span><span style="color:#bf616a;">draggingPoint</span><span>.y = </span><span style="color:#bf616a;">e</span><span>.offsetY;
</span><span>            </span><span style="color:#bf616a;">drawBezierCurve</span><span>();
</span><span>        }
</span><span>    });
</span><span>
</span><span>    </span><span style="color:#bf616a;">canvas</span><span>.</span><span style="color:#bf616a;">addEventListener</span><span>(&quot;</span><span style="color:#a3be8c;">mouseup</span><span>&quot;, () </span><span style="color:#b48ead;">=&gt; </span><span>{ </span><span style="color:#bf616a;">draggingPoint </span><span>= </span><span style="color:#d08770;">null</span><span>; });
</span><span>
</span><span>    </span><span style="color:#65737e;">// 监听用户选择曲线阶数
</span><span>    document.</span><span style="color:#bf616a;">querySelectorAll</span><span>(&quot;</span><span style="color:#a3be8c;">input[name=&#39;degree&#39;]</span><span>&quot;).</span><span style="color:#bf616a;">forEach</span><span>(radio </span><span style="color:#b48ead;">=&gt; </span><span>{
</span><span>        </span><span style="color:#bf616a;">radio</span><span>.</span><span style="color:#bf616a;">addEventListener</span><span>(&quot;</span><span style="color:#a3be8c;">change</span><span>&quot;, (e) </span><span style="color:#b48ead;">=&gt; </span><span>{
</span><span>            </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">e</span><span>.target.value === &quot;</span><span style="color:#a3be8c;">quadratic</span><span>&quot;) {
</span><span>                </span><span style="color:#bf616a;">controlPoints </span><span>= [
</span><span>                    { x: </span><span style="color:#d08770;">100</span><span>, y: </span><span style="color:#d08770;">400 </span><span>}, </span><span style="color:#65737e;">// 起点
</span><span>                    { x: </span><span style="color:#d08770;">250</span><span>, y: </span><span style="color:#d08770;">100 </span><span>}, </span><span style="color:#65737e;">// 控制点
</span><span>                    { x: </span><span style="color:#d08770;">400</span><span>, y: </span><span style="color:#d08770;">400 </span><span>}  </span><span style="color:#65737e;">// 终点
</span><span>                ];
</span><span>            } </span><span style="color:#b48ead;">else </span><span>{
</span><span>                </span><span style="color:#bf616a;">controlPoints </span><span>= [
</span><span>                    { x: </span><span style="color:#d08770;">100</span><span>, y: </span><span style="color:#d08770;">400 </span><span>},  </span><span style="color:#65737e;">// 起点
</span><span>                    { x: </span><span style="color:#d08770;">180</span><span>, y: </span><span style="color:#d08770;">100 </span><span>},  </span><span style="color:#65737e;">// 控制点1
</span><span>                    { x: </span><span style="color:#d08770;">320</span><span>, y: </span><span style="color:#d08770;">100 </span><span>},  </span><span style="color:#65737e;">// 控制点2
</span><span>                    { x: </span><span style="color:#d08770;">400</span><span>, y: </span><span style="color:#d08770;">400 </span><span>}   </span><span style="color:#65737e;">// 终点
</span><span>                ];
</span><span>            }
</span><span>            </span><span style="color:#bf616a;">drawBezierCurve</span><span>();
</span><span>        });
</span><span>    });
</span><span>
</span><span>    </span><span style="color:#65737e;">// 初始化绘制
</span><span>    </span><span style="color:#bf616a;">drawBezierCurve</span><span>();
</span><span>&lt;/</span><span style="color:#bf616a;">script</span><span>&gt;
</span><span>
</span><span>&lt;/</span><span style="color:#bf616a;">body</span><span>&gt;
</span><span>&lt;/</span><span style="color:#bf616a;">html</span><span>&gt;
</span></code></pre>
<p><img src="https://images.waer.ltd/notes/202503302044962.png" alt="image-20250330204444732" loading="lazy" decoding="async" /></p>
<p>因为是可拖动交互,简单做了一个gif,看起来效果还不错。</p>
<p><img src="https://images.waer.ltd/notes/202503302100140.gif" alt="Bezier1" loading="lazy" decoding="async" /></p>
<hr />
<h2 id="-3">使用贝塞尔曲线进行移动</h2>
<p>除了为应用程序和游戏提供平滑的动画外，贝塞尔曲线还可以用来定义游戏对象移动的曲线路径。考虑一个 2D 射击游戏，其中一些敌人沿着不同的路径移动。</p>
<p>虽然直线或圆形等直接路径可以硬编码，但这种方法缺乏灵活性，调整和可视化路径也更具挑战性。</p>
<p>对于这种情况，我们也可以使用贝塞尔曲线轻松地可视化和设计复杂的路径。以下是一个示例(通过改进js实现的代码来实现)，展示了物体沿着由一组贝塞尔曲线控制点定义的可视化曲线路径移动:</p>
<p><img src="https://images.waer.ltd/notes/202503302102854.png" alt="image-20250330210256765" loading="lazy" decoding="async" /></p>
<blockquote>
<p>这里有一个基本的工作原理：贝塞尔曲线提供了一组基于时间参数 t 的位置。通过将对象的当前位置更新为这些点，它能够平滑地穿越路径。</p>
</blockquote>
<p><img src="https://images.waer.ltd/notes/202503302112480.gif" alt="obj" loading="lazy" decoding="async" /></p>
<blockquote>
<p>See you hala!</p>
</blockquote>

        </div>
      </div>
      <div class="prompt" id="terminal"><input
    type="text"
    id="setter"
    onkeydown="writeit(this, event);moveIt(this.value.length, event)"
    onchange="writeit(this, event)"
    onkeyup="writeit(this, event)"
    onkeypress="writeit(this, event);"
    >
<label for="setter" id="writer"> </label><b class="cursor" id="cursor"></b></div>
      <footer class="footer">
        <div class="footer-content">
          <p class="icp-info">
            <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer">黔ICP备2021010295号</a>
          </p>
        </div>
      </footer>
    </main>
  </body>

</html>
