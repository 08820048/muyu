<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>慕予博客</title>
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"
    integrity="sha256-WCzAhd2P6gRJF9Hv3oOOd+hFJi/QJbv+Azn4CGB8gfY=" crossorigin="anonymous" defer></script>
  <script src="/js/index.js" defer></script>
  <script src="/js/prompt.js" defer></script>
  <script src="/js/keyboard.js" defer></script>
  <script src="/js/tab.js" defer></script>
  <script src="/js/commands.js" defer></script>
  <script src="/js/config.js" defer></script><script src="/config.js"></script><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="style.css"><link rel="stylesheet" href="/css/page.css"></head><body onkeydown="exec(event)" style="background-image: url(&#x27;&#x2F;assets&#x2F;bg.jpg&#x27;); "><main>
      <div class="files" id="files" tabindex="0">
<ul>

  <li class="file">
    <span><a href='https://ilikexff.cn/8-kuan-rang-ni-kai-fa-qi-fei-de-intellijidea-cha-jian/'
      tabindex="-2">  8款让你开发起飞的IntellijIDEA插件</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/aop-jie-mi-qie-mian-bian-cheng-de-zong-he-zhi-nan/'
      tabindex="-3">  AOP揭秘：切面编程的综合指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-mei-ju-pian-yi-wu-fan-wei-mei-ju/'
      tabindex="-4">  C++游戏开发基础-枚举篇一：无范围枚举</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-std-optional/'
      tabindex="-5">  C++游戏开发基础-深入解析std::optional</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shen-ru-jie-xi-thiszhi-zhen-de-ying-yong-yu-ji-qiao/'
      tabindex="-6">  C++游戏开发基础-深入解析this指针的应用与技巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-fu-zhi-gou-zao-han-shu/'
      tabindex="-7">  C++游戏开发基础-深入解析复制构造函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-mo-ban-he-can-shu-tui-dao-zhi-nan/'
      tabindex="-8">  C++游戏开发基础-类模版和参数推导指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/dockerbi-zhi-bi-hui/'
      tabindex="-9">  Docker必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/githithub-xiao-ce/'
      tabindex="-10">  GitGitHub小册</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/google-hacking/'
      tabindex="-11">  Google Hacking</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/googleguan-fang-ti-shi-gong-cheng-bai-pi-shu-zhong-wen-yi-ben/'
      tabindex="-12">  Google官方《提示工程白皮书（中文译本）》</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-dai-ma-bu-quan-ti-shi-gong-neng-xiao-shi-de-ji-chong-jie-jue-fang-an-re-geng-ban/'
      tabindex="-13">  IDEA代码补全&amp;提示功能消失的几种解决方案(热更版)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-chen-jin-shi-bian-cheng-ti-yan/'
      tabindex="-14">  IDEA沉浸式编程体验</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-han-shu-shi-bian-cheng/'
      tabindex="-15">  Java函数式编程</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-ji-he-yuan-ma-qian-xi/'
      tabindex="-16">  Java集合源码浅析</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mysql-shi-wu-te-xing-yu-ge-chi-ji-bie-xiang-jie/'
      tabindex="-17">  MySQL_事务特性与隔离级别详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ocao-zuo-fu-shi-xian-mei-ju-de-shu-ru-shu-chu/'
      tabindex="-18">  O操作符,实现枚举的输入输出</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/prdsuan-fa-ting-shuo-ni-xiang-ping-yun-qi-chou-yi-ke-rong-yao-shui-jing/'
      tabindex="-19">  PRD算法：听说你想凭运气抽一颗荣耀水晶?</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/picgo-pei-zhi-ge-chong-tu-chuang/'
      tabindex="-20">  PicGo配置各种图床</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/redis-bi-zhi-bi-hui/'
      tabindex="-21">  Redis必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-zhong-de-move-yu-yi-sui-bi/'
      tabindex="-22">  Rust中的move语义随笔</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ssm-kuang-jia-shi-xian-ji-cheng-duan-xin-yan-zheng-ma-gong-neng/'
      tabindex="-23">  SSM框架实现集成短信验证码功能</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/slf4jyu-logbackshi-yong-zhi-nan-ji-yu-gradle/'
      tabindex="-24">  Slf4j与Logback实用指南(基于Gradle)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/spring-security5-xdao-spring-security6-xde-qian-yi/'
      tabindex="-25">  Spring Security5.x到Spring Security6.x的迁移</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springboot-webkai-fa-jing-jie/'
      tabindex="-26">  SpringBoot Web开发精解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springsecurity/'
      tabindex="-27">  SpringSecurity</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/unity6xia-jia-zhong-guo-qu-tuan-jie-yin-qing-jie-bang-zhe-shi-fen-lie-huan-shi-ben-di-hua-de-kai-shi/'
      tabindex="-28">  Unity6下架中国区，团结引擎接棒：这是分裂，还是本地化的开始？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-cong-0-dao-1-da-zao-quan-yu-yan-zhi-chi-de-mo-neng-bian-ji-qi-yu-fa-pian/'
      tabindex="-29">  Vim从0到1打造全语言支持的万能编辑器-语法篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-tiao-tou-powershell-pian/'
      tabindex="-30">  Vim折腾之 PowerShell篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-di-zhi-chuan-di-xiang-jie/'
      tabindex="-31">  [C++游戏开发基础]:地址传递详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-yin-yong-fan-hui-he-di-zhi-fan-hui/'
      tabindex="-32">  [C++游戏开发基础]:引用返回和地址返回</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-he-const/'
      tabindex="-33">  [C++游戏开发基础]:指针和const</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shu-ju-feng-zhuang-yin-cang-de-hao-chu/'
      tabindex="-34">  [C++游戏开发基础]:数据封装(隐藏)的好处</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-gou-zao-han-shu-qian-xi-8000zi/'
      tabindex="-35">  [C++游戏开发基础]:构造函数浅析(8000字)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-li-jie-kong-zhi-zhen/'
      tabindex="-36">  [C++游戏开发基础]:理解空指针</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-zhong-de-fang-wen-han-shu/'
      tabindex="-37">  [C++游戏开发基础]:类中的访问函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-de-ji-ben-gai-nian-li-jie/'
      tabindex="-38">  [C++游戏开发基础]指针的基本概念理解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/fanatical-wu-yue-feng-kuang-te-hui-wei-ni-de-steam-ku-jia-dian-liao/'
      tabindex="-39">  _Fanatical 五月疯狂特惠：为你的 Steam 库加点料！</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-kai-yuan-mi-ma-gong-ju-xpwd-zhong-wen-ban-bian-geng-ri-zhi/'
      tabindex="-40">  _Rust开源密码工具xpwd中文版变更日志</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/readme/'
      tabindex="-41">  readme</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wblog-bo-ke-xian-shang-bu-shu/'
      tabindex="-42">  wblog博客线上部署</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/shang-gu-shen-qi-vim-su-cheng-bei-wang-lu/'
      tabindex="-43">  上古神器_Vim速成备忘录</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mian-fei-ji-huo-quan-ban-ben-typora-zui-xin-ban-wei-li/'
      tabindex="-44">  免费激活全版本Typora，最新版为例</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-lombokxian-wei-ren-zhi-de-ji-ge-qi-ji-yin-qiao/'
      tabindex="-45">  关于Lombok鲜为人知的几个奇技淫巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-jie-kou-xian-liu-de-yi-ci-jian-dan-shi-jian/'
      tabindex="-46">  关于接口限流的一次简单实践</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/tu-jie-er-jin-zhi/'
      tabindex="-47">  图解二进制</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ru-he-xie-de-yi-shou-you-ya-gui-fan-de-springboot-jie-kou/'
      tabindex="-48">  如何写得一手优雅规范的SpringBoot 接口？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/kai-fa-bi-hui-xi-lie-jwtqian-tan/'
      tabindex="-49">  开发必会系列_JWT浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ji-qiao-jiu-shi-xiao-lu-chatgpt-diao-jiao-zhi-bei/'
      tabindex="-50">  技巧就是效率，ChatGPT调教指北</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-sheng-intellij-kai-fa-xiao-lu-zhe-kuan-dai-ma-tu-ding-cha-jian-codepins-zhi-de-yi-shi/'
      tabindex="-51">  提升 IntelliJ 开发效率？这款代码图钉插件 CodePins 值得一试</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-wen-de-zhi-hui-zhuan-zai/'
      tabindex="-52">  提问的智慧转载</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiao-lu-gong-ju-markdown/'
      tabindex="-53">  效率工具Markdown</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wu-wei-bing-fa-rust-sheng-ming-zhou-qi-qian-tan/'
      tabindex="-54">  无畏并发_Rust 生命周期浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-yu-de-bei-sai-er-qu-xian-gan-shou-si-hua-de-shu-xue-zhi-mei/'
      tabindex="-55">  游戏开发与的贝塞尔曲线_感受丝滑的数学之美</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-bi-bei-gao-xiao-de-aabb-qiu-ti-he-obb-peng-zhuang-jian-ce-suan-fa/'
      tabindex="-56">  游戏开发必备：高效的 AABB、球体和 OBB 碰撞检测算法</a></span>
  </li><li class="file">
    <span><a class="selected"href='https://ilikexff.cn/you-xi-suan-fa-ji-chu-a-xun-lu-suan-fa-chi-xu-wei-hu/'
      tabindex="-57">  游戏算法基础-深入解析A*寻路算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/du-li-you-xi-kai-fa-zhe-gong-ju-xiang-2025jing-xuan-tui-jian-yu-shi-yong-zhi-nan/'
      tabindex="-58">  独立游戏开发者工具箱：2025精选推荐与实用指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xu-huan-yin-qing-you-xi-kai-fa-xi-lie-zhuan-ti-guan-fang-bian-ma-biao-zhun-huo-gui-yue/'
      tabindex="-59">  虚幻引擎游戏开发系列专题-官方编码标准或规约</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiang-jie-she-ji-mo-shi-dan-li-de-jin-hua-zhi-lu/'
      tabindex="-60">  详解设计模式_单例的进化之路</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xie-e-de-fei-chang-liang-quan-ju-bian-liang/'
      tabindex="-61">  邪恶的非常量全局变量</a></span>
  </li>
</ul>
</div>
      <div class="viewer page" id="viewer" tabindex="0">
        <div class="tab">
<div class="file-manager" onclick='document.getElementById("files").classList.toggle("open"); document.getElementById("content").classList.toggle("close")'> </div>
<ul id="tabs">
</ul>


</div>
        <div class="content" id="content"><blockquote>
<p>在开始阅读之前,本文阿婆主默认你已经掌握或者了解以下支撑内容:</p>
<ul>
<li>
<p>玩过游戏</p>
</li>
<li>
<p>买菜用的数学</p>
</li>
<li>
<p>图论基础(深度、广度、Dijkstra)</p>
</li>
<li>
<p>C++编程</p>
</li>
<li>
<p>非色盲选手</p>
</li>
</ul>
</blockquote>
<h2 id="suan-fa-jian-jie">算法简介</h2>
<p><strong>A*寻路算法</strong>是一种在图形平面上寻找<strong>最短路径</strong>的有效方法。它被广泛应用于游戏开发、路径规划、机器人导航等领域。</p>
<p>和一些其他的最短路径搜寻算法不同,A星算法是一种启发式的搜索算法,通过评估每个节点的代价来选择最优路径。A星结合了知名的<code>Dijkstra</code>算法和贪心算法的优点,因此被广泛的应用在各个领域,尤其是游戏开发中,对于游戏中AI角色或者NPC角色以及一些自动寻路功能的开发中更是常客。</p>
<hr />
<h2 id="suan-fa-he-xin-gai-nian">算法核心概念</h2>
<p>对于A星的核心,这里主要讲一下其中的两个核心函数,一是代价函数,第二则是启发式函数。</p>
<h3 id="dai-jia-han-shu-f-n-g-n-h-n">代价函数$f(n) = g(n) + h(n)$</h3>
<ul>
<li>$g(n)$:从起点到当前节点$n$的实际代价,也就是已经走过的那部分路径。</li>
<li>$h(n)$:从$n$到目标点的启发式估计代价(使用启发函数计算得到的距离)。</li>
<li>$f(n)$:代价评估函数,也即是$g(n) + h(n)$的值,决定了搜索的优先级。</li>
</ul>
<p><img src="https://images.waer.ltd/notes/202503181309987.png" alt="1" loading="lazy" decoding="async" /></p>
<h3 id="">启发式函数</h3>
<p>启发式函数（Heuristic Function）是一种用于引导搜索算法的方法，通过估计当前状态到目标状态的最优代价，帮助算法更高效地找到解决方案。它通常用于<strong>启发式搜索</strong>（如 A* 算法、贪心搜索）中，以减少搜索空间，提高搜索效率。</p>
<p>在路径搜索或状态空间搜索中，启发式函数用于评估一个状态的“优越性”或“接近目标的程度”，从而帮助算法优先探索可能更优的路径。例如，在 A* 算法中，启发式函数用于估计从当前节点到目标节点的最短距离。</p>
<h4 id="-1">常见的启发式函数</h4>
<p><strong>1. 欧几里得距离（Euclidean Distance）</strong></p>
<p>$h(n) = \sqrt{(x_{\text{goal}} - x_n)^2 + (y_{\text{goal}} - y_n)^2}$</p>
<blockquote>
<p>欧几里得距离计算的是两点之间的直线最短距离，适用于<strong>连续空间</strong>（如3D世界）或者允许<strong>对角线自由移动</strong>的环境。</p>
</blockquote>
<p><strong>2.曼哈顿距离（Manhattan Distance）</strong></p>
<p>$h(n) = |x_{\text{goal}} - x_n| + |y_{\text{goal}} - y_n|$</p>
<blockquote>
<p>适用于只能水平或者垂直移动的环境,比如棋盘网格状的地图中,常见的如迷宫类游戏。</p>
</blockquote>
<p><strong>3.切比雪夫距离（Chebyshev Distance）</strong></p>
<p>$h(n) = \max(|x_{\text{goal}} - x_n|, |y_{\text{goal}} - y_n|)$</p>
<blockquote>
<p>一般用于允许对角线移动的八方向网格地图中。</p>
</blockquote>
<p><strong>下面是这三种常见函数的对比总结</strong>:</p>
<table><thead><tr><th>启发式函数</th><th>适用场景</th><th>适用游戏类型</th><th>具体游戏示例</th></tr></thead><tbody>
<tr><td><strong>欧几里得距离</strong></td><td>连续空间，适用于<strong>自由移动</strong>的 3D 世界</td><td>FPS、开放世界、RTS、驾驶游戏</td><td>GTA 5、使命召唤、星际争霸 2</td></tr>
<tr><td><strong>曼哈顿距离</strong></td><td>网格地图，<strong>只能水平 / 垂直移动</strong></td><td>2D 像素风、回合制 RPG、战棋</td><td>火焰纹章、博德之门 3、勇者斗恶龙</td></tr>
<tr><td><strong>切比雪夫距离</strong></td><td><strong>允许对角线移动</strong>的网格地图</td><td>战略游戏、棋盘类、生存游戏</td><td>国际象棋、魔兽争霸 3、暗黑破坏神 2</td></tr>
</tbody></table>
<p>为了方便理解,如果没有特殊说明,后续的示例都是基于 <strong>曼哈顿距离</strong>作为启发式函数来讲解的。</p>
<p>举个例子,假设存在下面这样一个地图,其中图二是图一的数组化形式,逻辑上他们是等效的:</p>
<p><img src="https://images.waer.ltd/notes/202503181347197.png" alt="image-20250318134713119" loading="lazy" decoding="async" /></p>
<p>下面是其中一条最优路径的图示:从<code>(0,0)</code>出发到达<code>(3,3)</code></p>
<p><img src="https://images.waer.ltd/notes/202503181507389.png" alt="image-20250318150755239" loading="lazy" decoding="async" /></p>
<p>对于上面的网格地图来说,如果是启发式函数基于 <strong>曼哈顿距离</strong>的情况下,该示例的$g(n),h(n),f(n)$的计算结果如下:</p>
<table><thead><tr><th><strong>位置 (x,y)</strong></th><th><strong>G(n) (路径代价)</strong></th><th><strong>H(n) (曼哈顿)</strong></th><th><strong>F(n) = G(n) + H(n)</strong></th></tr></thead><tbody>
<tr><td><strong>(0,0) (起点)</strong></td><td>0</td><td><strong>6</strong> (3+3)</td><td>6</td></tr>
<tr><td><strong>(0,1)</strong></td><td>1</td><td><strong>5</strong> (3+2)</td><td>6</td></tr>
<tr><td><strong>(1,1)</strong></td><td>2</td><td><strong>4</strong> (3+1)</td><td>6</td></tr>
<tr><td><strong>(1,2)</strong></td><td>3</td><td><strong>3</strong> (3+0)</td><td>6</td></tr>
<tr><td><strong>(1,3)</strong></td><td>4</td><td><strong>2</strong> (2+0)</td><td>6</td></tr>
<tr><td><strong>(2,3)</strong></td><td>5</td><td><strong>1</strong> (1+0)</td><td>6</td></tr>
<tr><td><strong>(3,3) (终点)</strong></td><td>6</td><td><strong>0</strong> (0+0)</td><td>6</td></tr>
</tbody></table>
<blockquote>
<p><strong>纸上得来终觉浅</strong>,建议你掏出压箱底的<strong>稿纸</strong>和垃圾桶里的<strong>2B</strong>,自己模拟计算所需的代价函数,强化理解。</p>
</blockquote>
<p>注意,为了节省篇幅,这里列出的只是其中一条可行的路径,就这个示例地图来说,可能存在多个最优的选择,并不唯一。</p>
<hr />
<h2 id="-2">A*算法代码实现(C++)</h2>
<p>理解了A星的基本原理之后,接下来我们使用C++实现一个A星的基本算法流程。</p>
<p><strong>0.相关头文件</strong></p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">vector</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">queue</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">cmath</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">unordered_map</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">algorithm</span><span>&gt;
</span></code></pre>
<hr />
<h3 id="-3"><strong>1. Node结构</strong></h3>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#65737e;">// 节点结构体
</span><span style="color:#b48ead;">struct </span><span>Node {
</span><span>    </span><span style="color:#b48ead;">int</span><span> x, y;       </span><span style="color:#65737e;">// 坐标
</span><span>    </span><span style="color:#b48ead;">float</span><span> g, h;     </span><span style="color:#65737e;">// g: 从起点到当前节点的代价, h: 启发式估价
</span><span>    Node* parent;   </span><span style="color:#65737e;">// 父节点指针, 用于回溯路径
</span><span>
</span><span>    </span><span style="color:#8fa1b3;">Node</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span>, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">y</span><span>, </span><span style="color:#b48ead;">float </span><span style="color:#bf616a;">g</span><span>, </span><span style="color:#b48ead;">float </span><span style="color:#bf616a;">h</span><span>, Node* </span><span style="color:#bf616a;">parent </span><span>= </span><span style="color:#d08770;">nullptr</span><span>)
</span><span>        : </span><span style="color:#bf616a;">x</span><span>(x), </span><span style="color:#bf616a;">y</span><span>(y), </span><span style="color:#bf616a;">g</span><span>(g), </span><span style="color:#bf616a;">h</span><span>(h), </span><span style="color:#bf616a;">parent</span><span>(parent) {}
</span><span>
</span><span>    </span><span style="color:#b48ead;">float </span><span style="color:#8fa1b3;">f</span><span>() </span><span style="color:#b48ead;">const </span><span>{ </span><span style="color:#b48ead;">return</span><span> g + h; } </span><span style="color:#65737e;">// 计算总代价 f = g + h
</span><span>};
</span></code></pre>
<blockquote>
<ul>
<li>
<p>g：从起点到当前节点的 <strong>真实代价</strong>（步数）。</p>
</li>
<li>
<p>h：当前节点到目标点的 <strong>估算代价</strong>（启发式函数）。</p>
</li>
<li>
<p>f = g + h：总代价，A* 总是优先选择 f 最小的节点。</p>
</li>
</ul>
</blockquote>
<hr />
<p><strong>2.定义<code>Compare</code>结构体</strong></p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#65737e;">// 优先队列比较器, 使得 f 值较小的节点优先出队
</span><span style="color:#b48ead;">struct </span><span>Compare {
</span><span>    </span><span style="color:#b48ead;">bool </span><span style="color:#8fa1b3;">operator()</span><span>(</span><span style="color:#b48ead;">const</span><span> Node* </span><span style="color:#bf616a;">a</span><span>, </span><span style="color:#b48ead;">const</span><span> Node* </span><span style="color:#bf616a;">b</span><span>) {
</span><span>        </span><span style="color:#b48ead;">return</span><span> a-&gt;</span><span style="color:#bf616a;">f</span><span>() &gt; b-&gt;</span><span style="color:#bf616a;">f</span><span>();
</span><span>    }
</span><span>};
</span></code></pre>
<blockquote>
<p>由于优先队列<code>priority_queue</code>默认是 <strong>大顶堆(最大值优先)</strong>,但 <code>A* </code>需要 <strong>f 值最小</strong> 的优先出队，因此这里实现了 <strong>小顶堆</strong>（f 小的优先）。</p>
</blockquote>
<hr />
<p><strong>3.启发式函数</strong></p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#65737e;">// 启发式函数: 使用曼哈顿距离（适用于只能水平或垂直移动的情况）
</span><span style="color:#b48ead;">float </span><span style="color:#8fa1b3;">heuristic</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x1</span><span>, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">y1</span><span>, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x2</span><span>, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">y2</span><span>) {
</span><span>    </span><span style="color:#b48ead;">return </span><span>std::</span><span style="color:#96b5b4;">abs</span><span>(x1 - x2) + std::</span><span style="color:#96b5b4;">abs</span><span>(y1 - y2);
</span><span>}
</span></code></pre>
<blockquote>
<ul>
<li>曼哈顿距离 <strong>适用于网格地图</strong>（只能水平/垂直移动）。</li>
<li>后续也会给出其他几种函数的代码参考,你可以自己更换不同的启发函数来研究不同情况下的<code>A*</code></li>
</ul>
</blockquote>
<p><strong>4. A*搜索主方法</strong></p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#65737e;">// A* 搜索算法
</span><span>std::vector&lt;std::pair&lt;</span><span style="color:#b48ead;">int</span><span>, </span><span style="color:#b48ead;">int</span><span>&gt;&gt; </span><span style="color:#8fa1b3;">aStarSearch</span><span>(std::vector&lt;std::vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&gt;&amp; </span><span style="color:#bf616a;">grid</span><span>,
</span><span>                                             std::pair&lt;</span><span style="color:#b48ead;">int</span><span>, </span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">start</span><span>,
</span><span>                                             std::pair&lt;</span><span style="color:#b48ead;">int</span><span>, </span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">goal</span><span>) {
</span><span>    </span><span style="color:#b48ead;">int</span><span> rows = grid.</span><span style="color:#bf616a;">size</span><span>(), cols = grid[</span><span style="color:#d08770;">0</span><span>].</span><span style="color:#bf616a;">size</span><span>();
</span><span>    std::priority_queue&lt;Node*, std::vector&lt;Node*&gt;, Compare&gt; openSet; </span><span style="color:#65737e;">// 优先队列
</span><span>    std::unordered_map&lt;</span><span style="color:#b48ead;">int</span><span>, Node*&gt; allNodes; </span><span style="color:#65737e;">// 记录所有访问过的节点
</span><span>
</span><span>    </span><span style="color:#65737e;">// 创建起始节点并放入开启列表
</span><span>    Node* startNode = </span><span style="color:#b48ead;">new </span><span style="color:#bf616a;">Node</span><span>(start.</span><span style="color:#bf616a;">first</span><span>, start.</span><span style="color:#bf616a;">second</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#bf616a;">heuristic</span><span>(start.</span><span style="color:#bf616a;">first</span><span>, start.</span><span style="color:#bf616a;">second</span><span>, goal.</span><span style="color:#bf616a;">first</span><span>, goal.</span><span style="color:#bf616a;">second</span><span>));
</span><span>    openSet.</span><span style="color:#bf616a;">push</span><span>(startNode);
</span><span>    allNodes[start.</span><span style="color:#bf616a;">first </span><span>* cols + start.</span><span style="color:#bf616a;">second</span><span>] = startNode;
</span><span>
</span><span>    </span><span style="color:#65737e;">// 4个移动方向（右、下、左、上）
</span><span>    std::vector&lt;std::pair&lt;</span><span style="color:#b48ead;">int</span><span>, </span><span style="color:#b48ead;">int</span><span>&gt;&gt; directions = {{</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">1</span><span>}, {</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>}, {</span><span style="color:#d08770;">0</span><span>, -</span><span style="color:#d08770;">1</span><span>}, {-</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>}};
</span><span>    std::vector&lt;std::pair&lt;</span><span style="color:#b48ead;">int</span><span>, </span><span style="color:#b48ead;">int</span><span>&gt;&gt; path;
</span><span>
</span><span>    </span><span style="color:#b48ead;">while </span><span>(!openSet.</span><span style="color:#bf616a;">empty</span><span>()) {
</span><span>        Node* current = openSet.</span><span style="color:#bf616a;">top</span><span>(); </span><span style="color:#65737e;">// 取出当前代价最小的节点
</span><span>        openSet.</span><span style="color:#bf616a;">pop</span><span>();
</span><span>
</span><span>        </span><span style="color:#65737e;">// 如果到达目标点，回溯路径
</span><span>        </span><span style="color:#b48ead;">if </span><span>(current-&gt;</span><span style="color:#bf616a;">x </span><span>== goal.</span><span style="color:#bf616a;">first </span><span>&amp;&amp; current-&gt;</span><span style="color:#bf616a;">y </span><span>== goal.</span><span style="color:#bf616a;">second</span><span>) {
</span><span>            </span><span style="color:#b48ead;">while </span><span>(current) {
</span><span>                path.</span><span style="color:#bf616a;">emplace_back</span><span>(current-&gt;</span><span style="color:#bf616a;">x</span><span>, current-&gt;</span><span style="color:#bf616a;">y</span><span>);
</span><span>                current = current-&gt;</span><span style="color:#bf616a;">parent</span><span>;
</span><span>            }
</span><span>            std::</span><span style="color:#bf616a;">reverse</span><span>(path.</span><span style="color:#bf616a;">begin</span><span>(), path.</span><span style="color:#bf616a;">end</span><span>());
</span><span>            </span><span style="color:#b48ead;">break</span><span>;
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#65737e;">// 遍历 4 个方向的邻居节点
</span><span>        </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">auto </span><span>[dx, dy] : directions) {
</span><span>            </span><span style="color:#b48ead;">int</span><span> nx = current-&gt;</span><span style="color:#bf616a;">x </span><span>+ dx, ny = current-&gt;</span><span style="color:#bf616a;">y </span><span>+ dy;
</span><span>
</span><span>            </span><span style="color:#65737e;">// 边界检查和障碍物检查
</span><span>            </span><span style="color:#b48ead;">if </span><span>(nx &lt; </span><span style="color:#d08770;">0 </span><span>|| ny &lt; </span><span style="color:#d08770;">0 </span><span>|| nx &gt;= rows || ny &gt;= cols || grid[nx][ny] == </span><span style="color:#d08770;">1</span><span>)
</span><span>                </span><span style="color:#b48ead;">continue</span><span>;
</span><span>
</span><span>            </span><span style="color:#b48ead;">float </span><span style="color:#bf616a;">gNew </span><span>= current-&gt;</span><span style="color:#bf616a;">g </span><span>+ </span><span style="color:#d08770;">1</span><span>; </span><span style="color:#65737e;">// g 值 +1 (假设所有移动的代价相等)
</span><span>            </span><span style="color:#b48ead;">float</span><span> hNew = </span><span style="color:#bf616a;">heuristic</span><span>(nx, ny, goal.</span><span style="color:#bf616a;">first</span><span>, goal.</span><span style="color:#bf616a;">second</span><span>);
</span><span>            </span><span style="color:#b48ead;">int</span><span> key = nx * cols + ny;
</span><span>
</span><span>            </span><span style="color:#65737e;">// 如果该节点未被访问或找到更短路径
</span><span>            </span><span style="color:#b48ead;">if </span><span>(!allNodes.</span><span style="color:#bf616a;">count</span><span>(key) || </span><span style="color:#bf616a;">gNew </span><span>&lt; allNodes[key]-&gt;</span><span style="color:#bf616a;">g</span><span>) {
</span><span>                </span><span style="color:#b48ead;">auto</span><span> neighbor = </span><span style="color:#b48ead;">new </span><span style="color:#bf616a;">Node</span><span>(nx, ny, </span><span style="color:#bf616a;">gNew</span><span>, hNew, current);
</span><span>                openSet.</span><span style="color:#bf616a;">push</span><span>(neighbor);
</span><span>                allNodes[key] = neighbor;
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// 释放所有节点的内存
</span><span>    </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">auto</span><span>&amp; [_, node] : allNodes)
</span><span>        </span><span style="color:#b48ead;">delete</span><span> node;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return</span><span> path;
</span><span>}
</span></code></pre>
<p><strong>5.路径字符化(可选)</strong></p>
<blockquote>
<p>这不是算法必须的步骤,添加这部分代码主要是用来打印路径字符,直观的理解搜索的结果。</p>
</blockquote>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#65737e;">// 可视化打印路径
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">printGridWithPath</span><span>(std::vector&lt;std::vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&gt;&amp; </span><span style="color:#bf616a;">grid</span><span>, </span><span style="color:#b48ead;">const</span><span> std::vector&lt;std::pair&lt;</span><span style="color:#b48ead;">int</span><span>, </span><span style="color:#b48ead;">int</span><span>&gt;&gt;&amp; </span><span style="color:#bf616a;">path</span><span>,
</span><span>                       std::pair&lt;</span><span style="color:#b48ead;">int</span><span>, </span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">start</span><span>, std::pair&lt;</span><span style="color:#b48ead;">int</span><span>, </span><span style="color:#b48ead;">int</span><span>&gt; </span><span style="color:#bf616a;">goal</span><span>) {
</span><span>    std::vector&lt;std::vector&lt;</span><span style="color:#b48ead;">char</span><span>&gt;&gt; </span><span style="color:#bf616a;">display</span><span>(grid.</span><span style="color:#bf616a;">size</span><span>(), std::</span><span style="color:#bf616a;">vector</span><span>&lt;</span><span style="color:#b48ead;">char</span><span>&gt;(grid[</span><span style="color:#d08770;">0</span><span>].</span><span style="color:#bf616a;">size</span><span>(), &#39; &#39;));
</span><span>
</span><span>    </span><span style="color:#65737e;">// 初始化网格，障碍物用 &#39;#&#39; 标记
</span><span>    </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">0</span><span>; i &lt; grid.</span><span style="color:#bf616a;">size</span><span>(); ++i) {
</span><span>        </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> j = </span><span style="color:#d08770;">0</span><span>; j &lt; grid[</span><span style="color:#d08770;">0</span><span>].</span><span style="color:#bf616a;">size</span><span>(); ++j) {
</span><span>            display[i][j] = (grid[i][j] == </span><span style="color:#d08770;">1</span><span>) ? &#39;</span><span style="color:#a3be8c;">#</span><span>&#39; : &#39;</span><span style="color:#a3be8c;">.</span><span>&#39;;
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// 绘制路径
</span><span>    </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">const auto</span><span>&amp; [x, y] : path) {
</span><span>        display[x][y] = &#39;</span><span style="color:#a3be8c;">*</span><span>&#39;;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// 标记起点和终点
</span><span>    display[start.</span><span style="color:#bf616a;">first</span><span>][start.</span><span style="color:#bf616a;">second</span><span>] = &#39;</span><span style="color:#a3be8c;">S</span><span>&#39;;
</span><span>    display[goal.</span><span style="color:#bf616a;">first</span><span>][goal.</span><span style="color:#bf616a;">second</span><span>] = &#39;</span><span style="color:#a3be8c;">G</span><span>&#39;;
</span><span>
</span><span>    </span><span style="color:#65737e;">// 打印网格
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">A* 搜索路径:</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">const auto</span><span>&amp; row : display) {
</span><span>        </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">char</span><span> cell : row) {
</span><span>            std::cout &lt;&lt; cell &lt;&lt; &#39; &#39;;
</span><span>        }
</span><span>        std::cout &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>    }
</span><span>}
</span></code></pre>
<p>字符化地图说明:</p>
<blockquote>
<p>#：障碍物</p>
<p>.：可行区域</p>
<p>*：路径</p>
<p>S：起点</p>
<p>G：终点</p>
</blockquote>
<hr />
<p><strong>5. 主函数</strong></p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>   std::vector&lt;std::vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt;&gt; grid =
</span><span>        {
</span><span>          {</span><span style="color:#d08770;">0</span><span>,</span><span style="color:#d08770;">0</span><span>,</span><span style="color:#d08770;">1</span><span>,</span><span style="color:#d08770;">0</span><span>},
</span><span>          {</span><span style="color:#d08770;">1</span><span>,</span><span style="color:#d08770;">0</span><span>,</span><span style="color:#d08770;">0</span><span>,</span><span style="color:#d08770;">0</span><span>},
</span><span>          {</span><span style="color:#d08770;">0</span><span>,</span><span style="color:#d08770;">1</span><span>,</span><span style="color:#d08770;">0</span><span>,</span><span style="color:#d08770;">0</span><span>},
</span><span>          {</span><span style="color:#d08770;">0</span><span>,</span><span style="color:#d08770;">1</span><span>,</span><span style="color:#d08770;">0</span><span>,</span><span style="color:#d08770;">0</span><span>},
</span><span>        };
</span><span>
</span><span>    std::pair&lt;</span><span style="color:#b48ead;">int</span><span>, </span><span style="color:#b48ead;">int</span><span>&gt; start = {</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>};
</span><span>    std::pair&lt;</span><span style="color:#b48ead;">int</span><span>, </span><span style="color:#b48ead;">int</span><span>&gt; goal = {</span><span style="color:#d08770;">6</span><span>, </span><span style="color:#d08770;">6</span><span>};
</span><span>
</span><span>    </span><span style="color:#b48ead;">auto</span><span> path = </span><span style="color:#bf616a;">aStarSearch</span><span>(grid, start, goal);
</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span>(path.</span><span style="color:#bf616a;">empty</span><span>()) {
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">未找到可行路径!</span><span>&quot; &lt;&lt; std::endl;
</span><span>    } </span><span style="color:#b48ead;">else </span><span>{
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">最短路径:</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>        </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">auto </span><span>[x, y] : path)
</span><span>            std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">(</span><span>&quot; &lt;&lt; x &lt;&lt; &quot;</span><span style="color:#a3be8c;">, </span><span>&quot; &lt;&lt; y &lt;&lt; &quot;</span><span style="color:#a3be8c;">) -&gt; </span><span>&quot;;
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">目标点</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>        </span><span style="color:#bf616a;">printGridWithPath</span><span>(grid, path, start, goal);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p><img src="https://images.waer.ltd/notes/202503181535055.png" alt="image-20250318153504868" loading="lazy" decoding="async" /></p>
<hr />
<h2 id="-4">关于A*的一些优化方向</h2>
<p>原生的A星算法已经相对高效,但是在大规模地图或者复杂路径规划的问题中可能会遇到性能瓶颈。因此具体的优化方向还得取决于具体的问题,这里只是列出一些常见的优化方向,作为学习指南。</p>
<h3 id="-5">数据结构上的优化</h3>
<blockquote>
<p>这里的数据结构优化基于本文实现的代码而言。</p>
</blockquote>
<p><code>A*</code> 依赖 <strong>openSet</strong>（开启列表），当前实现使用的是 <code>std::priority_queue</code>，但是 <code>std::priority_queue</code> <strong>不支持高效的更新操作</strong>，这可能导致节点重复入队并降低性能。</p>
<p>因此,可以使用<code>std::unordered_map+最小堆</code>进行优化:</p>
<ul>
<li><code>std::unordered_map</code> 存储节点索引，最小堆（<code>Binary Heap</code>）用于快速取出 <code>f(n)</code> 最小的节点。</li>
<li>需要额外维护一个哈希表来存储节点的位置，以支持 <strong>堆的 decrease-key 操作</strong>。</li>
</ul>
<hr />
<h3 id="-6">启发式函数的选择</h3>
<p>这个没啥说的,最基本的原则就是根据项目的类型来选择不同的启发式函数。</p>
<hr />
<h3 id="-7">逻辑上的优化</h3>
<p>常见的优化方向有:</p>
<ul>
<li>双向<code>A*</code>:同时从起点和终点进行搜索,相遇时停止。</li>
<li>跳点搜索(<code>JPS</code>):跳过冗余的节点,适用于规则网格地图,可以极大的减少搜索空间。</li>
<li>图割方法(对称<code>A*</code>):在动态地图中,分割图像区域,减少搜索范围。</li>
</ul>
<hr />
<blockquote>
<p>欢迎关注后续更新….</p>
</blockquote>

        </div>
      </div>
      <div class="prompt" id="terminal"><input
    type="text"
    id="setter"
    onkeydown="writeit(this, event);moveIt(this.value.length, event)"
    onchange="writeit(this, event)"
    onkeyup="writeit(this, event)"
    onkeypress="writeit(this, event);"
    >
<label for="setter" id="writer"> </label><b class="cursor" id="cursor"></b></div>
      <footer class="footer">
        <div class="footer-content">
          <p class="icp-info">
            <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer">黔ICP备2021010295号</a>
          </p>
        </div>
      </footer>
    </main>
  </body>

</html>
