<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>慕予博客</title>
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"
    integrity="sha256-WCzAhd2P6gRJF9Hv3oOOd+hFJi/QJbv+Azn4CGB8gfY=" crossorigin="anonymous" defer></script>
  <script src="/js/index.js" defer></script>
  <script src="/js/prompt.js" defer></script>
  <script src="/js/keyboard.js" defer></script>
  <script src="/js/tab.js" defer></script>
  <script src="/js/commands.js" defer></script>
  <script src="/js/config.js" defer></script><script src="/config.js"></script><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="style.css"><link rel="stylesheet" href="/css/page.css"></head><body onkeydown="exec(event)" style="background-image: url(&#x27;&#x2F;assets&#x2F;bg.jpg&#x27;); "><main>
      <div class="files" id="files" tabindex="0">
<ul>

  <li class="file">
    <span><a href='https://ilikexff.cn/8-kuan-rang-ni-kai-fa-qi-fei-de-intellijidea-cha-jian/'
      tabindex="-2">  8款让你开发起飞的IntellijIDEA插件</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/aop-jie-mi-qie-mian-bian-cheng-de-zong-he-zhi-nan/'
      tabindex="-3">  AOP揭秘：切面编程的综合指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-mei-ju-pian-yi-wu-fan-wei-mei-ju/'
      tabindex="-4">  C++游戏开发基础-枚举篇一：无范围枚举</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-std-optional/'
      tabindex="-5">  C++游戏开发基础-深入解析std::optional</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shen-ru-jie-xi-thiszhi-zhen-de-ying-yong-yu-ji-qiao/'
      tabindex="-6">  C++游戏开发基础-深入解析this指针的应用与技巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-fu-zhi-gou-zao-han-shu/'
      tabindex="-7">  C++游戏开发基础-深入解析复制构造函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-mo-ban-he-can-shu-tui-dao-zhi-nan/'
      tabindex="-8">  C++游戏开发基础-类模版和参数推导指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/dockerbi-zhi-bi-hui/'
      tabindex="-9">  Docker必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/githithub-xiao-ce/'
      tabindex="-10">  GitGitHub小册</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/google-hacking/'
      tabindex="-11">  Google Hacking</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/googleguan-fang-ti-shi-gong-cheng-bai-pi-shu-zhong-wen-yi-ben/'
      tabindex="-12">  Google官方《提示工程白皮书（中文译本）》</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-dai-ma-bu-quan-ti-shi-gong-neng-xiao-shi-de-ji-chong-jie-jue-fang-an-re-geng-ban/'
      tabindex="-13">  IDEA代码补全&amp;提示功能消失的几种解决方案(热更版)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-chen-jin-shi-bian-cheng-ti-yan/'
      tabindex="-14">  IDEA沉浸式编程体验</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-han-shu-shi-bian-cheng/'
      tabindex="-15">  Java函数式编程</a></span>
  </li><li class="file">
    <span><a class="selected"href='https://ilikexff.cn/java-ji-he-yuan-ma-qian-xi/'
      tabindex="-16">  Java集合源码浅析</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mysql-shi-wu-te-xing-yu-ge-chi-ji-bie-xiang-jie/'
      tabindex="-17">  MySQL_事务特性与隔离级别详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ocao-zuo-fu-shi-xian-mei-ju-de-shu-ru-shu-chu/'
      tabindex="-18">  O操作符,实现枚举的输入输出</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/prdsuan-fa-ting-shuo-ni-xiang-ping-yun-qi-chou-yi-ke-rong-yao-shui-jing/'
      tabindex="-19">  PRD算法：听说你想凭运气抽一颗荣耀水晶?</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/picgo-pei-zhi-ge-chong-tu-chuang/'
      tabindex="-20">  PicGo配置各种图床</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/redis-bi-zhi-bi-hui/'
      tabindex="-21">  Redis必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-zhong-de-move-yu-yi-sui-bi/'
      tabindex="-22">  Rust中的move语义随笔</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ssm-kuang-jia-shi-xian-ji-cheng-duan-xin-yan-zheng-ma-gong-neng/'
      tabindex="-23">  SSM框架实现集成短信验证码功能</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/slf4jyu-logbackshi-yong-zhi-nan-ji-yu-gradle/'
      tabindex="-24">  Slf4j与Logback实用指南(基于Gradle)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/spring-security5-xdao-spring-security6-xde-qian-yi/'
      tabindex="-25">  Spring Security5.x到Spring Security6.x的迁移</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springboot-webkai-fa-jing-jie/'
      tabindex="-26">  SpringBoot Web开发精解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springsecurity/'
      tabindex="-27">  SpringSecurity</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/unity6xia-jia-zhong-guo-qu-tuan-jie-yin-qing-jie-bang-zhe-shi-fen-lie-huan-shi-ben-di-hua-de-kai-shi/'
      tabindex="-28">  Unity6下架中国区，团结引擎接棒：这是分裂，还是本地化的开始？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-cong-0-dao-1-da-zao-quan-yu-yan-zhi-chi-de-mo-neng-bian-ji-qi-yu-fa-pian/'
      tabindex="-29">  Vim从0到1打造全语言支持的万能编辑器-语法篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-tiao-tou-powershell-pian/'
      tabindex="-30">  Vim折腾之 PowerShell篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-di-zhi-chuan-di-xiang-jie/'
      tabindex="-31">  [C++游戏开发基础]:地址传递详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-yin-yong-fan-hui-he-di-zhi-fan-hui/'
      tabindex="-32">  [C++游戏开发基础]:引用返回和地址返回</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-he-const/'
      tabindex="-33">  [C++游戏开发基础]:指针和const</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shu-ju-feng-zhuang-yin-cang-de-hao-chu/'
      tabindex="-34">  [C++游戏开发基础]:数据封装(隐藏)的好处</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-gou-zao-han-shu-qian-xi-8000zi/'
      tabindex="-35">  [C++游戏开发基础]:构造函数浅析(8000字)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-li-jie-kong-zhi-zhen/'
      tabindex="-36">  [C++游戏开发基础]:理解空指针</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-zhong-de-fang-wen-han-shu/'
      tabindex="-37">  [C++游戏开发基础]:类中的访问函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-de-ji-ben-gai-nian-li-jie/'
      tabindex="-38">  [C++游戏开发基础]指针的基本概念理解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/fanatical-wu-yue-feng-kuang-te-hui-wei-ni-de-steam-ku-jia-dian-liao/'
      tabindex="-39">  _Fanatical 五月疯狂特惠：为你的 Steam 库加点料！</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-kai-yuan-mi-ma-gong-ju-xpwd-zhong-wen-ban-bian-geng-ri-zhi/'
      tabindex="-40">  _Rust开源密码工具xpwd中文版变更日志</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/readme/'
      tabindex="-41">  readme</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wblog-bo-ke-xian-shang-bu-shu/'
      tabindex="-42">  wblog博客线上部署</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/shang-gu-shen-qi-vim-su-cheng-bei-wang-lu/'
      tabindex="-43">  上古神器_Vim速成备忘录</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mian-fei-ji-huo-quan-ban-ben-typora-zui-xin-ban-wei-li/'
      tabindex="-44">  免费激活全版本Typora，最新版为例</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-lombokxian-wei-ren-zhi-de-ji-ge-qi-ji-yin-qiao/'
      tabindex="-45">  关于Lombok鲜为人知的几个奇技淫巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-jie-kou-xian-liu-de-yi-ci-jian-dan-shi-jian/'
      tabindex="-46">  关于接口限流的一次简单实践</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/tu-jie-er-jin-zhi/'
      tabindex="-47">  图解二进制</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ru-he-xie-de-yi-shou-you-ya-gui-fan-de-springboot-jie-kou/'
      tabindex="-48">  如何写得一手优雅规范的SpringBoot 接口？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/kai-fa-bi-hui-xi-lie-jwtqian-tan/'
      tabindex="-49">  开发必会系列_JWT浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ji-qiao-jiu-shi-xiao-lu-chatgpt-diao-jiao-zhi-bei/'
      tabindex="-50">  技巧就是效率，ChatGPT调教指北</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-sheng-intellij-kai-fa-xiao-lu-zhe-kuan-dai-ma-tu-ding-cha-jian-codepins-zhi-de-yi-shi/'
      tabindex="-51">  提升 IntelliJ 开发效率？这款代码图钉插件 CodePins 值得一试</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-wen-de-zhi-hui-zhuan-zai/'
      tabindex="-52">  提问的智慧转载</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiao-lu-gong-ju-markdown/'
      tabindex="-53">  效率工具Markdown</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wu-wei-bing-fa-rust-sheng-ming-zhou-qi-qian-tan/'
      tabindex="-54">  无畏并发_Rust 生命周期浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-yu-de-bei-sai-er-qu-xian-gan-shou-si-hua-de-shu-xue-zhi-mei/'
      tabindex="-55">  游戏开发与的贝塞尔曲线_感受丝滑的数学之美</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-bi-bei-gao-xiao-de-aabb-qiu-ti-he-obb-peng-zhuang-jian-ce-suan-fa/'
      tabindex="-56">  游戏开发必备：高效的 AABB、球体和 OBB 碰撞检测算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-suan-fa-ji-chu-a-xun-lu-suan-fa-chi-xu-wei-hu/'
      tabindex="-57">  游戏算法基础-深入解析A*寻路算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/du-li-you-xi-kai-fa-zhe-gong-ju-xiang-2025jing-xuan-tui-jian-yu-shi-yong-zhi-nan/'
      tabindex="-58">  独立游戏开发者工具箱：2025精选推荐与实用指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xu-huan-yin-qing-you-xi-kai-fa-xi-lie-zhuan-ti-guan-fang-bian-ma-biao-zhun-huo-gui-yue/'
      tabindex="-59">  虚幻引擎游戏开发系列专题-官方编码标准或规约</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiang-jie-she-ji-mo-shi-dan-li-de-jin-hua-zhi-lu/'
      tabindex="-60">  详解设计模式_单例的进化之路</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xie-e-de-fei-chang-liang-quan-ju-bian-liang/'
      tabindex="-61">  邪恶的非常量全局变量</a></span>
  </li>
</ul>
</div>
      <div class="viewer page" id="viewer" tabindex="0">
        <div class="tab">
<div class="file-manager" onclick='document.getElementById("files").classList.toggle("open"); document.getElementById("content").classList.toggle("close")'> </div>
<ul id="tabs">
</ul>


</div>
        <div class="content" id="content"><h3 id="geng-xin-ri-zhi-tada">更新日志🎉</h3>
<p>2023-01-29 星期六</p>
<blockquote>
<ul>
<li>修正一些已知错误</li>
<li>调整文章布局结构</li>
<li>修正错别字词</li>
</ul>
</blockquote>
<p>2022-05-26 10:20:23 星期四</p>
<blockquote>
<ul>
<li>修正语言表达逻辑</li>
<li>删除/修改了错别字词</li>
<li>更新了部分配图</li>
</ul>
</blockquote>
<p>2022-08-02</p>
<blockquote>
<ul>
<li>修正错别字</li>
<li>修正语言表达逻辑</li>
</ul>
</blockquote>
<p>2022-08-22</p>
<blockquote>
<ul>
<li>还是修已知的正错别词语</li>
</ul>
</blockquote>
<hr />
<hr />
<p>Java集合解读</p>
<h2 id="ideakuai-jie-jian">IDEA快捷键</h2>
<blockquote>
<p>查看源码:F4</p>
<p>进入实现:Ctrl+Alt+B(鼠标点击)</p>
<p>添加实现类:空格</p>
<p>显示图:Ctrl+Alt+Shift+U</p>
</blockquote>
<h2 id="gai-lan">概览</h2>
<p>**说明：**以下内容的源码分析，如没有特别说明，均来自JDK8.</p>
<blockquote>
<ol>
<li>
<p>集合主要分为两组：单列集合和双列集合</p>
<blockquote>
<p>但列集合一般是指存放单个对象的集合，而双列集合一般是以&lt;k,v&gt;键值对形式存放数据的集合。</p>
</blockquote>
</li>
<li>
<p><code>Collection</code>接口下有两个重要的子接口<code>List</code>,<code>Set</code>，他们的实现子类都是单列集合。</p>
</li>
<li>
<p><code>Map</code>接口的实现子类有<code>HashTable</code>、<code>HashMap</code>、<code>TreeMap</code>,也都是双列集合。</p>
</li>
<li>
<p>以下是集合类下两大主接口的类图关系。</p>
</li>
</ol>
</blockquote>
<h3 id="collectionxi"><strong>Collection系</strong></h3>
<p><img src="https://images.waer.ltd/img/20220525092920.png" alt="" loading="lazy" decoding="async" /></p>
<blockquote>
<p>在Conllection接口下，派生出了三个主要的子接口，分别为无序集合<code>Set</code>,队列<code>Queue</code>和有序集合<code>List</code>。在三大子接口之下，还有着众多的实现子类或者派生的子接口，其中最常用的有：</p>
</blockquote>
<ul>
<li>TreeSet</li>
<li>LinkedHashSet</li>
<li>HashSet</li>
<li>LinkedList</li>
<li>ArrayList</li>
<li>Stack</li>
</ul>
<hr />
<h3 id=""><strong>Map系</strong></h3>
<p><img src="https://images.waer.ltd/img/20220525092947.png" alt="" loading="lazy" decoding="async" /></p>
<blockquote>
<p><code>Map</code>集合为双列集合。<code>Map</code>**没有直接继承的子接口,**主要有三个实现类，分别是<code>HashMap</code>、<code>HashTable</code>、<code>SortedMap</code>。在三个主要实现之下，比较常用的实现及其实现子类有：</p>
<ul>
<li><code>HashMap</code>(性能高，非线程安全)</li>
<li><code>Hashtable</code>(性能较低，线程安全，但属于老旧的API，一般不推荐使用)</li>
<li><code>TreeMap</code>(有序<code>map</code>)</li>
</ul>
</blockquote>
<hr />
<h2 id="-1">细说</h2>
<h3 id="collection"><code>Collection</code></h3>
<p>由于<code>Collection</code>接口直接继承了<code>Iterable</code>，它是没有实现的，它的所有方法都是由它的<strong>子接口</strong>的实现类进行实现，所以这里就以<code>Collection</code>下子接口<code>List</code>的实现类<code>ArrayList</code>来讲解。注意<code>List</code>是<strong>有序集合且元素可以重复</strong>，而<code>Set</code>则是<strong>无序集合，元素不可重复</strong>。</p>
<p><strong>讲解的方法列表</strong></p>
<blockquote>
<ul>
<li>add:添加单个元素</li>
<li>remove：输出指定元素</li>
<li>contains:查找元素是否存在</li>
<li>size:获取元素个数</li>
<li>isEmpty:判断是否为空</li>
<li>clear:清空</li>
<li>addAll:添加多个元素</li>
<li>containsAll:查找多个元素是否都存在</li>
<li>removeAll:输出多个元素</li>
</ul>
</blockquote>
<p><strong>基本用法演示</strong></p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#ebcb8b;">List</span><span> list = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ArrayList</span><span>();
</span><span style="color:#65737e;">/*添加单个元素*/
</span><span>list.</span><span style="color:#bf616a;">add</span><span>(&quot;</span><span style="color:#a3be8c;">Jack</span><span>&quot;);
</span><span style="color:#65737e;">//这里其实是一个自动装箱的操作:list.add(new Integer(10))
</span><span>list.</span><span style="color:#bf616a;">add</span><span>(</span><span style="color:#d08770;">10</span><span>);
</span><span>list.</span><span style="color:#bf616a;">add</span><span>(</span><span style="color:#d08770;">true</span><span>);
</span><span style="color:#ebcb8b;">System</span><span>.out.</span><span style="color:#bf616a;">println</span><span>(&quot;</span><span style="color:#a3be8c;">list:</span><span>&quot;+list);
</span><span>
</span><span style="color:#65737e;">/*输出元素*/
</span><span style="color:#65737e;">//输出&quot;Jack&quot;
</span><span style="color:#65737e;">//list.remove(0);
</span><span style="color:#65737e;">//指定输出某个元素
</span><span>list.</span><span style="color:#bf616a;">remove</span><span>(</span><span style="color:#d08770;">true</span><span>);
</span><span style="color:#ebcb8b;">System</span><span>.out.</span><span style="color:#bf616a;">println</span><span>(&quot;</span><span style="color:#a3be8c;">输出后的[list]:</span><span>&quot;+list);
</span><span>
</span><span style="color:#65737e;">/*查找某个元素是否存在*/
</span><span style="color:#65737e;">//true
</span><span style="color:#ebcb8b;">System</span><span>.out.</span><span style="color:#bf616a;">println</span><span>(list.</span><span style="color:#bf616a;">contains</span><span>(&quot;</span><span style="color:#a3be8c;">Jack</span><span>&quot;));
</span><span>
</span><span style="color:#65737e;">/*获取元素个数*/
</span><span style="color:#65737e;">//2
</span><span style="color:#ebcb8b;">System</span><span>.out.</span><span style="color:#bf616a;">println</span><span>(list.</span><span style="color:#bf616a;">size</span><span>());
</span><span>
</span><span style="color:#65737e;">/*判断集合是否为空*/
</span><span style="color:#65737e;">//false
</span><span style="color:#ebcb8b;">System</span><span>.out.</span><span style="color:#bf616a;">println</span><span>(list.</span><span style="color:#bf616a;">isEmpty</span><span>());
</span><span>
</span><span style="color:#65737e;">/*清空集合*/
</span><span>list.</span><span style="color:#bf616a;">clear</span><span>();
</span><span style="color:#65737e;">//清空后的[list]：[]
</span><span style="color:#ebcb8b;">System</span><span>.out.</span><span style="color:#bf616a;">println</span><span>(&quot;</span><span style="color:#a3be8c;">清空后的[list]：</span><span>&quot;+list);
</span><span>
</span><span style="color:#65737e;">/*添加多个元素*/
</span><span style="color:#ebcb8b;">ArrayList</span><span> list2 = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ArrayList</span><span>();
</span><span>list2.</span><span style="color:#bf616a;">add</span><span>(&quot;</span><span style="color:#a3be8c;">西游记</span><span>&quot;);
</span><span>list2.</span><span style="color:#bf616a;">add</span><span>(&quot;</span><span style="color:#a3be8c;">西厢记</span><span>&quot;);
</span><span>list.</span><span style="color:#bf616a;">addAll</span><span>(list2);
</span><span style="color:#65737e;">//添加多个元素后的[list]:[西游记, 西厢记]
</span><span style="color:#ebcb8b;">System</span><span>.out.</span><span style="color:#bf616a;">println</span><span>(&quot;</span><span style="color:#a3be8c;">添加多个元素后的[list]:</span><span>&quot;+list);
</span><span>
</span><span style="color:#65737e;">/*判断多个元素是否都存在*/
</span><span style="color:#65737e;">//true
</span><span style="color:#ebcb8b;">System</span><span>.out.</span><span style="color:#bf616a;">println</span><span>(list.</span><span style="color:#bf616a;">containsAll</span><span>(list2));
</span><span>
</span><span style="color:#65737e;">/*输出多个元素*/
</span><span>list.</span><span style="color:#bf616a;">add</span><span>(&quot;</span><span style="color:#a3be8c;">华强北</span><span>&quot;);
</span><span style="color:#65737e;">//true
</span><span style="color:#ebcb8b;">System</span><span>.out.</span><span style="color:#bf616a;">println</span><span>(list.</span><span style="color:#bf616a;">removeAll</span><span>(list2));
</span><span style="color:#65737e;">//华强北
</span><span style="color:#ebcb8b;">System</span><span>.out.</span><span style="color:#bf616a;">println</span><span>(list);
</span></code></pre>
<p><strong>遍历用法</strong></p>
<blockquote>
<p>上面的类图已经知道，<code>Collection</code>接口还有一个<code>Iterable</code>父接口。它的部分实现源码中第一个方法如下:</p>
<p><img src="https://images.waer.ltd/img/20220320114101.png" alt="" loading="lazy" decoding="async" /></p>
<p>可以看到，该方法可以返回元素的<code>iterator</code>对象。只要是实现了接口的所有子类，都有一个<code>iterator()</code>方法。在对元素的遍历上，都可以采用迭代器的方式进行遍历。所以<code>Collection</code><strong>及其所有子类实现</strong>，我们都可以获取到每个元素的迭代器并用在对元素的遍历操作上。需要注意的是，<code>iterator</code><strong>仅用来遍历集合，本身并不存放任何对象。</strong></p>
</blockquote>
<p><strong>迭代器的执行原理</strong></p>
<blockquote>
<p>作为<code>Collection</code>的父接口，<code>Iterator</code>的方法如下：</p>
<p><img src="https://images.waer.ltd/img/20220320141211.png" alt="" loading="lazy" decoding="async" /></p>
</blockquote>
<blockquote>
<p>我们一般在使用迭代器进行遍历的时候，都会用到一个<code>while</code>循环，循环的条件是<code>iterator.hasNext()</code>，也就是说，在每次得到遍历元素之前，<code>iterator</code>对象会调用自身的<code>hasNext()</code>方法，对集合里的元素进行判断，<strong>只有当存在下一个元素时，迭代器才会继续往下执行</strong>，否则，迭代结束。</p>
<p><img src="https://images.waer.ltd/img/20220320140135.png" alt="" loading="lazy" decoding="async" /></p>
<p>可以看到，<code>Iterator</code>的<code>hasNext()</code>方法返回一个<strong>布尔值</strong>，如果该迭代对象还存在元素的情况下。这个方法就相当于一个指向集合元素的指针，每一次调用都会向下移动以检查<strong>是否到达集合尾部</strong>，在移动的同时，它还会调用<code>next()</code>方法，该方法会将移动后该指针指向位置上的元素进行返回。为了有效的防止空指针，每次在调用<code>Next()</code>之前，会先调用<code>hasNext()</code>,这是有必要的。如果说不存在下一个元素，则会抛出一个<code>NoSuchElementException</code>异常。</p>
</blockquote>
<p><strong>Iterator使用示例</strong></p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">package </span><span>collection;
</span><span>
</span><span style="color:#b48ead;">import </span><span>java.util.</span><span style="color:#ebcb8b;">ArrayList</span><span>;
</span><span style="color:#b48ead;">import </span><span>java.util.</span><span style="color:#ebcb8b;">Collection</span><span>;
</span><span style="color:#b48ead;">import </span><span>java.util.</span><span style="color:#ebcb8b;">Iterator</span><span>;
</span><span>
</span><span style="color:#65737e;">/**
</span><span style="color:#65737e;"> * </span><span style="color:#b48ead;">@author</span><span style="color:#65737e;">: 八尺妖剑
</span><span style="color:#65737e;"> * @date: 2022/3/20 14:17
</span><span style="color:#65737e;"> * @description: 演示迭代器[Iterator]的使用
</span><span style="color:#65737e;"> * @blog:www.waer.ltd
</span><span style="color:#65737e;"> */
</span><span>@</span><span style="color:#bf616a;">SuppressWarnings</span><span>({&quot;</span><span style="color:#a3be8c;">all</span><span>&quot;})
</span><span style="color:#b48ead;">public class </span><span style="color:#ebcb8b;">CollectionIterator </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">public static void </span><span style="color:#8fa1b3;">main</span><span style="color:#eff1f5;">(</span><span style="color:#ebcb8b;">String</span><span style="color:#b48ead;">[] </span><span style="color:#bf616a;">args</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">Collection</span><span style="color:#eff1f5;"> col </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ArrayList</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        col.</span><span style="color:#bf616a;">add</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">Book</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">C++ Primer Plus</span><span>&quot;</span><span style="color:#eff1f5;">,</span><span>&quot;</span><span style="color:#a3be8c;">Stephen Prata</span><span>&quot;</span><span style="color:#eff1f5;">,</span><span style="color:#d08770;">57.4</span><span style="color:#eff1f5;">));
</span><span style="color:#eff1f5;">        col.</span><span style="color:#bf616a;">add</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">Book</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">程序员的数学</span><span>&quot;</span><span style="color:#eff1f5;">,</span><span>&quot;</span><span style="color:#a3be8c;">结城浩</span><span>&quot;</span><span style="color:#eff1f5;">,</span><span style="color:#d08770;">20.5</span><span style="color:#eff1f5;">));
</span><span style="color:#eff1f5;">        col.</span><span style="color:#bf616a;">add</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">Book</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">Java疯狂讲义</span><span>&quot;</span><span style="color:#eff1f5;">,</span><span>&quot;</span><span style="color:#a3be8c;">李刚</span><span>&quot;</span><span style="color:#eff1f5;">,</span><span style="color:#d08770;">80.7</span><span style="color:#eff1f5;">));
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">集合[col]:</span><span>&quot;+</span><span style="color:#eff1f5;">col);
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">/*遍历集合*/
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">//1.获取集合的迭代对象
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">Iterator</span><span style="color:#eff1f5;"> iterator </span><span>=</span><span style="color:#eff1f5;"> col.</span><span style="color:#bf616a;">iterator</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">//2.while循环遍历数据
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">while</span><span style="color:#eff1f5;">(iterator.</span><span style="color:#bf616a;">hasNext</span><span style="color:#eff1f5;">()){
</span><span style="color:#eff1f5;">            </span><span style="color:#65737e;">//3.注意：iterator返回默认时一个Object类型(除非指定泛型)
</span><span style="color:#eff1f5;">            </span><span style="color:#ebcb8b;">Object</span><span style="color:#eff1f5;"> o </span><span>=</span><span style="color:#eff1f5;"> iterator.</span><span style="color:#bf616a;">next</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">            </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">[col]迭代返回:</span><span>&quot;+</span><span style="color:#eff1f5;">o);
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">//4.当退出while循环之后，此时的iterator指向最后一个元素，在调用next()方法会报NoSuchElementException异常。
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">//如果需要再次遍历，需要重置迭代器。方法如下：
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">//IDEA支持快速生成迭代方法，使用[Ctrl+j]快捷键进行查看
</span><span style="color:#eff1f5;">        iterator </span><span>=</span><span style="color:#eff1f5;"> col.</span><span style="color:#bf616a;">iterator</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">while </span><span style="color:#eff1f5;">(iterator.</span><span style="color:#bf616a;">hasNext</span><span style="color:#eff1f5;">()) {
</span><span style="color:#eff1f5;">            </span><span style="color:#ebcb8b;">Object</span><span style="color:#eff1f5;"> o1 </span><span>=</span><span style="color:#eff1f5;">  iterator.</span><span style="color:#bf616a;">next</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">            </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">[col]再次迭代：</span><span>&quot;+</span><span style="color:#eff1f5;">o1);
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span><span>
</span><span style="color:#65737e;">/**
</span><span style="color:#65737e;"> * 内部类
</span><span style="color:#65737e;"> */
</span><span style="color:#65737e;">class  Book{
</span><span style="color:#65737e;">    private String name;
</span><span style="color:#65737e;">    private String author;
</span><span style="color:#65737e;">    private double price;
</span><span style="color:#65737e;">
</span><span style="color:#65737e;">    public Book(String name, String author, double price) {
</span><span style="color:#65737e;">        this.name = name;
</span><span style="color:#65737e;">        this.author = author;
</span><span style="color:#65737e;">        this.price = price;
</span><span style="color:#65737e;">    }
</span><span style="color:#65737e;">
</span><span style="color:#65737e;">    @Override
</span><span style="color:#65737e;">    public String toString() {
</span><span style="color:#65737e;">        return &quot;Book{&quot; +
</span><span style="color:#65737e;">                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
</span><span style="color:#65737e;">                &quot;, author=&#39;&quot; + author + &#39;\&#39;&#39; +
</span><span style="color:#65737e;">                &quot;, price=&quot; + price +
</span><span style="color:#65737e;">                &#39;}&#39;;
</span><span style="color:#65737e;">    }
</span><span style="color:#65737e;">
</span><span style="color:#65737e;">    public String getName() {
</span><span style="color:#65737e;">        return name;
</span><span style="color:#65737e;">    }
</span><span style="color:#65737e;">
</span><span style="color:#65737e;">    public void setName(String name) {
</span><span style="color:#65737e;">        this.name = name;
</span><span style="color:#65737e;">    }
</span><span style="color:#65737e;">
</span><span style="color:#65737e;">    public String getAuthor() {
</span><span style="color:#65737e;">        return author;
</span><span style="color:#65737e;">    }
</span><span style="color:#65737e;">
</span><span style="color:#65737e;">    public void setAuthor(String author) {
</span><span style="color:#65737e;">        this.author = author;
</span><span style="color:#65737e;">    }
</span><span style="color:#65737e;">
</span><span style="color:#65737e;">    public double getPrice() {
</span><span style="color:#65737e;">        return price;
</span><span style="color:#65737e;">    }
</span><span style="color:#65737e;">
</span><span style="color:#65737e;">    public void setPrice(double price) {
</span><span style="color:#65737e;">        this.price = price;
</span><span style="color:#65737e;">    }
</span><span style="color:#65737e;">}
</span></code></pre>
<blockquote>
<p>一些需要注意的点，已经写在了注释当中。</p>
</blockquote>
<p><strong>增强for</strong></p>
<blockquote>
<p>所谓增强for，也就是针对普通for循环的增强。它可以替代<code>iterator</code>迭代器，相当于一个简化版的<code>iterator</code>,也正因为如此，<strong>增强for只能用于遍历集合或者数组</strong>。</p>
</blockquote>
<p>基本语法：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">for</span><span>(元素类型 元素名:集合或者数组名){
</span><span>    访问元素;
</span><span>}
</span></code></pre>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">package </span><span>collection;
</span><span>
</span><span style="color:#b48ead;">import </span><span>java.util.</span><span style="color:#ebcb8b;">ArrayList</span><span>;
</span><span style="color:#b48ead;">import </span><span>java.util.</span><span style="color:#ebcb8b;">Collection</span><span>;
</span><span>
</span><span style="color:#65737e;">/**
</span><span style="color:#65737e;"> * </span><span style="color:#b48ead;">@author</span><span style="color:#65737e;">: 八尺妖剑
</span><span style="color:#65737e;"> * @date: 2022/3/20 14:56
</span><span style="color:#65737e;"> * @description: 演示增强for的使用
</span><span style="color:#65737e;"> * @blog:www.waer.ltd
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">public class </span><span style="color:#ebcb8b;">CollectionFor </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    @</span><span style="color:#bf616a;">SuppressWarnings</span><span style="color:#eff1f5;">({</span><span>&quot;</span><span style="color:#a3be8c;">all</span><span>&quot;</span><span style="color:#eff1f5;">})
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">public static void  </span><span style="color:#8fa1b3;">main</span><span style="color:#eff1f5;">(</span><span style="color:#ebcb8b;">String</span><span style="color:#b48ead;">[] </span><span style="color:#bf616a;">args</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">Collection</span><span style="color:#eff1f5;"> col </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ArrayList</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        col.</span><span style="color:#bf616a;">add</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">Book</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">C++ Primer Plus</span><span>&quot;</span><span style="color:#eff1f5;">,</span><span>&quot;</span><span style="color:#a3be8c;">Stephen Prata</span><span>&quot;</span><span style="color:#eff1f5;">,</span><span style="color:#d08770;">57.4</span><span style="color:#eff1f5;">));
</span><span style="color:#eff1f5;">        col.</span><span style="color:#bf616a;">add</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">Book</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">程序员的数学</span><span>&quot;</span><span style="color:#eff1f5;">,</span><span>&quot;</span><span style="color:#a3be8c;">结城浩</span><span>&quot;</span><span style="color:#eff1f5;">,</span><span style="color:#d08770;">20.5</span><span style="color:#eff1f5;">));
</span><span style="color:#eff1f5;">        col.</span><span style="color:#bf616a;">add</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">Book</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">Java疯狂讲义</span><span>&quot;</span><span style="color:#eff1f5;">,</span><span>&quot;</span><span style="color:#a3be8c;">李刚</span><span>&quot;</span><span style="color:#eff1f5;">,</span><span style="color:#d08770;">80.7</span><span style="color:#eff1f5;">));
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">/*使用增强for进行集合的遍历*/
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">for</span><span style="color:#eff1f5;">(</span><span style="color:#ebcb8b;">Object</span><span style="color:#eff1f5;"> book</span><span>:</span><span style="color:#eff1f5;">col){
</span><span style="color:#eff1f5;">            </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">book=</span><span>&quot;+</span><span style="color:#eff1f5;">book);
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span></code></pre>
<h4 id="list"><code>List</code>接口</h4>
<p><strong>常用实现及其方法一览</strong></p>
<p><img src="https://images.waer.ltd/img/Lists.png" alt="" loading="lazy" decoding="async" /></p>
<blockquote>
<p><code>List</code>接口是<code>Collection</code>的子接口，上面讲解的<code>ArrayList</code>的方法是来自<code>Collection</code>接口方法。而这些方在<code>Set</code>子接口中也可以使用。下面讲一下子接口<code>List</code>中的实现类，也是以<code>ArrayList</code>实现为例。</p>
</blockquote>
<blockquote>
<ul>
<li><code>List</code>集合类中的元素是有序(添加和取出顺序一致)的，且是可重复的。</li>
<li><code>List</code>集合中的每一个元素都有其对应的顺序索引，即他是支持<strong>索引</strong>的一类集合。</li>
<li><code>List</code>中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</li>
<li><code>List</code>子接口的主要常用实现类有<code>ArrayList</code>、<code>LinkedList</code>、<code>Vector</code>。</li>
</ul>
</blockquote>
<p><strong>List的一些方法</strong></p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">package </span><span>List;
</span><span>
</span><span style="color:#b48ead;">import </span><span>java.util.</span><span style="color:#ebcb8b;">ArrayList</span><span>;
</span><span style="color:#b48ead;">import </span><span>java.util.</span><span style="color:#ebcb8b;">List</span><span>;
</span><span>
</span><span style="color:#65737e;">/**
</span><span style="color:#65737e;"> * </span><span style="color:#b48ead;">@author</span><span style="color:#65737e;">: 八尺妖剑
</span><span style="color:#65737e;"> * @date: 2022/3/20 16:57
</span><span style="color:#65737e;"> * @description: List的方法演示
</span><span style="color:#65737e;"> * @blog:www.waer.ltd
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">public class </span><span style="color:#ebcb8b;">ListMethod </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    @</span><span style="color:#bf616a;">SuppressWarnings</span><span style="color:#eff1f5;">({</span><span>&quot;</span><span style="color:#a3be8c;">all</span><span>&quot;</span><span style="color:#eff1f5;">})
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">public static void </span><span style="color:#8fa1b3;">main</span><span style="color:#eff1f5;">(</span><span style="color:#ebcb8b;">String</span><span style="color:#b48ead;">[] </span><span style="color:#bf616a;">args</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">List</span><span style="color:#eff1f5;"> list </span><span>=</span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ArrayList</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        list.</span><span style="color:#bf616a;">add</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">张无忌</span><span>&quot;</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">        list.</span><span style="color:#bf616a;">add</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">张天志</span><span>&quot;</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">/*在index位置插入元素e*/
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">/*注意：这里如果不指定下标的话，默认是以尾部追加的方式进行元素插入的*/
</span><span style="color:#eff1f5;">        list.</span><span style="color:#bf616a;">add</span><span style="color:#eff1f5;">(</span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">,</span><span>&quot;</span><span style="color:#a3be8c;">Tisox</span><span>&quot;</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">//list=[张无忌, Tisox, 张天志]
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">list=</span><span>&quot;+</span><span style="color:#eff1f5;">list);
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">/*addAll(inr index,Collection e)：从index位置开始将元素e中的所有元素添加进来*/
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">List</span><span style="color:#eff1f5;"> list2 </span><span>=</span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ArrayList</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        list2.</span><span style="color:#bf616a;">add</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">蜘蛛侠</span><span>&quot;</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">        list2.</span><span style="color:#bf616a;">add</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">钢铁侠</span><span>&quot;</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">        list.</span><span style="color:#bf616a;">addAll</span><span style="color:#eff1f5;">(</span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">,list2);
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">//list=[张无忌, 蜘蛛侠, 钢铁侠, Tisox, 张天志]
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">list=</span><span>&quot;+</span><span style="color:#eff1f5;">list);
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">/*int intdexOf(Object obj):返回obj在当前集合中首次出现的位置*/
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(list.</span><span style="color:#bf616a;">indexOf</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">蜘蛛侠</span><span>&quot;</span><span style="color:#eff1f5;">));
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">/*int lastIndexOf(Object obj):返回obj在当前集合中最后一次出现的位置*/
</span><span style="color:#eff1f5;">        list.</span><span style="color:#bf616a;">add</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">凋残</span><span>&quot;</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(list.</span><span style="color:#bf616a;">lastIndexOf</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">凋残</span><span>&quot;</span><span style="color:#eff1f5;">));
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">/*remove(int index):移除指定index位置的元素，并返回此元素*/
</span><span style="color:#eff1f5;">        list.</span><span style="color:#bf616a;">remove</span><span style="color:#eff1f5;">(</span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">list=</span><span>&quot;+</span><span style="color:#eff1f5;">list);
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">/*set(int index,Object ele):设置指定index位置出的元素为ele，相当于是替换元素*/
</span><span style="color:#eff1f5;">        list.</span><span style="color:#bf616a;">set</span><span style="color:#eff1f5;">(</span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">,</span><span>&quot;</span><span style="color:#a3be8c;">新的名字</span><span>&quot;</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">list=</span><span>&quot;+</span><span style="color:#eff1f5;">list);
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">/*subList(int fromIndex,int toIndex):返回从fromIndex到toIndex位置的子集合*/
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">//返回一个左闭右开的区间
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">List</span><span style="color:#eff1f5;"> reslist </span><span>=</span><span style="color:#eff1f5;"> list.</span><span style="color:#bf616a;">subList</span><span style="color:#eff1f5;">(</span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">, </span><span style="color:#d08770;">2</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">relist=</span><span>&quot;+</span><span style="color:#eff1f5;">reslist);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span></code></pre>
<p><strong>List的三种遍历方式</strong></p>
<blockquote>
<p>由于<code>ArrayList</code>、<code>LinkedList</code>和<code>Vector</code>都是<code>List</code>的实现子类，以下方法可以<strong>无缝切换</strong>，效果是一样的。</p>
</blockquote>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">package </span><span>List;
</span><span>
</span><span style="color:#b48ead;">import </span><span>java.util.*;
</span><span>
</span><span style="color:#65737e;">/**
</span><span style="color:#65737e;"> * </span><span style="color:#b48ead;">@author</span><span style="color:#65737e;">: Tisox
</span><span style="color:#65737e;"> * @date: 2022/3/20 19:18
</span><span style="color:#65737e;"> * @description: List的三种遍历方式
</span><span style="color:#65737e;"> * @blog:www.waer.ltd
</span><span style="color:#65737e;"> */
</span><span style="color:#b48ead;">public class </span><span style="color:#ebcb8b;">ListFor </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    @</span><span style="color:#bf616a;">SuppressWarnings</span><span style="color:#eff1f5;">({</span><span>&quot;</span><span style="color:#a3be8c;">all</span><span>&quot;</span><span style="color:#eff1f5;">})
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">public static void </span><span style="color:#8fa1b3;">main</span><span style="color:#eff1f5;">(</span><span style="color:#ebcb8b;">String</span><span style="color:#b48ead;">[] </span><span style="color:#bf616a;">args</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">//List list =new Vector();
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">List</span><span style="color:#eff1f5;"> list </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">LinkedList</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">//List list = new ArrayList();
</span><span style="color:#eff1f5;">        list.</span><span style="color:#bf616a;">add</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">jack</span><span>&quot;</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">        list.</span><span style="color:#bf616a;">add</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">tom</span><span>&quot;</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">        list.</span><span style="color:#bf616a;">add</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">回锅肉</span><span>&quot;</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">        list.</span><span style="color:#bf616a;">add</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">鱼香肉丝</span><span>&quot;</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">        list.</span><span style="color:#bf616a;">add</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">砂锅粉</span><span>&quot;</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">/*1.迭代器遍历*/
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">Iterator</span><span style="color:#eff1f5;"> iterator </span><span>=</span><span style="color:#eff1f5;"> list.</span><span style="color:#bf616a;">iterator</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">while </span><span style="color:#eff1f5;">(iterator.</span><span style="color:#bf616a;">hasNext</span><span style="color:#eff1f5;">()) {
</span><span style="color:#eff1f5;">            </span><span style="color:#ebcb8b;">Object</span><span style="color:#eff1f5;"> next </span><span>=</span><span style="color:#eff1f5;"> iterator.</span><span style="color:#bf616a;">next</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">            </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">[list]的[迭代器iterator]遍历=</span><span>&quot;+</span><span style="color:#eff1f5;">list);
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">====================================</span><span>&quot;</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">/*2.增强for遍历*/
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">for </span><span style="color:#eff1f5;">(</span><span style="color:#ebcb8b;">Object</span><span style="color:#eff1f5;"> o </span><span>:</span><span style="color:#eff1f5;"> list) {
</span><span style="color:#eff1f5;">            </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">[list]的[增强for]遍历=</span><span>&quot;+</span><span style="color:#eff1f5;">list);
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">====================================</span><span>&quot;</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">/*3.普通for循环遍历*/
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">for</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> i</span><span>=</span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">;i</span><span>&lt;</span><span style="color:#eff1f5;">list.</span><span style="color:#bf616a;">size</span><span style="color:#eff1f5;">();i</span><span>++</span><span style="color:#eff1f5;">){
</span><span style="color:#eff1f5;">            </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">[list]的[普通for循环]遍历=</span><span>&quot;+</span><span style="color:#eff1f5;">list.</span><span style="color:#bf616a;">get</span><span style="color:#eff1f5;">(i));
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span></code></pre>
<h4 id="arraylist"><code>ArrayList</code></h4>
<ul>
<li><code>ArrayList</code><strong>允许存入<code>null</code>值。</strong></li>
</ul>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#ebcb8b;">ArrayList</span><span> arrayList = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ArrayList</span><span>();
</span><span>arrayList.</span><span style="color:#bf616a;">add</span><span>(</span><span style="color:#d08770;">null</span><span>);
</span><span>arrayList.</span><span style="color:#bf616a;">add</span><span>(&quot;&quot;);
</span><span>arrayList.</span><span style="color:#bf616a;">add</span><span>(&quot;</span><span style="color:#a3be8c;">Java</span><span>&quot;);
</span><span style="color:#ebcb8b;">System</span><span>.out.</span><span style="color:#bf616a;">println</span><span>(arrayList);
</span></code></pre>
<ul>
<li>
<p>底层采用数组实现。</p>
</li>
<li>
<p><code>ArrayList</code>线程不安全</p>
</li>
</ul>
<p><img src="https://images.waer.ltd/img/20220320204436.png" alt="" loading="lazy" decoding="async" /></p>
<blockquote>
<p>通过它的源码可以看到，他是没有<code>synchronized</code>关键字修饰的。也正是因为如此，它的效率是比较高的，所以如果需要保证线程安全的场景下，不建议使用<code>ArrayList</code>。</p>
</blockquote>
<h5 id="-2">源码分析</h5>
<p>**<code>ArrayList</code>中维护了一个<code>Object</code>类型的数组<code>elementData[]</code>。**源码如下:</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">transient </span><span style="color:#ebcb8b;">Object</span><span style="color:#b48ead;">[]</span><span> elementData;
</span></code></pre>
<p>这里的<code>elementData[]</code>数组的类型是<code>Object</code>类型，也就是说，它可以存放任意类型的数据，因为<code>Object</code>类是<strong>所有类的父类</strong>，也就是顶级父类。 关键字<code>transient</code>的作用是去除序列化，当某个属性被加上该关键字即表示它在进行序列化时会被忽略，不参与序列化操作。</p>
<h5 id="-3">底层扩容原理</h5>
<blockquote>
<p><code>ArrayList</code>底层采用数组这种数据结构来实现，必然会有容量的限制，那么在它的底层是如何实现自动扩容的呢？这里以其中的<code>add()</code>方法进行浅析。</p>
</blockquote>
<p><code>ArrayList</code>有两个构造方法，分别是<strong>无参数构造和有参构造</strong>。下面是源码</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#65737e;">//无参构造
</span><span style="color:#b48ead;">public </span><span style="color:#bf616a;">ArrayList</span><span>() {
</span><span>    </span><span style="color:#bf616a;">this</span><span>.elementData = </span><span style="color:#d08770;">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span>;
</span><span>}
</span><span style="color:#65737e;">//有参构造
</span><span style="color:#b48ead;">public </span><span style="color:#bf616a;">ArrayList</span><span>(</span><span style="color:#b48ead;">int</span><span> initialCapacity) {
</span><span>    </span><span style="color:#b48ead;">if </span><span>(initialCapacity &gt; </span><span style="color:#d08770;">0</span><span>) {
</span><span>        </span><span style="color:#bf616a;">this</span><span>.elementData = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">Object</span><span>[initialCapacity];
</span><span>    } </span><span style="color:#b48ead;">else if </span><span>(initialCapacity == </span><span style="color:#d08770;">0</span><span>) {
</span><span>        </span><span style="color:#bf616a;">this</span><span>.elementData = </span><span style="color:#d08770;">EMPTY_ELEMENTDATA</span><span>;
</span><span>    } </span><span style="color:#b48ead;">else </span><span>{
</span><span>        </span><span style="color:#b48ead;">throw new </span><span style="color:#ebcb8b;">IllegalArgumentException</span><span>(&quot;</span><span style="color:#a3be8c;">Illegal Capacity: </span><span>&quot;+
</span><span>                                           initialCapacity);
</span><span>    }
</span><span>}
</span></code></pre>
<p>两个构造方法不仅在参数上有所区别，他们的底层扩容原理也是不一样的，先看一下无参数的<code> ArrayList()</code>构造。</p>
<p>可以看到，在<strong>无参构造的方法</strong>中，它将数组的初始容量设为<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>。也就是一个空对象数组。这一点可以从下面的源码得知。</p>
<p><img src="https://images.waer.ltd/img/20220321195749.png" alt="" loading="lazy" decoding="async" /></p>
<p>下面尝试在集合中添加元素，来分析add方法的执行过程。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#65737e;">//使用无参构造对集合进行初始化
</span><span style="color:#ebcb8b;">ArrayList</span><span> list = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ArrayList</span><span>();
</span><span style="color:#65737e;">//向其中添加10个元素
</span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">1</span><span>; i &lt;= </span><span style="color:#d08770;">10</span><span>; i++) {
</span><span>    list.</span><span style="color:#bf616a;">add</span><span>(i);
</span><span>}
</span></code></pre>
<p><strong>执行过程和扩容原理</strong></p>
<ul>
<li>在初始化完成后，当我们触发add()时，它会先调用<code>valueOf()</code>方法对添加的元素进行一个<strong>装箱</strong>操作，这不是本次分析的重点，不再赘述。注意下面这个自动装箱的源码来自<strong>JDK11</strong></li>
</ul>
<p><img src="https://images.waer.ltd/img/20220321200829.png" alt="" loading="lazy" decoding="async" /></p>
<ul>
<li>
<p>装箱结束后，进入<code>add(E e)</code>这个方法，该方法是集合中的一个<strong>重载方法，接收一个泛型参数</strong>，源码如下:</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">public boolean </span><span style="color:#bf616a;">add</span><span>(</span><span style="color:#ebcb8b;">E</span><span> e) {
</span><span>    </span><span style="color:#bf616a;">ensureCapacityInternal</span><span>(size + </span><span style="color:#d08770;">1</span><span>);  </span><span style="color:#65737e;">// Increments modCount!!
</span><span>    elementData[size++] = e;
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">true</span><span>;
</span><span>}
</span></code></pre>
</li>
</ul>
<p>首先，在执行正式的添加操作之前，会先执行<code>ensureCapacityInternal()</code>方法，该方法主要是用来<strong>确认集合的容量情况</strong>，决定是否需要扩容。再调用添加方法进行元素的添加。显然，这里出现的<code>ensureCapacityInternal()</code>方法是重点，源码如下：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">private</span><span> void </span><span style="color:#bf616a;">ensureCapacityInternal</span><span>(</span><span style="color:#b48ead;">int</span><span> minCapacity) {
</span><span>    </span><span style="color:#b48ead;">if </span><span>(elementData == </span><span style="color:#d08770;">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span>) {
</span><span>        minCapacity = </span><span style="color:#ebcb8b;">Math</span><span>.</span><span style="color:#bf616a;">max</span><span>(</span><span style="color:#d08770;">DEFAULT_CAPACITY</span><span>, minCapacity);
</span><span>    }
</span><span>    </span><span style="color:#bf616a;">ensureExplicitCapacity</span><span>(minCapacity);
</span><span>}
</span></code></pre>
<p>方法传入一个名为<code>minCapacity</code>的<code>int</code>类型变量，表示数组最小容量。接着判断<code>elementData</code>是否是<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>默认值，由于我们选择的是无参构造，所以<code>if</code>语句中的条件是成立的。接下来<code>Math.max(DEFAULT_CAPACITY, minCapacity)</code>在<strong>默认容量</strong>和<strong>最小容量</strong>之间取一个最大值并赋给<code>minCapacity</code>，也就是更新<code>minCapacity</code>的值。关于默认容量<code>DEFAULT_CAPACITY</code>，下面是它的声明：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">private static final int </span><span style="color:#d08770;">DEFAULT_CAPACITY </span><span>= </span><span style="color:#d08770;">10</span><span>;
</span></code></pre>
<p>执行之后，<code>minCapacity</code>的值将更新为10;也就是说，这个方法目的是为了确认<code>minCapacity</code>的值，而在<code>if</code>之后，又出现了一个<code>ensureExplicitCapacity(minCapacity)</code>方法，在<code>if</code>判断条件不满足的情况下执行，参数就是上面更新后的<code>minCapacity</code>，可以猜测，这个方法应该也是对是否需要扩容进行一个判断的算法。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">private</span><span> void </span><span style="color:#bf616a;">ensureExplicitCapacity</span><span>(</span><span style="color:#b48ead;">int</span><span> minCapacity) {
</span><span>    modCount++;
</span><span>    </span><span style="color:#65737e;">// overflow-conscious code
</span><span>    </span><span style="color:#b48ead;">if </span><span>(minCapacity - elementData.length &gt; </span><span style="color:#d08770;">0</span><span>)
</span><span>        </span><span style="color:#bf616a;">grow</span><span>(minCapacity);
</span><span>}
</span></code></pre>
<p>注意,这里有一条为<code>modCount++;</code>的语句，他主要是记录当前集合被修改的次数，为了防止被多个线程操作，否则会抛异常。第4行中if的条件<code>minCapacity - elementData.length &gt; 0</code>表示最小容量与当前数组元素容量的一个<strong>差值大于0是否成立</strong>，将会直接调用下一个方法进行扩容，也就是<code>grow()</code>方法。</p>
<blockquote>
<p>比方说，此时的<code>minCapacity=10</code>，<code>elementData=0</code>,显然<code>10-0&gt;0</code>,也即是说，数组需要一个最小容量为10空间，而此时的容量为0，显然需要进行扩容操作。</p>
</blockquote>
<p>下面是<code>grow()</code>方法，也是扩容的核心实现。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">private</span><span> void </span><span style="color:#bf616a;">grow</span><span>(</span><span style="color:#b48ead;">int</span><span> minCapacity) {
</span><span>    </span><span style="color:#65737e;">// overflow-conscious code
</span><span>    </span><span style="color:#b48ead;">int</span><span> oldCapacity = elementData.length;
</span><span>    </span><span style="color:#b48ead;">int</span><span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; </span><span style="color:#d08770;">1</span><span>);
</span><span>    </span><span style="color:#b48ead;">if </span><span>(newCapacity - minCapacity &lt; </span><span style="color:#d08770;">0</span><span>)
</span><span>        newCapacity = minCapacity;
</span><span>    </span><span style="color:#b48ead;">if </span><span>(newCapacity - </span><span style="color:#d08770;">MAX_ARRAY_SIZE </span><span>&gt; </span><span style="color:#d08770;">0</span><span>)
</span><span>        newCapacity = </span><span style="color:#bf616a;">hugeCapacity</span><span>(minCapacity);
</span><span>    </span><span style="color:#65737e;">// minCapacity is usually close to size, so this is a win:
</span><span>    elementData = </span><span style="color:#ebcb8b;">Arrays</span><span>.</span><span style="color:#bf616a;">copyOf</span><span>(elementData, newCapacity);
</span><span>}
</span></code></pre>
<p>可以看到，方法开始会先将数组容量<code>elementData.length</code>赋值给一个中间变量<code>oldCapacity</code>。接着为变量<code>newCapacity</code>进行赋值，算法是将<code>oldCapacity</code>旧<strong>的容量+旧容量的二分之一</strong>赋值给该变量。注意这里<code>(oldCapacity &gt;&gt; 1)</code>表将<code>oldCapacity</code>右移一位，<strong>等同于除以2</strong>，用位运算可以提高执行效率。反过来，如果是左移的话，代表乘以<code>2</code>。</p>
<p>又由于前面已经知道<code>elemenatData</code>其实是等于<code>0</code>的，那么直接导致这条赋值语句结果为<code>0</code>，也就是<code>newCapacity==0</code>，所以它后面紧接着出现了两个判断。</p>
<blockquote>
<ol>
<li>如果新的容量小于最小容量，那么将最小容量赋给这个新容量，<strong>完成一次扩容，此时数组的容量由0变为10.</strong></li>
<li>如果<code>newCapacity &gt; MAX_ARRAY_SIZE </code>,那么<code>newCpapcity</code>的值由方法<code>hugeCapacity()</code>决定。这个后面再说，我们继续当前的分析，在执行完上面的判断语句之后，最后对<code>elemantData</code>进行重新赋值，核心方法<code>Arrays.copyOf(elementData, newCapacity)</code>,该方法的作用是将<code>newCapacity</code>的值复制给<code>elementData</code>。之后<code>elementData</code>里面将会存在<strong>10个null</strong>值.</li>
</ol>
</blockquote>
<p>就是说，当我们<strong>首次</strong>使用该集合的<strong>无参构造</strong>初始化集合时，其实并不会触发<strong>1.5倍的底层扩容机制</strong>。注意，这里使用<code>copyOf()</code>方法的作用也是为了<strong>保留扩容之前已经存在集合中的元素</strong>，换句话说，每次扩容并不会导致已存在的元素丢失，而是在这些元素之后添加<code>N</code>个值为<code>null</code>的元素空间。比如这样:</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#65737e;">//null值得位置就是扩容的容量
</span><span>{</span><span style="color:#d08770;">1</span><span>,</span><span style="color:#d08770;">2</span><span>,</span><span style="color:#d08770;">3</span><span>,</span><span style="color:#d08770;">4</span><span>,</span><span style="color:#d08770;">5</span><span>,</span><span style="color:#d08770;">6</span><span>,</span><span style="color:#d08770;">7</span><span>,</span><span style="color:#d08770;">8</span><span>,</span><span style="color:#d08770;">9</span><span>,</span><span style="color:#d08770;">10</span><span>,</span><span style="color:#d08770;">null</span><span>,</span><span style="color:#d08770;">null</span><span>,</span><span style="color:#d08770;">null</span><span>,</span><span style="color:#d08770;">null</span><span>,</span><span style="color:#d08770;">null</span><span>}
</span></code></pre>
<p>当以上扩容操作完成之后，执行会返回到之前的<code>add()</code>方法：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">public boolean </span><span style="color:#bf616a;">add</span><span>(</span><span style="color:#ebcb8b;">E</span><span> e) {
</span><span>    </span><span style="color:#bf616a;">ensureCapacityInternal</span><span>(size + </span><span style="color:#d08770;">1</span><span>);  </span><span style="color:#65737e;">// Increments modCount!!
</span><span>    elementData[size++] = e;
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">true</span><span>;
</span><span>}
</span></code></pre>
<p>此时的<code>elementData</code>已经由最初的空数组扩容为大小为10的容量，当执行完<code>elementData[size++] = e;</code>之后，新的容量中第一个位置会被替换为元素<code>1</code>:</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span>[</span><span style="color:#d08770;">1</span><span>,</span><span style="color:#d08770;">null</span><span>,</span><span style="color:#d08770;">null</span><span>,</span><span style="color:#d08770;">null</span><span>,</span><span style="color:#d08770;">null</span><span>,</span><span style="color:#d08770;">null</span><span>,</span><span style="color:#d08770;">null</span><span>,</span><span style="color:#d08770;">null</span><span>,</span><span style="color:#d08770;">null</span><span>,</span><span style="color:#d08770;">null</span><span>]
</span></code></pre>
<blockquote>
<p>注意理解<strong>minCapacity</strong>和<strong>elementData</strong>的含义。前者的意思时我们用这个集合存放某些元素<strong>最少需要的空间</strong>，而后者表示此时这个集合<strong>本身拥有的空间</strong>，所以，扩容的目的在于扩张<strong>elementData</strong>的大小，以满足存放<strong>minCapacity</strong>所需。</p>
</blockquote>
<p>现在来看一下上面留下的**hugeCapacity(minCapacity)**方法，源码如下：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">private static int </span><span style="color:#bf616a;">hugeCapacity</span><span>(</span><span style="color:#b48ead;">int</span><span> minCapacity) {
</span><span> </span><span style="color:#b48ead;">if </span><span>(minCapacity &lt; </span><span style="color:#d08770;">0</span><span>) </span><span style="color:#65737e;">// overflow
</span><span>     </span><span style="color:#b48ead;">throw new </span><span style="color:#ebcb8b;">OutOfMemoryError</span><span>();
</span><span> </span><span style="color:#b48ead;">return </span><span>(minCapacity &gt; </span><span style="color:#d08770;">MAX_ARRAY_SIZE</span><span>) ? </span><span style="color:#ebcb8b;">Integer</span><span>.</span><span style="color:#d08770;">MAX_VALUE </span><span>: </span><span style="color:#d08770;">MAX_ARRAY_SIZE</span><span>;
</span><span>}
</span><span style="color:#65737e;">//注意：以下是MAX_ARRAY_SIZE的常量定义。
</span><span style="color:#b48ead;">private static final int </span><span style="color:#d08770;">MAX_ARRAY_SIZE </span><span>= </span><span style="color:#ebcb8b;">Integer</span><span>.</span><span style="color:#d08770;">MAX_VALUE </span><span>- </span><span style="color:#d08770;">8</span><span>;
</span><span style="color:#65737e;">//2147483647是Integer.MAX_VALUE
</span></code></pre>
<p>这个方法其实就是对数组<strong>大小边界进行一个判断和限制</strong>，要求数组大小在<code>0</code>到<code>MAX_VALUE</code>之间。如果<code>&lt;0</code>直接抛出一个<code>OutOfMemoryError</code>异常，否则返回一个值作为数组容量的上限，这里用了一个三元表达式作为返回语句。</p>
<p>如果<code>最小容量大于MAX_ARRAY_SIZE，</code>则将<code>Integer.MAX_VALUE</code>的值赋给它，否则还是用<code>MAX_ARRAY_SIZE。</code></p>
<p>再看一下<strong>为什么这里****MAX_ARRAY_SIZE</strong>是<strong>Integer.MAX_VALUE-8</strong>，也即是**2147483647-8=2,147,483,639****而不是减其他数值？**关于这个问题，其实再源码的注释中就已经写清楚了。</p>
<p><img src="https://images.waer.ltd/img/20220322112254.png" alt="" loading="lazy" decoding="async" /></p>
<p>大致意思就是如果直接使用<strong>Integer.MAX_VALUE</strong>的话，在某些虚拟机中，可能会出现溢出的问题。不过一般情况下，我们还是认为它的值可以直接看作是与<strong>Integer.MAX_VALUE</strong>相同。以下是来自<code>stackoverflow</code>的一个解答，可以参考一下。</p>
<p><a class="" href="https://stackoverflow.com/questions/35756277/why-the-maximum-array-size-of-arraylist-is-integer-max-value-8">Why the maximum array size of ArrayList is Integer.MAX_VALUE - 8?</a></p>
<p><strong>有参构造的扩容原理</strong></p>
<p>上面分析了调用<strong>无参构造器</strong>创建集合后，它底层的扩容原理，其实只要理解了之后。那么关于<strong>有参构造</strong>的扩容，就很容易理解了。</p>
<p>下面是它的有参构造器源码，前面也提到过。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#65737e;">/**
</span><span style="color:#65737e;">     * Constructs an empty list with the specified initial capacity.
</span><span style="color:#65737e;">     *
</span><span style="color:#65737e;">     * </span><span style="color:#b48ead;">@param  </span><span style="color:#bf616a;">initialCapacity</span><span style="color:#65737e;">  the initial capacity of the list
</span><span style="color:#65737e;">     * </span><span style="color:#b48ead;">@throws </span><span style="color:#65737e;">IllegalArgumentException if the specified initial capacity
</span><span style="color:#65737e;">     *         is negative
</span><span style="color:#65737e;">     */
</span><span style="color:#65737e;">public ArrayList(int initialCapacity) {
</span><span style="color:#65737e;">    if (initialCapacity &gt; 0) {
</span><span style="color:#65737e;">        this.elementData = new Object[initialCapacity];
</span><span style="color:#65737e;">    } else if (initialCapacity == 0) {
</span><span style="color:#65737e;">        this.elementData = EMPTY_ELEMENTDATA;
</span><span style="color:#65737e;">    } else {
</span><span style="color:#65737e;">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+initialCapacity);
</span><span style="color:#65737e;">    }
</span><span style="color:#65737e;">}
</span></code></pre>
<p>这段代码很容易理解，我们在调用该构造器进行初始化时传入一个初始大小<code>initialCapacity</code>作为数组的<strong>初始容量</strong>。如果该容量<strong>大于0，<strong>此时<code>elementData</code>数组会直接</strong>用该值作为数组的长度创建一个新的<code>Object</code>数组，以完成初始化</strong>。否则如果传入的初始值为<code>0</code>，会对<code>elementData</code>进行一个常量赋值操作，将数组初始化为<code>EMPTY_ELEMENTDATA</code>大小的数组，该常量定义如下：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">private static final </span><span style="color:#ebcb8b;">Object</span><span style="color:#b48ead;">[] </span><span style="color:#d08770;">EMPTY_ELEMENTDATA </span><span>= {};
</span></code></pre>
<p>也就是创建一个空数组。如果不在以上两种情况之外的，直接抛一个<strong>IllegalArgumentException</strong>异常结束。但是一般情况下，既然我们决定调用了该构造器，一般不会直接甩个<code>0</code>进去，这样做的意义不大。</p>
<p>在初始化完成后，进入添加方法，方法会先对现有的数组容量进行检查，如果发现所<strong>需最小容量大于当前初始化传入的容量</strong>，则会先进入<code>grow()</code>方法完成扩容，这里扩容不会进入第一个<code>if</code>判断，因为初始化传入的<code>elementData</code><strong>必然是大于0的</strong>，程序会直接执行源码中的<strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);<strong>这行逻辑，<strong>直接采取1.5倍扩容的机制</strong>对数组进行扩容后，将扩容后的整个数组空间直接复制一份，该操作会在原有元素的基础上追加扩容部分的空间，<strong>该部分的值默认使用null来填充</strong>，这些和前面分析</strong>无参构造扩容</strong>时候是一样的。此时再返回添加方法内部执行添加，添加成功之后之前扩容的<code>null</code>部分会被刚添加的元素取代，以此类推，直到下一次容量不够时，又再一次触发<code>1.5</code>b倍的扩容机制。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">private</span><span> void </span><span style="color:#bf616a;">grow</span><span>(</span><span style="color:#b48ead;">int</span><span> minCapacity) {
</span><span> </span><span style="color:#65737e;">// overflow-conscious code
</span><span> </span><span style="color:#b48ead;">int</span><span> oldCapacity = elementData.length;
</span><span> </span><span style="color:#b48ead;">int</span><span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; </span><span style="color:#d08770;">1</span><span>);
</span><span> </span><span style="color:#b48ead;">if </span><span>(newCapacity - minCapacity &lt; </span><span style="color:#d08770;">0</span><span>)
</span><span>     newCapacity = minCapacity;
</span><span> </span><span style="color:#b48ead;">if </span><span>(newCapacity - </span><span style="color:#d08770;">MAX_ARRAY_SIZE </span><span>&gt; </span><span style="color:#d08770;">0</span><span>)
</span><span>     newCapacity = </span><span style="color:#bf616a;">hugeCapacity</span><span>(minCapacity);
</span><span> </span><span style="color:#65737e;">// minCapacity is usually close to size, so this is a win:
</span><span> elementData = </span><span style="color:#ebcb8b;">Arrays</span><span>.</span><span style="color:#bf616a;">copyOf</span><span>(elementData, newCapacity);
</span><span>}
</span></code></pre>
<p><strong>实例演示</strong></p>
<p>通过一个具体的例子，来解释帮助理解上面所说的扩容原理(无参构造)。</p>
<ul>
<li><strong>无参构造器</strong></li>
</ul>
<blockquote>
<p>假设我们调用 了<code>ArrayList()</code>对集合<code>list</code>进行了初始化并尝试向其中添加元素，下面模拟这个大致过程：</p>
<ol>
<li>初始化完成，创建一个空的对象数组<code>elementData[] = {}</code>。</li>
<li>进入<code>add()</code>方法，根据当前添加元素所需空间对已有空间进行判断，显然我们添加第一个元素时，<code>minCapacity=1,</code>而<code>elementData=0。</code></li>
<li>此时不忙着执行添加，而是调用<code>ensureCapacityInternal()</code>方法：
<ol>
<li>该方法发现，初始化的<code>elementData=DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，则执行一个<code>Math.max()</code>方法，该方法直接将<code>minCapacity</code>的值改为<code>10</code>。此时我们的<code>minCapacity=10</code>,而<code>elementData</code>还是<code>0</code>；</li>
<li>进入**<code>ensureExplicitCapacity()</code>**方法，满足判断条件发现，<strong>所需最小容量&gt;当前容量</strong>，需要扩容，触发<code>grow()</code>方法。
<ol>
<li>检查并记录<code>elementData</code>的长度，发现此时该值为<code>0</code>，<strong>由于0的1.5倍还是0，此时扩容算法无意义不执行。</strong></li>
<li>进入第一个<code>if</code>判断，发现条件满足，直接将<code>minCapacity</code>的值赋给一个新的变量<code>newCapacity=10</code></li>
<li>执行数组的<code>copyOf()</code>方法，将会开辟一个容量为<code>10</code>的数组。</li>
<li>程序跳回<code>add()</code>方法，执行元素的添加。</li>
<li><code>add()</code>方法执行结束。</li>
</ol>
</li>
</ol>
</li>
</ol>
</blockquote>
<p><strong>也就是说，如果我们调用无参构造器初始化集合，首次扩容并不会按照<code>1.5</code>倍的机制来，而是直接给你开一个大小为<code>10</code>的数组，只有当这<code>10</code>个空间全部用完之后，之后的每一次扩容，就都会采用<code>1.5</code>倍的机制进行扩容，因此首次调用的方法栈是比较绕的，但是从第二次开始，或者使用有参构造器初始化的时候就会少一些判断，空间不够，直接开始<code>1.5</code>倍扩容机制走起。</strong></p>
<h5 id="-4">1.5倍扩容怎么算？</h5>
<blockquote>
<p>假设当前容量值为<code>8</code>，下一次扩容的值就是<code>12</code>，算法过程很简单：</p>
<p>12 = 8+8/2</p>
<p>= 8+4</p>
<p>=12</p>
<p>只不过，在源代码中，算法使用右移<code>&gt;&gt;</code>代替除法，要知道，<strong>位运算的速度是远快于四则运算的</strong>。由此，如果需要再次扩容的话，<code>12</code>的容量会扩容为<code>12+6 = 18</code>。</p>
</blockquote>
<hr />
<h4 id="vector"><code>Vector</code></h4>
<h5 id="-5">基本结构</h5>
<p><code>Vector</code>类的定义，它实现自<code>List</code>接口。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">public class </span><span style="color:#ebcb8b;">Vector</span><span style="color:#eff1f5;">&lt;</span><span style="color:#bf616a;">E</span><span style="color:#eff1f5;">&gt;
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">extends </span><span style="color:#a3be8c;">AbstractList</span><span style="color:#eff1f5;">&lt;</span><span style="color:#ebcb8b;">E</span><span style="color:#eff1f5;">&gt;
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">implements </span><span style="color:#a3be8c;">List</span><span style="color:#eff1f5;">&lt;</span><span style="color:#ebcb8b;">E</span><span style="color:#eff1f5;">&gt;, </span><span style="color:#a3be8c;">RandomAccess</span><span style="color:#eff1f5;">, </span><span style="color:#a3be8c;">Cloneable</span><span style="color:#eff1f5;">, </span><span style="color:#a3be8c;">java</span><span style="color:#eff1f5;">.</span><span style="color:#a3be8c;">io</span><span style="color:#eff1f5;">.</span><span style="color:#a3be8c;">Serializable
</span></code></pre>
<p>它的底层实现也是基于对象数组，它由<code>protected</code>修饰符修饰：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">protected </span><span style="color:#ebcb8b;">Object</span><span style="color:#b48ead;">[]</span><span> elementData;
</span></code></pre>
<p><code>Vector</code>是线程安全的，它的操作方法都有<code>synchronized</code>修饰，该关键字可以实现线程同步和互斥，所以他是线程安全的。比如其源码中的<code>indexOf()</code>方法，因此，一般在开发中，如果有线程安全的需要，可以考虑使用<code>Vector</code>。当然，这也并非是必须的，关于线程安全的集合或者说实现，还有专门的类去管理，<code>Vector</code>在<code>JDK1.0</code>版本中就有的，算是一个老前辈了，尽管它线程安全，但也不一定就是最佳的选择。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">public synchronized int </span><span style="color:#bf616a;">indexOf</span><span>(</span><span style="color:#ebcb8b;">Object</span><span> o, </span><span style="color:#b48ead;">int</span><span> index) {
</span><span>    </span><span style="color:#b48ead;">if </span><span>(o == </span><span style="color:#d08770;">null</span><span>) {
</span><span>        </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> i = index ; i &lt; elementCount ; i++)
</span><span>            </span><span style="color:#b48ead;">if </span><span>(elementData[i]==</span><span style="color:#d08770;">null</span><span>)
</span><span>                </span><span style="color:#b48ead;">return</span><span> i;
</span><span>    } </span><span style="color:#b48ead;">else </span><span>{
</span><span>        </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> i = index ; i &lt; elementCount ; i++)
</span><span>            </span><span style="color:#b48ead;">if </span><span>(o.</span><span style="color:#bf616a;">equals</span><span>(elementData[i]))
</span><span>                </span><span style="color:#b48ead;">return</span><span> i;
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">return </span><span>-</span><span style="color:#d08770;">1</span><span>;
</span><span>}
</span></code></pre>
<h5 id="-6">源码分析</h5>
<h6 id="-7"><strong>扩容机制</strong></h6>
<p><strong>默认10满后，按照2倍扩容。如果指定大小，则每次按2倍扩容。</strong></p>
<p><strong>创建一个无参的vector之后，它会默认直接给你一个大小为10的空间。直截了当。</strong></p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">public </span><span style="color:#bf616a;">Vector</span><span>() {
</span><span>    </span><span style="color:#bf616a;">this</span><span>(</span><span style="color:#d08770;">10</span><span>);
</span><span>}
</span></code></pre>
<p>接着执行添加操作，跳转到<code>add()</code>方法(这里就不再提自动装箱的操作了)，源码如下,咋一看是不是和前面分析的<code>ArrayList</code>的源码如出一辙？除了一个<code>modCount++</code>之外，还是会在添加元素之前先执行一个名为<code>ensureCapacityHelper</code>的方法，基于前面<code>ArrayList</code>源码的阅读理解，这里不用多想也能猜到，这个方法的作用，无非就是对目前的数组容量进行判断，看看是不是需要扩容。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">public synchronized boolean </span><span style="color:#bf616a;">add</span><span>(</span><span style="color:#ebcb8b;">E</span><span> e) {
</span><span>    modCount++;
</span><span>    </span><span style="color:#bf616a;">ensureCapacityHelper</span><span>(elementCount + </span><span style="color:#d08770;">1</span><span>);
</span><span>    elementData[elementCount++] = e;
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">true</span><span>;
</span><span>}
</span></code></pre>
<p>进入<code>ensureCapacityHelper</code>的源码看看,可以看到这实现和<code>ArrayList</code>中的实现几乎一样，还是判断最小所需空间和当前数组的容量关系，显然，这里<code>elementData=10,</code>而<code>minCapacity=1</code>，<strong>不满足扩容的条件</strong>，因此这里不会进入<code>grow()</code>方法。直接返回<code>add()</code>执行元素的添加，一次添加执行结束。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">private</span><span> void </span><span style="color:#bf616a;">ensureCapacityHelper</span><span>(</span><span style="color:#b48ead;">int</span><span> minCapacity) {
</span><span>    </span><span style="color:#65737e;">// overflow-conscious code
</span><span>    </span><span style="color:#b48ead;">if </span><span>(minCapacity - elementData.length &gt; </span><span style="color:#d08770;">0</span><span>)
</span><span>        </span><span style="color:#bf616a;">grow</span><span>(minCapacity);
</span><span>}
</span></code></pre>
<p>下面我们假设，要添加第<code>11</code>个元素，此时原来的10个空间已经不够，自然会触发扩容机制，下面是该扩容方法的实现源码：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#65737e;">// 扩容方法
</span><span style="color:#b48ead;">private</span><span> void </span><span style="color:#bf616a;">grow</span><span>(</span><span style="color:#b48ead;">int</span><span> minCapacity) {
</span><span>    </span><span style="color:#65737e;">// overflow-conscious code
</span><span>    </span><span style="color:#b48ead;">int</span><span> oldCapacity = elementData.length;
</span><span>    </span><span style="color:#b48ead;">int</span><span> newCapacity = oldCapacity + ((capacityIncrement &gt; </span><span style="color:#d08770;">0</span><span>) ? capacityIncrement : oldCapacity);
</span><span>    </span><span style="color:#b48ead;">if </span><span>(newCapacity - minCapacity &lt; </span><span style="color:#d08770;">0</span><span>)
</span><span>        newCapacity = minCapacity;
</span><span>    </span><span style="color:#b48ead;">if </span><span>(newCapacity - </span><span style="color:#d08770;">MAX_ARRAY_SIZE </span><span>&gt; </span><span style="color:#d08770;">0</span><span>)
</span><span>        newCapacity = </span><span style="color:#bf616a;">hugeCapacity</span><span>(minCapacity);
</span><span>    elementData = </span><span style="color:#ebcb8b;">Arrays</span><span>.</span><span style="color:#bf616a;">copyOf</span><span>(elementData, newCapacity);
</span><span>}
</span><span style="color:#65737e;">// 关于capacityIncrement的定义：
</span><span>   </span><span style="color:#65737e;">/**
</span><span style="color:#65737e;">     * The amount by which the capacity of the vector is automatically
</span><span style="color:#65737e;">     * incremented when its size becomes greater than its capacity.  If
</span><span style="color:#65737e;">     * the capacity increment is less than or equal to zero, the capacity
</span><span style="color:#65737e;">     * of the vector is doubled each time it needs to grow.
</span><span style="color:#65737e;">     *
</span><span style="color:#65737e;">     * </span><span style="color:#b48ead;">@serial
</span><span style="color:#65737e;">     */
</span><span style="color:#65737e;">    protected int capacityIncrement;
</span></code></pre>
<p>根据源码了解到，它会先将<code>elementData</code>的长度放到一个名为<code>oldCapacity</code>的变量中并创建一个新的容量<code>newCapacity</code>,该变量的值就是扩容的核心原理，其中<code> int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity)</code>这段三元表达式会先判断<code>capacityIncrement</code>的值是否<code>&gt;0</code>,如果成立，那么<code>capacityIncrement</code>的值保持不变，那么整个表达式就是<code>newCapacity = oldCapacity+capacityIncrement</code>。</p>
<p>否则将会是<code>newCapacity =oldCapacity+oldCapactity</code>,也就<code>newCapacity </code>会<strong>变为原来两倍的容量，<strong>最后依旧是采用<code>copyOf()</code>方法将扩容后的空间复制到原空间，完成扩容。关于其中两个<code>if</code>判断的逻辑和之前对<code>ArrayList</code>的分析是类似的，不再赘述。通过这个源码也发现了，这个<code>2</code>倍扩容的算法中，有一个名为<code>capacityIncrement</code>的</strong>容量增量</strong>，具体作用面会在下面有参构造器中进行分析。</p>
<p><strong>有参构造器源码分析</strong></p>
<p>该构造器的源码如下，构造器是有两个参数的，其中一个便是上面提到的容量增量参数<code>capacityIncrement</code>。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">public </span><span style="color:#bf616a;">Vector</span><span>(</span><span style="color:#b48ead;">int</span><span> initialCapacity, </span><span style="color:#b48ead;">int</span><span> capacityIncrement) {
</span><span>    </span><span style="color:#bf616a;">super</span><span>();
</span><span>    </span><span style="color:#b48ead;">if </span><span>(initialCapacity &lt; </span><span style="color:#d08770;">0</span><span>)
</span><span>        </span><span style="color:#b48ead;">throw new </span><span style="color:#ebcb8b;">IllegalArgumentException</span><span>(&quot;</span><span style="color:#a3be8c;">Illegal Capacity: </span><span>&quot;+
</span><span>                                           initialCapacity);
</span><span>    </span><span style="color:#bf616a;">this</span><span>.elementData = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">Object</span><span>[initialCapacity];
</span><span>    </span><span style="color:#bf616a;">this</span><span>.capacityIncrement = capacityIncrement;
</span><span>}
</span></code></pre>
<p>方法体首先会先调用父类的无参构造。如果我们不指定<code>capacityIncrement</code>的值，它默认是<code>0</code>，也就是<strong>无增量</strong>，一般在调用无参构造器时就是属于这种情况，**在没有明确容量增量时，扩容会按照原容量的2两倍进行，**如果指定具体的值，我们在<code>grow()</code>方法中看到，<code>  int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity);</code>这个表达式将产生一个新的容量值，<strong>该值的大小由原来的容量+指定的容量增量决定</strong>。那么可能会开始疑惑， 既然说了是<code>2</code>倍扩容，那么加一个容量增量算怎么回事？</p>
<p>如果指定了该增量的值，不就改变了2倍扩容的机制了吗？其实不完全是，在<code>vector</code>源码中，其实存在三个构造器，上面这个便是可以指定扩容增量的构造器，如果你不需要指定第二个参数，那么还可以看到，它还有一个普通的带一个参数的构造，源码如下：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">public </span><span style="color:#bf616a;">Vector</span><span>(</span><span style="color:#b48ead;">int</span><span> initialCapacity) {
</span><span>    </span><span style="color:#bf616a;">this</span><span>(initialCapacity, </span><span style="color:#d08770;">0</span><span>);
</span><span>}
</span></code></pre>
<p>该构造器尽管只需要一个参数，但它在创建之后会默认给<code>capacityIncrement</code>赋值为0，这也就是不管你是空参构造还是带参构造对<code>Vector</code>进行初始化，在扩容时都会用到<code>capacityIncrement</code>这样一个参数，这也是扩容算法中三元表达式的意义，<strong>你可以不写，但我必须得用</strong>，所以才会有默认的<code>0</code>,这是不冲突的。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#65737e;">/*无参构造*/
</span><span style="color:#ebcb8b;">Vector</span><span> vector = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">Vector</span><span>();
</span><span style="color:#65737e;">/*指定一个参数：默认为集合的初始大小*/
</span><span style="color:#ebcb8b;">Vector</span><span> vector2 = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">Vector</span><span>(</span><span style="color:#d08770;">6</span><span>);
</span><span style="color:#65737e;">/*指定两个参数：依次时集合大小和扩容时的容量增量*/
</span><span style="color:#ebcb8b;">Vector</span><span> vector3= </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">Vector</span><span>(</span><span style="color:#d08770;">6</span><span>,</span><span style="color:#d08770;">3</span><span>);
</span></code></pre>
<hr />
<h4 id="linkedlist"><code>LinkedList</code></h4>
<h5 id="-8">基本结构</h5>
<ul>
<li><code>LinkedList</code>底层实现采用了<strong>双向链表</strong>和<strong>双端队列</strong>。</li>
<li>可以添加任意元素且元素可以重复(因为实现自List接口)，同时包括<code>null</code>。</li>
<li>非线程安全的集合，没有实现同步。</li>
<li>在其中维护的两个属性<code>first</code>和<code>last</code>分别指向首尾节点，<code>prev</code>指向前驱节点，<code>next</code>指向后继节点。</li>
<li>因此<code>LinkedList</code>的元素<strong>删除和添加的操作效率相对较高</strong>。</li>
</ul>
<h5 id="-9">源码分析</h5>
<p>[待更新……]</p>
<h4 id="-10">如何选择</h4>
<blockquote>
<p>如何选择使用<code>ArrayList</code>和<code>LinkedList</code>?根据我们实际的使用场景或者需求</p>
</blockquote>
<ul>
<li>如果涉及改查操作比较多，建议<code>ArrayList</code>。</li>
<li>如果增删操作比较多，建议<code>LinkedList</code>。</li>
<li>一般来说，在程序中<code>80%~90%</code>都是查询操作，因此大部分情况下会选择使用<code>ArrayList</code>。</li>
<li>当然，选择哪一个并非一成不变，在实际的项目中，甚至可能出现<code>ArrayList</code>和<code>LinkedList</code>同时使用的情况，也是正常的，所以要求最好都会使用。</li>
</ul>
<hr />
<h4 id="set"><code>Set</code>接口</h4>
<p>下面主要讲解<code>Set</code>子接口下的主要实现类。</p>
<p><strong>常用方法和实现</strong></p>
<p><img src="https://images.waer.ltd/img/Set.png" alt="" loading="lazy" decoding="async" /></p>
<p><strong>Set的基本介绍</strong></p>
<ul>
<li>
<p>无序(元素的添加与取出的顺序不一致)，无索引。</p>
<blockquote>
<p>注意理解这里的无序的含义，并不是说，每一次取出的顺序都是随机的，而是指当执行了一次取出之后，今后的每一次相同的操作，它取出的元素顺序都与第一次相同，但<strong>这个顺序又和添加进去的顺序不保持一致</strong>。</p>
</blockquote>
</li>
<li>
<p>不允许重复元素。</p>
</li>
<li>
<p>还有一点，由于它是<code>Collection</code>的子接口，自然也支持其父接口中的特性，比如迭代对象，增强for等等。</p>
</li>
</ul>
<h4 id="hashset"><code>HashSet</code></h4>
<h5 id="-11">基本结构</h5>
<blockquote>
<p><code>HashSet</code>作为<code>Set</code>典型的实现类之一，拥有<code>Set</code>的全部属性，这里不再赘述。</p>
</blockquote>
<h5 id="-12">源码解读</h5>
<h6 id="-13">初始化与基本原理</h6>
<p>我们先看一下<code>HashSet</code>的基本用法，其实，<code>HashSet</code>在实现上，就是一个<code>HashMap</code>,这一点可以从它的构造器说起。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span> </span><span style="color:#ebcb8b;">Set</span><span> hashSet = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">HashSet</span><span>();
</span></code></pre>
<p>以下是<code>HashSet</code>的无参构造器源码，可以看到，当我们创建一个<code>HashSet</code>对象时，它在底层直接<code>new</code>了一个<code>HashMap</code>，这又不得不说一下<code>HashMap</code>的底层，它是由<strong>数组+链表+红黑树</strong>构成，所以相对来说是比较复杂的。</p>
<p><img src="https://images.waer.ltd/img/20220323200228.png" alt="" loading="lazy" decoding="async" /></p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">public </span><span style="color:#bf616a;">HashSet</span><span>() {
</span><span>    map = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">HashMap</span><span>&lt;&gt;();
</span><span>}
</span></code></pre>
<p>换句话说，要分析<code>HashSet</code>的源码，其实就是分析<code>HashMap</code>的原理。<code>HashSet</code>一个明显的特点就是不能添加重复的元素，但这里的<strong>重复</strong>也许不是你想象中的那么简单。</p>
<p>下面开始分析一下其中的添加元素的<code>add()</code>方法在底层是如何实现的。</p>
<blockquote>
<ul>
<li><strong>添加一个元素时，会先得到一个<code>hash</code>值，根据该值转成一个索引值。</strong></li>
<li><strong>找到存储数据表<code>table</code>，检查该索引是否已在<code>table</code>中存在有元素</strong>：
<ul>
<li><strong>如果没有，直接将该元素加入。</strong></li>
<li><strong>如果有，会调用<code>equals</code>方法进行比较操作，如果比较结果为<code>true</code>,添加失败，否则，将会在末尾添加元素。</strong></li>
<li><strong>在<code>Java8</code>中，如果一条链表的元素个数达到<code>TREEIFY_THRESHOLD</code>且<code>table</code>的大小<code>&gt;=</code>MIN_TREEIFY_CAPACITY,就会触发树化机制，即会由单链表结构转换为一棵红黑树。</strong></li>
</ul>
</li>
</ul>
</blockquote>
<p>为例更好的理解它的执行过程和原理，我们按照下面这几行代码来讲解:</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#ebcb8b;">HashSet</span><span> hashSet = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">HashSet</span><span>();
</span><span>hashSet.</span><span style="color:#bf616a;">add</span><span>(&quot;</span><span style="color:#a3be8c;">Java</span><span>&quot;);
</span><span>hashSet.</span><span style="color:#bf616a;">add</span><span>(&quot;</span><span style="color:#a3be8c;">C++</span><span>&quot;);
</span><span>hashSet.</span><span style="color:#bf616a;">add</span><span>(&quot;</span><span style="color:#a3be8c;">Java</span><span>&quot;);
</span><span style="color:#ebcb8b;">System</span><span>.out.</span><span style="color:#bf616a;">println</span><span>(&quot;</span><span style="color:#a3be8c;">hashSet=</span><span>&quot;+hashSet);
</span></code></pre>
<p>代码逻辑很简单，就是向<code>HashSet</code>中添加三个元素，其中有<strong>两个元素是重复</strong>的，这是为了理解它底层是如何判断元素重复的。</p>
<p>执行代码，首先会进入<code>HashSet</code>的构造器，直接创建一个值为空的<code>HashMap</code>，这点在上面已经说过。进入<code>add()</code>方法，它的实现源码如下：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#65737e;">//HashSet中add方法的源码实现
</span><span style="color:#b48ead;">public boolean </span><span style="color:#bf616a;">add</span><span>(</span><span style="color:#ebcb8b;">E</span><span> e) {
</span><span>    </span><span style="color:#b48ead;">return</span><span> map.</span><span style="color:#bf616a;">put</span><span>(e, </span><span style="color:#d08770;">PRESENT</span><span>)==</span><span style="color:#d08770;">null</span><span>;
</span><span>}
</span></code></pre>
<p>方法很简单，直接调用了<code>map</code>的<code>put()</code>方法,注意到，这个方法除了我们需要添加的元素<code>e</code>之外，它还有一个名为<code>PRESENT</code>的常量参数，关于这个参数的理解，源码中是这样介绍的：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#65737e;">// Dummy value to associate with an Object in the backing Map
</span><span style="color:#b48ead;">private static final </span><span style="color:#ebcb8b;">Object </span><span style="color:#d08770;">PRESENT </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">Object</span><span>();
</span></code></pre>
<p><code>PRESENT</code>其实是一个<code>static final</code>修饰的对象，在上面的方法中作为<code>put(k,v)</code>中<code>value</code>的占位，并没有其他实际的作用。这里不必深究。不知道有没有注意到，<code>add</code>方法中将<code>map.put(e,PRESENT)==null</code>作为返回值，为什么这里会是<code>null</code>呢？这和<code>HashMap</code>底层实现有关系，我们先继续往下，后面自然就会明白了。下面进入<code>put</code>方法内部看看。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#65737e;">//HashSet中map.put(e,PERSENT)方法源码
</span><span style="color:#b48ead;">public </span><span style="color:#ebcb8b;">V </span><span style="color:#bf616a;">put</span><span>(</span><span style="color:#ebcb8b;">K</span><span> key, </span><span style="color:#ebcb8b;">V</span><span> value) {
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">putVal</span><span>(</span><span style="color:#bf616a;">hash</span><span>(key), key, value, </span><span style="color:#d08770;">false</span><span>, </span><span style="color:#d08770;">true</span><span>);
</span><span>}
</span></code></pre>
<p>方法中有一个<code>putVal</code>的方法，可以看到其中的第一个参数<code>hash(key)</code>表示通过这个方法获取<code>key</code>的<code>hash</code>值。这里的<code>key</code>也就是我们传入的待添加的元素，进入该方法：果然，<code>hash</code>方法的作用就是计算<code>key</code>的<code>hash值</code>，算法都在这条三元表达式当中了，可以简单看一下。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#65737e;">//HashMap中的hash()方法实现
</span><span style="color:#b48ead;">static final int </span><span style="color:#bf616a;">hash</span><span>(</span><span style="color:#ebcb8b;">Object</span><span> key) {
</span><span>    </span><span style="color:#b48ead;">int</span><span> h;
</span><span>    </span><span style="color:#b48ead;">return </span><span>(key == </span><span style="color:#d08770;">null</span><span>) ? </span><span style="color:#d08770;">0 </span><span>: (h = key.</span><span style="color:#bf616a;">hashCode</span><span>()) ^ (h &gt;&gt;&gt; </span><span style="color:#d08770;">16</span><span>);
</span><span>}
</span></code></pre>
<p>核心算法<code>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，意思就是如果传入的<code>key</code>为<code>null</code>,那么直接返回0，也就是不执行任何实际操作。<strong>否则会使用<code>hashCode()</code>方法获取<code>key</code>的哈希码和无符号右移16位之后的值进行一个异或操作</strong>，将该异或的结果返回作为<code>key</code>最终的<code>hash</code>值。这样作主要是为了保证<strong>高16位和低16未的特征，减少碰撞，减低<code>hash</code>冲突的几率</strong>。</p>
<p>注意，<code>hash</code>和<code>hashCode</code>并不是一回事。</p>
<blockquote>
<p>这里的<code>hash</code>仅仅是用来在<code>HashMap</code>中计算<code>key</code>对应的散列码。它的算法中用到了<code>hashCode()</code>这个方法，<code>hashCode</code>是在<code>Objct</code>中定义的，用来获取每个元素对应的散列值，<strong>底层使用的C语言作为实现</strong>,属于<code>native</code>方法。换句话说，使用<code>hashCode()</code>方法可以计算<code>Java</code>中每一个元素的一个哈希值。而<code>hash()</code>方法在这里的作就相对局限，使用的算法也相对简单很多，具体的关于<code>hash和hashCode()</code>的内容，可以自己研究，这里不作展开。</p>
</blockquote>
<p>理解了<code>hash</code>的计算方式之后，继续往后看，在获取到<code>key</code>的<code>hash</code>，方法会返回进入到<code>putVal()</code>方法中，这是整个添加操作的底层实现的核心源码，也是一个难点。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">final </span><span style="color:#ebcb8b;">V </span><span style="color:#bf616a;">putVal</span><span>(</span><span style="color:#b48ead;">int</span><span> hash, </span><span style="color:#ebcb8b;">K</span><span> key, </span><span style="color:#ebcb8b;">V</span><span> value, </span><span style="color:#b48ead;">boolean</span><span> onlyIfAbsent,
</span><span>               </span><span style="color:#b48ead;">boolean</span><span> evict) {
</span><span>    </span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt;</span><span style="color:#b48ead;">[]</span><span> tab; </span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt; p; </span><span style="color:#b48ead;">int</span><span> n, i;
</span><span>    </span><span style="color:#b48ead;">if </span><span>((tab = table) == </span><span style="color:#d08770;">null </span><span>|| (n = tab.length) == </span><span style="color:#d08770;">0</span><span>)
</span><span>        n = (tab = </span><span style="color:#bf616a;">resize</span><span>()).length;
</span><span>    </span><span style="color:#b48ead;">if </span><span>((p = tab[i = (n - </span><span style="color:#d08770;">1</span><span>) &amp; hash]) == </span><span style="color:#d08770;">null</span><span>)
</span><span>        tab[i] = </span><span style="color:#bf616a;">newNode</span><span>(hash, key, value, </span><span style="color:#d08770;">null</span><span>);
</span><span>    </span><span style="color:#b48ead;">else </span><span>{
</span><span>        </span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt; e; </span><span style="color:#ebcb8b;">K</span><span> k;
</span><span>        </span><span style="color:#b48ead;">if </span><span>(p.hash == hash &amp;&amp;((k = p.key) == key || (key != </span><span style="color:#d08770;">null </span><span>&amp;&amp; key.</span><span style="color:#bf616a;">equals</span><span>(k))))
</span><span>            e = p;
</span><span>        </span><span style="color:#b48ead;">else if </span><span>(p instanceof </span><span style="color:#ebcb8b;">TreeNode</span><span>)
</span><span>            e = ((</span><span style="color:#ebcb8b;">TreeNode</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt;)p).</span><span style="color:#bf616a;">putTreeVal</span><span>(</span><span style="color:#bf616a;">this</span><span>, tab, hash, key, value);
</span><span>        </span><span style="color:#b48ead;">else </span><span>{
</span><span>            </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> binCount = </span><span style="color:#d08770;">0</span><span>; ; ++binCount) {
</span><span>                </span><span style="color:#b48ead;">if </span><span>((e = p.next) == </span><span style="color:#d08770;">null</span><span>) {
</span><span>                    p.next = </span><span style="color:#bf616a;">newNode</span><span>(hash, key, value, </span><span style="color:#d08770;">null</span><span>);
</span><span>                    </span><span style="color:#b48ead;">if </span><span>(binCount &gt;= </span><span style="color:#d08770;">TREEIFY_THRESHOLD </span><span>- </span><span style="color:#d08770;">1</span><span>) </span><span style="color:#65737e;">// -1 for 1st
</span><span>                        </span><span style="color:#bf616a;">treeifyBin</span><span>(tab, hash);
</span><span>                    </span><span style="color:#b48ead;">break</span><span>;
</span><span>                }
</span><span>                </span><span style="color:#b48ead;">if </span><span>(e.hash == hash &amp;&amp;((k = e.key) == key || (key != </span><span style="color:#d08770;">null </span><span>&amp;&amp; key.</span><span style="color:#bf616a;">equals</span><span>(k))))
</span><span>                    </span><span style="color:#b48ead;">break</span><span>;
</span><span>                p = e;
</span><span>            }
</span><span>        }
</span><span>        </span><span style="color:#b48ead;">if </span><span>(e != </span><span style="color:#d08770;">null</span><span>) { </span><span style="color:#65737e;">// existing mapping for key
</span><span>            </span><span style="color:#ebcb8b;">V</span><span> oldValue = e.value;
</span><span>            </span><span style="color:#b48ead;">if </span><span>(!onlyIfAbsent || oldValue == </span><span style="color:#d08770;">null</span><span>)
</span><span>                e.value = value;
</span><span>            </span><span style="color:#bf616a;">afterNodeAccess</span><span>(e);
</span><span>            </span><span style="color:#b48ead;">return</span><span> oldValue;
</span><span>        }
</span><span>    }
</span><span>    ++modCount;
</span><span>    </span><span style="color:#b48ead;">if </span><span>(++size &gt; threshold)
</span><span>        </span><span style="color:#bf616a;">resize</span><span>();
</span><span>    </span><span style="color:#bf616a;">afterNodeInsertion</span><span>(evict);
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">null</span><span>;
</span><span>}
</span></code></pre>
<p>在方法体的开始，定义了几个局部变量，以备后面使用(废话)。继续看下面的代码，这是方法体的第一个if判断，主要的作用是判断并创建一个<code>table</code>，注意，这里的<code>table</code>是一个数组+链表形式的结构，也就是数组每一个索引出的元素都是一条单链表的形式。这一点前面有提到。具体的逻辑是，</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">if </span><span>((tab = table) == </span><span style="color:#d08770;">null </span><span>|| (n = tab.length) == </span><span style="color:#d08770;">0</span><span>){
</span><span>     n = (tab = </span><span style="color:#bf616a;">resize</span><span>()).length;
</span><span>}
</span></code></pre>
<p>首先，对于<code>if</code>中的<code>(tab = table) == null </code>条件，程序先将<code>table</code>赋值给<code>tab</code>变量，判断集合中是否已经存在<code>table</code>数据，或者说该数组的长度是否为<code>0</code>。如果上述条件有一个成立，则表示<strong>这是第一次向集合中添加元素</strong>，<code>hashMap</code>会自动调用<code>resize()</code>方法对<code>table[]</code>进行首次扩容，以用来存放接下来的元素，所以，明白了这个判断的作用，也就不难推测，为什么这条<code>if</code>判断语句会放在方法的开始了，也可以推测，只要不是首次添加元素，就不再会进入该判断，直接走后面的逻辑。那么现在的关注点就该转移到这个<code>resize()</code>方法中，看一下它的源码：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">final </span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt;</span><span style="color:#b48ead;">[] </span><span style="color:#bf616a;">resize</span><span>() {
</span><span>    </span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt;</span><span style="color:#b48ead;">[]</span><span> oldTab = table;
</span><span>    </span><span style="color:#b48ead;">int</span><span> oldCap = (oldTab == </span><span style="color:#d08770;">null</span><span>) ? </span><span style="color:#d08770;">0 </span><span>: oldTab.length;
</span><span>    </span><span style="color:#b48ead;">int</span><span> oldThr = threshold;
</span><span>    </span><span style="color:#b48ead;">int</span><span> newCap, newThr = </span><span style="color:#d08770;">0</span><span>;
</span><span>    </span><span style="color:#b48ead;">if </span><span>(oldCap &gt; </span><span style="color:#d08770;">0</span><span>) {
</span><span>        </span><span style="color:#b48ead;">if </span><span>(oldCap &gt;= </span><span style="color:#d08770;">MAXIMUM_CAPACITY</span><span>) {
</span><span>            threshold = </span><span style="color:#ebcb8b;">Integer</span><span>.</span><span style="color:#d08770;">MAX_VALUE</span><span>;
</span><span>            </span><span style="color:#b48ead;">return</span><span> oldTab;
</span><span>        }
</span><span>        </span><span style="color:#b48ead;">else if </span><span>((newCap = oldCap &lt;&lt; </span><span style="color:#d08770;">1</span><span>) &lt; </span><span style="color:#d08770;">MAXIMUM_CAPACITY </span><span>&amp;&amp;
</span><span>                 oldCap &gt;= </span><span style="color:#d08770;">DEFAULT_INITIAL_CAPACITY</span><span>)
</span><span>            newThr = oldThr &lt;&lt; </span><span style="color:#d08770;">1</span><span>; </span><span style="color:#65737e;">// double threshold
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">else if </span><span>(oldThr &gt; </span><span style="color:#d08770;">0</span><span>) </span><span style="color:#65737e;">// initial capacity was placed in threshold
</span><span>        newCap = oldThr;
</span><span>    </span><span style="color:#b48ead;">else </span><span>{               </span><span style="color:#65737e;">// zero initial threshold signifies using defaults
</span><span>        newCap = </span><span style="color:#d08770;">DEFAULT_INITIAL_CAPACITY</span><span>;
</span><span>        newThr = (</span><span style="color:#b48ead;">int</span><span>)(</span><span style="color:#d08770;">DEFAULT_LOAD_FACTOR </span><span>* </span><span style="color:#d08770;">DEFAULT_INITIAL_CAPACITY</span><span>);
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">if </span><span>(newThr == </span><span style="color:#d08770;">0</span><span>) {
</span><span>        </span><span style="color:#b48ead;">float</span><span> ft = (</span><span style="color:#b48ead;">float</span><span>)newCap * loadFactor;
</span><span>        newThr = (newCap &lt; </span><span style="color:#d08770;">MAXIMUM_CAPACITY </span><span>&amp;&amp; ft &lt; (</span><span style="color:#b48ead;">float</span><span>)</span><span style="color:#d08770;">MAXIMUM_CAPACITY </span><span>?
</span><span>                  (</span><span style="color:#b48ead;">int</span><span>)ft : </span><span style="color:#ebcb8b;">Integer</span><span>.</span><span style="color:#d08770;">MAX_VALUE</span><span>);
</span><span>    }
</span><span>    threshold = newThr;
</span><span>    @</span><span style="color:#bf616a;">SuppressWarnings</span><span>({&quot;</span><span style="color:#a3be8c;">rawtypes</span><span>&quot;,&quot;</span><span style="color:#a3be8c;">unchecked</span><span>&quot;})
</span><span>    </span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt;</span><span style="color:#b48ead;">[]</span><span> newTab = (</span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt;</span><span style="color:#b48ead;">[]</span><span>)</span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">Node</span><span>[newCap];
</span><span>    table = newTab;
</span><span>    </span><span style="color:#b48ead;">if </span><span>(oldTab != </span><span style="color:#d08770;">null</span><span>) {
</span><span>        </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> j = </span><span style="color:#d08770;">0</span><span>; j &lt; oldCap; ++j) {
</span><span>            </span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt; e;
</span><span>            </span><span style="color:#b48ead;">if </span><span>((e = oldTab[j]) != </span><span style="color:#d08770;">null</span><span>) {
</span><span>                oldTab[j] = </span><span style="color:#d08770;">null</span><span>;
</span><span>                </span><span style="color:#b48ead;">if </span><span>(e.next == </span><span style="color:#d08770;">null</span><span>)
</span><span>                    newTab[e.hash &amp; (newCap - </span><span style="color:#d08770;">1</span><span>)] = e;
</span><span>                </span><span style="color:#b48ead;">else if </span><span>(e instanceof </span><span style="color:#ebcb8b;">TreeNode</span><span>)
</span><span>                    ((</span><span style="color:#ebcb8b;">TreeNode</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt;)e).</span><span style="color:#bf616a;">split</span><span>(</span><span style="color:#bf616a;">this</span><span>, newTab, j, oldCap);
</span><span>                </span><span style="color:#b48ead;">else </span><span>{ </span><span style="color:#65737e;">// preserve order
</span><span>                    </span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt; loHead = </span><span style="color:#d08770;">null</span><span>, loTail = </span><span style="color:#d08770;">null</span><span>;
</span><span>                    </span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt; hiHead = </span><span style="color:#d08770;">null</span><span>, hiTail = </span><span style="color:#d08770;">null</span><span>;
</span><span>                    </span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt; next;
</span><span>                    </span><span style="color:#b48ead;">do </span><span>{
</span><span>                        next = e.next;
</span><span>                        </span><span style="color:#b48ead;">if </span><span>((e.hash &amp; oldCap) == </span><span style="color:#d08770;">0</span><span>) {
</span><span>                            </span><span style="color:#b48ead;">if </span><span>(loTail == </span><span style="color:#d08770;">null</span><span>)
</span><span>                                loHead = e;
</span><span>                            </span><span style="color:#b48ead;">else
</span><span>                                loTail.next = e;
</span><span>                            loTail = e;
</span><span>                        }
</span><span>                        </span><span style="color:#b48ead;">else </span><span>{
</span><span>                            </span><span style="color:#b48ead;">if </span><span>(hiTail == </span><span style="color:#d08770;">null</span><span>)
</span><span>                                hiHead = e;
</span><span>                            </span><span style="color:#b48ead;">else
</span><span>                                hiTail.next = e;
</span><span>                            hiTail = e;
</span><span>                        }
</span><span>                    } </span><span style="color:#b48ead;">while </span><span>((e = next) != </span><span style="color:#d08770;">null</span><span>);
</span><span>                    </span><span style="color:#b48ead;">if </span><span>(loTail != </span><span style="color:#d08770;">null</span><span>) {
</span><span>                        loTail.next = </span><span style="color:#d08770;">null</span><span>;
</span><span>                        newTab[j] = loHead;
</span><span>                    }
</span><span>                    </span><span style="color:#b48ead;">if </span><span>(hiTail != </span><span style="color:#d08770;">null</span><span>) {
</span><span>                        hiTail.next = </span><span style="color:#d08770;">null</span><span>;
</span><span>                        newTab[j + oldCap] = hiHead;
</span><span>                    }
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">return</span><span> newTab;
</span><span>}
</span></code></pre>
<p>那就看下它的扩容原理吧。首先呢，如前面说所，它开始就创建了一个<code>table[]</code>。将该数组的引用赋给<code>oldTab</code>,</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span> </span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt;</span><span style="color:#b48ead;">[]</span><span> oldTab = table;
</span></code></pre>
<p>注意这里这个数组首次定义并非在这个方法中，而是在<code>HashMap</code>源码中有做的一个定义，<strong>它也是不可被序列化的</strong>。接着会先判断该<code>table</code>是否是首次创建，如果是，直接初始化为0，否则就是<code>oldTab</code>的大小，为什么会这么说呢，因为这个<code>resize()</code>方法可不只是执行这一次，在<code>putVal()</code>方法的后续的逻辑中还会用到，也就是会出现再次扩容的情况，那么存在一个<code>oldTab</code>的值也就不难理解了吧。</p>
<p>如果<code>oldCap&gt;0</code>，进一步判断它是否<code>&gt;=</code>最大容量<code>MAXNUM_CAPACITY</code>,关于<code>MAXNUM_CAPACITY</code>的定义如下</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#65737e;">//MAXIMUM_CAPACITY定义
</span><span style="color:#b48ead;">static final int </span><span style="color:#d08770;">MAXIMUM_CAPACITY </span><span>= </span><span style="color:#d08770;">1 </span><span>&lt;&lt; </span><span style="color:#d08770;">30</span><span>;
</span></code></pre>
<p>如果该条件成立，会给<code>threshod</code>重新赋一个新的容量值，即<code>Integer</code>的上限，反之进入下一个判断<code> ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</code>,将<code>oldCap</code>左移1位,也就是两倍的<code>oldCap</code>赋给一个新的变量<code>newCap</code>,如果该值小于<code>MAXNUM_CAPACITY</code>并且原来的容量<code>oldCap</code>大于等于初始默认容量值<code>DEFAULT_INITIAL_CAPACITY</code>的话，就将新的<code>newThr</code>扩为原来(<code>oldThr</code>)的两倍大小。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#65737e;">//DEFAULT_INITIAL_CAPACITY定义
</span><span style="color:#b48ead;">static final int </span><span style="color:#d08770;">DEFAULT_INITIAL_CAPACITY </span><span>= </span><span style="color:#d08770;">1 </span><span>&lt;&lt; </span><span style="color:#d08770;">4</span><span>; </span><span style="color:#65737e;">// aka 16
</span><span style="color:#65737e;">//1&lt;&lt;4等价于1X2^4=2x2x2x2=16
</span></code></pre>
<blockquote>
<p><strong>这里先对上面源码中涉及到的几个变量简单说明一下</strong>，<strong>不然频繁的<code>=</code>赋值操作一波又一波，可能会给整懵圈。</strong></p>
<ol>
<li><code>oldCap</code>:数组原先(准备扩容之前)的容量。</li>
<li><code>oldThr</code>：其实就是<code>threshold</code>的一个暂存局部变量，用来暂存<code>threshold</code>的值。</li>
<li><code>threshold</code>：这是一个定义在<code>HashMap</code>的的全局变量(<strong>可以这么说，实际上<code>Java</code>中没有全局变量这种概念</strong>),它用来存放<code>table[]</code>的一个容量值，或者说<strong>阈值</strong>。所以最终决定是否需要扩容取决于这个全局变量来判断。</li>
<li><code>newCap</code>:同理于<code>oldCap</code>。</li>
</ol>
</blockquote>
<p>继续回到最外层<code>if</code>判断的<code>else if</code>逻辑中，这里先是对<code>newThr</code>是否大于0作了判断，如果<code>&gt;0</code>成立，那么新的容量<code>newCap</code>的值沿用<code>oldThr</code>,否则将会执行下面这段代码,<code>newCap</code>的值默认设置为<code>DEFAULT_INITIAL_CAPACITY</code>也就是<code>16</code>,并且<code>newThr</code>的值更新为<code>(int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</code>。这里参与<code>*</code>运算的除了初始默认容量<code>DEFAULT_INITIAL_CAPACITY</code>外，还有一个重要的常量参数<code>DEFAULT_LOAD_FACTOR</code>，我们称为<strong>负载因子</strong>，换句话说，这个因子的值决定了你每次扩容的具体大小。它是默认值为<code>0.75</code>,也就是说当我们数组占用量达到本身容量的75%时，就会触发首次扩容(<code>resize</code>)操作。当然，最后还进行了强制类型转换为<code>int</code>。</p>
<p>所以不难理解，如果我们是首次使用<code>HashMap</code>进行<code>put</code>操作，方法会直接进入这一步进行初始化。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">else </span><span>{</span><span style="color:#65737e;">// zero initial threshold signifies using defaults
</span><span>    newCap = </span><span style="color:#d08770;">DEFAULT_INITIAL_CAPACITY</span><span>;
</span><span>    newThr = (</span><span style="color:#b48ead;">int</span><span>)(</span><span style="color:#d08770;">DEFAULT_LOAD_FACTOR </span><span>* </span><span style="color:#d08770;">DEFAULT_INITIAL_CAPACITY</span><span>);
</span><span>}
</span></code></pre>
<blockquote>
<p>具体一点说，当阈值达到<code>16*0.75</code>时，也即是16大小的容量用掉了12个大小时就会触发首次<code>resize</code>。</p>
</blockquote>
<p>这个<strong>负载因子</strong>不是固定不变的，而且有一点需要说明的是，这个<code>resize()</code>方法中，<strong>负载因子是可以手动传入的</strong>，这一点在<code>HashMap</code>的另一个构造方法中有体现，当然，这个后面再说。这里主要讲的还是无参构造器的执行原理，你需要理解<code>resize()</code>方法的两个主要作用，第一个就是上面巴拉巴拉这一堆，<strong>主要是用来对数组进行初始化工作</strong>(当然，你也可以理解为首次扩容，这只是一种说法而已，一般我们会将首次扩容称为初始化，因为其实<strong>扩容的概念是建立在已有容量的基础上的</strong>)，而此后再调用<code>resize()</code>就执行的是扩容工作了，但它的扩容工作可没有初始化这么简单。</p>
<p>但为了能更清晰的理解，我们还是继续首次<code>put</code>操作的主线进行分析。接着上面说，初始化结束之后，会得到一个初始的阈值<code>newThr=16</code>,并将该阈值重新赋给全局<code>threshold</code>保存。计算出<code>table[]</code>的一个初始大小之后，利用该值直接创建一个大小为<code>newCap</code>的新的<code>newTab</code>给<code>table</code>返回，有了这个<code>table</code>，我们就可以在里面存放元素了，比如存放一个字符串<code>Java</code>。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span>threshold = newThr;
</span><span>@</span><span style="color:#bf616a;">SuppressWarnings</span><span>({&quot;</span><span style="color:#a3be8c;">rawtypes</span><span>&quot;,&quot;</span><span style="color:#a3be8c;">unchecked</span><span>&quot;})
</span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt;</span><span style="color:#b48ead;">[]</span><span> newTab = (</span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt;</span><span style="color:#b48ead;">[]</span><span>)</span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">Node</span><span>[newCap];
</span><span>table = newTab;
</span></code></pre>
<p>但光是初始化一个16大小的<code>table</code>是远远不够的。我们知道，既然是数组里面存放元素，是需要一个索引的，根据这个索引去找到一个对应的位置，再将该元素覆盖上去，完成元素的添加。</p>
<p>所以我们先回到上一个方法<code>putVal()</code>方法：接着上面切入进来的<code>resize()</code>方法之后讲解。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">if </span><span>((tab = table) == </span><span style="color:#d08770;">null </span><span>|| (n = tab.length) == </span><span style="color:#d08770;">0</span><span>)
</span><span>    n = (tab = </span><span style="color:#bf616a;">resize</span><span>()).length;
</span></code></pre>
<blockquote>
<p>上面这两行代码，也就是我们上面刚刚讲完的初始化操作的部分。</p>
</blockquote>
<p>看一下，在对<code>table</code>进行了初始化，并计算得到<code>key</code>的<code>hash</code>之后，后续的代码逻辑分解：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">if </span><span>((p = tab[i = (n - </span><span style="color:#d08770;">1</span><span>) &amp; hash]) == </span><span style="color:#d08770;">null</span><span>)
</span><span>    tab[i] = </span><span style="color:#bf616a;">newNode</span><span>(hash, key, value, </span><span style="color:#d08770;">null</span><span>);
</span></code></pre>
<p>这里就是根据<code>hash</code>值计算一个索引<code>i</code>。方法是<code>(n-1) &amp; hash</code>,在获得索引之后，检查该索引位置的值<code>tab[i]</code>赋给变量<code>p</code>并判断是否为<code>null</code>，如果为<code>null</code>表示没有被使用，后面一句<code>tab[i] = newNode(hash, key, value, null);</code>直接将元素<code>key</code>存进去,当然，存入的元素除了我们自己传入的数据之外，还有计算出来的<code>hash</code>和一个<code>value</code>，传入<code>hash</code>主要是为了<strong>下一次计算，用来确定下次传入的值是否为重复元素。<strong>至于其中还有一个值为<code>null</code>的值，表示</strong>链表的下一个结点指向</strong>，当然，这里是首次<code>put</code>，所以<code>next</code>是不存在的，也就是<code>null</code>。当上面这段代码执行完毕之后，元素就被成功添加到<code>table</code>中了。</p>
<p><img src="C:/Users/22170/AppData/Roaming/Typora/typora-user-images/image-20220325162444469.png" alt="image-20220325162444469" loading="lazy" decoding="async" /></p>
<blockquote>
<p>通过<code>debug</code>可以看到,<code>key</code>计算出的<code>hash=2301537</code>.那么这个索引就可以根据<code>(16-1)&amp;2301537</code>计算出来，它的值是为<code>1</code>的，也就是数组中第二个位置的索引。</p>
</blockquote>
<p><img src="C:/Users/22170/AppData/Roaming/Typora/typora-user-images/image-20220325162819682.png" alt="image-20220325162819682" loading="lazy" decoding="async" /></p>
<p>元素添加之后，程序逻辑会直接执行到下面的代码</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span>++modCount;
</span><span style="color:#b48ead;">if </span><span>(++size &gt; threshold)
</span><span>    </span><span style="color:#bf616a;">resize</span><span>();
</span><span style="color:#bf616a;">afterNodeInsertion</span><span>(evict);
</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">null</span><span>;
</span></code></pre>
<p>其中的<code>++modCount</code>我在<code>ArrayList</code>源码分析的文章中已经提过，他们的作用是一样的。判断<code>if (++size &gt; threshold)</code>，如果添加元素之后的数组容量<code>&gt;</code>目前的阈值<code>threshold</code>，会触发<code>resize()</code>。关于<code>afterNodeInsertion(evict);</code>方法，是<code>HashMap</code>留给它的子类去实现的一个方法，所以它是个空的方法。类似的方法还有：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#65737e;">// Callbacks to allow LinkedHashMap post-actions
</span><span>void </span><span style="color:#bf616a;">afterNodeAccess</span><span>(</span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt; p) { }
</span><span>void </span><span style="color:#bf616a;">afterNodeInsertion</span><span>(</span><span style="color:#b48ead;">boolean</span><span> evict) { }
</span><span>void </span><span style="color:#bf616a;">afterNodeRemoval</span><span>(</span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt; p) { }
</span></code></pre>
<p>接着<code>putVal()</code>方法最后返回一个<code>null</code>作为方法的结束。<strong>所以还记得前面留的一个问题吗</strong>？在<code>HashSet</code>源码中的<code>add()</code>方法的方法体里面，它的返回值是判断是否为<code>null</code>,再看一下吧还是。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">public boolean </span><span style="color:#bf616a;">add</span><span>(</span><span style="color:#ebcb8b;">E</span><span> e) {
</span><span>    </span><span style="color:#b48ead;">return</span><span> map.</span><span style="color:#bf616a;">put</span><span>(e, </span><span style="color:#d08770;">PRESENT</span><span>)==</span><span style="color:#d08770;">null</span><span>;
</span><span>}
</span></code></pre>
<p>表示执行<code>HashSet</code>中的<code>add()</code>方法添加一个元素，它底层实际上调用了<code>HashMap</code>中的<code>put()</code>方法去实现，能否添加成功的依据就是该<code>put()</code>方法是否返回<code>null</code>,如果是，<code>HashSet</code>的<code>add()</code>方法就返回一个<code>true</code>,最终表示着我们利用<code>HashSet</code>成功的添加了一个元素。否则，添加失败！！</p>
<hr />
<h6 id="-14">去重原理</h6>
<blockquote>
<p>在理解了<code>HashMap</code>底层<code>table[]</code>的初始化逻辑之后，当我们向其中<code>put()</code>第二个元素时，它的底层是如何判断元素是否重复的呢？下面就以这个问题为主线开始分析。</p>
</blockquote>
<p>由于同样是添加的操作，前面的的几个步骤就不再赘述，比如底层调用<code>map.put()</code>，然后是<code>hash</code>的计算。直接进入<code>putVal()</code>方法开始看。这里再贴一遍它的源码：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">final </span><span style="color:#ebcb8b;">V </span><span style="color:#bf616a;">putVal</span><span>(</span><span style="color:#b48ead;">int</span><span> hash, </span><span style="color:#ebcb8b;">K</span><span> key, </span><span style="color:#ebcb8b;">V</span><span> value, </span><span style="color:#b48ead;">boolean</span><span> onlyIfAbsent,</span><span style="color:#b48ead;">boolean</span><span> evict) {
</span><span>    </span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt;</span><span style="color:#b48ead;">[]</span><span> tab; </span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt; p; </span><span style="color:#b48ead;">int</span><span> n, i;
</span><span>    </span><span style="color:#b48ead;">if </span><span>((tab = table) == </span><span style="color:#d08770;">null </span><span>|| (n = tab.length) == </span><span style="color:#d08770;">0</span><span>)
</span><span>        n = (tab = </span><span style="color:#bf616a;">resize</span><span>()).length;
</span><span>    </span><span style="color:#b48ead;">if </span><span>((p = tab[i = (n - </span><span style="color:#d08770;">1</span><span>) &amp; hash]) == </span><span style="color:#d08770;">null</span><span>)
</span><span>        tab[i] = </span><span style="color:#bf616a;">newNode</span><span>(hash, key, value, </span><span style="color:#d08770;">null</span><span>);
</span><span>    </span><span style="color:#b48ead;">else </span><span>{
</span><span>        </span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt; e; </span><span style="color:#ebcb8b;">K</span><span> k;
</span><span>        </span><span style="color:#b48ead;">if </span><span>(p.hash == hash &amp;&amp;
</span><span>            ((k = p.key) == key || (key != </span><span style="color:#d08770;">null </span><span>&amp;&amp; key.</span><span style="color:#bf616a;">equals</span><span>(k))))
</span><span>            e = p;
</span><span>        </span><span style="color:#b48ead;">else if </span><span>(p instanceof </span><span style="color:#ebcb8b;">TreeNode</span><span>)
</span><span>            e = ((</span><span style="color:#ebcb8b;">TreeNode</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt;)p).</span><span style="color:#bf616a;">putTreeVal</span><span>(</span><span style="color:#bf616a;">this</span><span>, tab, hash, key, value);
</span><span>        </span><span style="color:#b48ead;">else </span><span>{
</span><span>            </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> binCount = </span><span style="color:#d08770;">0</span><span>; ; ++binCount) {
</span><span>                </span><span style="color:#b48ead;">if </span><span>((e = p.next) == </span><span style="color:#d08770;">null</span><span>) {
</span><span>                    p.next = </span><span style="color:#bf616a;">newNode</span><span>(hash, key, value, </span><span style="color:#d08770;">null</span><span>);
</span><span>                    </span><span style="color:#b48ead;">if </span><span>(binCount &gt;= </span><span style="color:#d08770;">TREEIFY_THRESHOLD </span><span>- </span><span style="color:#d08770;">1</span><span>) </span><span style="color:#65737e;">// -1 for 1st
</span><span>                        </span><span style="color:#bf616a;">treeifyBin</span><span>(tab, hash);
</span><span>                    </span><span style="color:#b48ead;">break</span><span>;
</span><span>                }
</span><span>                </span><span style="color:#b48ead;">if </span><span>(e.hash == hash &amp;&amp;
</span><span>                    ((k = e.key) == key || (key != </span><span style="color:#d08770;">null </span><span>&amp;&amp; key.</span><span style="color:#bf616a;">equals</span><span>(k))))
</span><span>                    </span><span style="color:#b48ead;">break</span><span>;
</span><span>                p = e;
</span><span>            }
</span><span>        }
</span><span>        </span><span style="color:#b48ead;">if </span><span>(e != </span><span style="color:#d08770;">null</span><span>) { </span><span style="color:#65737e;">// existing mapping for key
</span><span>            </span><span style="color:#ebcb8b;">V</span><span> oldValue = e.value;
</span><span>            </span><span style="color:#b48ead;">if </span><span>(!onlyIfAbsent || oldValue == </span><span style="color:#d08770;">null</span><span>)
</span><span>                e.value = value;
</span><span>            </span><span style="color:#bf616a;">afterNodeAccess</span><span>(e);
</span><span>            </span><span style="color:#b48ead;">return</span><span> oldValue;
</span><span>        }
</span><span>    }
</span><span>    ++modCount;
</span><span>    </span><span style="color:#b48ead;">if </span><span>(++size &gt; threshold)
</span><span>        </span><span style="color:#bf616a;">resize</span><span>();
</span><span>    </span><span style="color:#bf616a;">afterNodeInsertion</span><span>(evict);
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">null</span><span>;
</span><span>}
</span></code></pre>
<p>鉴于前面我们在添加第一个元素<code>Java</code>的时候，已经完成了<code>table[]</code>的初始化工作，所以下面这段代码不会再执行;</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">if </span><span>((tab = table) == </span><span style="color:#d08770;">null </span><span>|| (n = tab.length) == </span><span style="color:#d08770;">0</span><span>) n = (tab = </span><span style="color:#bf616a;">resize</span><span>()).length;
</span></code></pre>
<p>而是直接带着前面计算得来得<code>Hash</code>通过与之前同样算法计算出元素<code>C++</code>(假设这是我们第二个添加的元素)在数组中的索引，代码如下：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">if </span><span>((p = tab[i = (n - </span><span style="color:#d08770;">1</span><span>) &amp; hash]) == </span><span style="color:#d08770;">null</span><span>) tab[i] = </span><span style="color:#bf616a;">newNode</span><span>(hash, key, value, </span><span style="color:#d08770;">null</span><span>);
</span></code></pre>
<blockquote>
<p>注意哈，这里的<code>n</code>在初始化的时候已经计算出来，还是等于16的，改变的是<code>hash</code>值，假设为<code>65762</code>。那么根据上述算法计算得到它的索引为<code>15&amp;65762=2</code>。</p>
</blockquote>
<p>好了，既然索引也有了，并且我们添加的这个元素和第一个元素<code>Java</code>明显是不相等的，所以不会进入到<code>else if</code>判断中，因为<code>if</code>已经成立，后面的逻辑就是将该元素值直接添加到数组中索引为<code>2</code>的位置，当然，元素也是一个<code>Node&lt;k,v&gt;</code>类型。注意，这里存入参数中的最后一个值依旧还是<code>null</code>，因为前后两个元素并没有存放在同一条链表上，自然不会出现在尾部挂载的情况。</p>
<blockquote>
<p>下面将会进行第三个元素的添加，假设我们添加的元素是<code>Java</code>,是的，和<strong>首次添加的元素是相同的</strong>，看一下底层将会如何处理。</p>
</blockquote>
<p>同样我们直接跳到<code>putVal()</code>方法中。程序首先会进入到第二个<code>if</code>判断里，开始计算索引并作判断，也就是下面这段代码：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">if </span><span>((p = tab[i = (n - </span><span style="color:#d08770;">1</span><span>) &amp; hash]) == </span><span style="color:#d08770;">null</span><span>)
</span><span>    tab[i] = </span><span style="color:#bf616a;">newNode</span><span>(hash, key, value, </span><span style="color:#d08770;">null</span><span>);
</span></code></pre>
<p>注意了，由于首次计算得出<code>Java</code>对应的索引为<code>2</code>,那么这次的结果也是相同的值，所以<code>if</code>中的条件显然不可能成立，因为索引为<code>2</code>的位置已经被占用，自然不会为<code>null</code>。所以程序将会进入下面的逻辑中：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">else </span><span>{
</span><span>    </span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt; e; </span><span style="color:#ebcb8b;">K</span><span> k;
</span><span>    </span><span style="color:#b48ead;">if </span><span>(p.hash == hash &amp;&amp;
</span><span>        ((k = p.key) == key || (key != </span><span style="color:#d08770;">null </span><span>&amp;&amp; key.</span><span style="color:#bf616a;">equals</span><span>(k))))
</span><span>        e = p;
</span><span>    </span><span style="color:#b48ead;">else if </span><span>(p instanceof </span><span style="color:#ebcb8b;">TreeNode</span><span>)
</span><span>        e = ((</span><span style="color:#ebcb8b;">TreeNode</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt;)p).</span><span style="color:#bf616a;">putTreeVal</span><span>(</span><span style="color:#bf616a;">this</span><span>, tab, hash, key, value);
</span><span>    </span><span style="color:#b48ead;">else </span><span>{
</span><span>        </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> binCount = </span><span style="color:#d08770;">0</span><span>; ; ++binCount) {
</span><span>            </span><span style="color:#b48ead;">if </span><span>((e = p.next) == </span><span style="color:#d08770;">null</span><span>) {
</span><span>                p.next = </span><span style="color:#bf616a;">newNode</span><span>(hash, key, value, </span><span style="color:#d08770;">null</span><span>);
</span><span>                </span><span style="color:#b48ead;">if </span><span>(binCount &gt;= </span><span style="color:#d08770;">TREEIFY_THRESHOLD </span><span>- </span><span style="color:#d08770;">1</span><span>) </span><span style="color:#65737e;">// -1 for 1st
</span><span>                    </span><span style="color:#bf616a;">treeifyBin</span><span>(tab, hash);
</span><span>                </span><span style="color:#b48ead;">break</span><span>;
</span><span>            }
</span><span>            </span><span style="color:#b48ead;">if </span><span>(e.hash == hash &amp;&amp;
</span><span>                ((k = e.key) == key || (key != </span><span style="color:#d08770;">null </span><span>&amp;&amp; key.</span><span style="color:#bf616a;">equals</span><span>(k))))
</span><span>                </span><span style="color:#b48ead;">break</span><span>;
</span><span>            p = e;
</span><span>        }
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">if </span><span>(e != </span><span style="color:#d08770;">null</span><span>) { </span><span style="color:#65737e;">// existing mapping for key
</span><span>        </span><span style="color:#ebcb8b;">V</span><span> oldValue = e.value;
</span><span>        </span><span style="color:#b48ead;">if </span><span>(!onlyIfAbsent || oldValue == </span><span style="color:#d08770;">null</span><span>)
</span><span>            e.value = value;
</span><span>        </span><span style="color:#bf616a;">afterNodeAccess</span><span>(e);
</span><span>        </span><span style="color:#b48ead;">return</span><span> oldValue;
</span><span>    }
</span><span>}
</span></code></pre>
<p>又是一堆<code>if else if</code>套娃操作。按照它的顺序，我们先分析第一个<code>if</code>的逻辑：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">if </span><span>(p.hash == hash &amp;&amp;((k = p.key) == key || (key != </span><span style="color:#d08770;">null </span><span>&amp;&amp; key.</span><span style="color:#bf616a;">equals</span><span>(k))))
</span><span>    e = p;
</span></code></pre>
<p>鉴于<code>()</code>中涉及到了三处逻辑运算，方便理解，我们将它逐层进行拆分讲解。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span>(k = p.key) == key || (key != </span><span style="color:#d08770;">null </span><span>&amp;&amp; key.</span><span style="color:#bf616a;">equals</span><span>(k))
</span></code></pre>
<p>首先看<code>||</code>的左边<code>(k=p.key)==key</code>:意思是先将<code>p</code>中的<code>key</code>值赋给变量<code>k</code>,再与<code>key</code>进行一个比较，判断是否为同一个<code>key</code>值(对象)，注意了，这里的两个<code>key</code>的意思，前一个<code>key</code>(也就是<code>k</code>)**代表的是数组之前已经存在数组中的元素，**而后一个<code>key</code><strong>就是当前传入的元素</strong>，具体的也就是指我们第一次存入的<code>Java</code>和本次存入的<code>Java</code>。</p>
<p>再看<code>||</code>右边<code>(key != null &amp;&amp; key.equals(k)</code>,这是一个<code>&amp;&amp;</code>操作,需要操作符两边的条件同时成立，整个条件才会成立。首先判断存入的<code>key</code>是否为<code>null</code>，再判断<code>key</code>和<code>k</code>是否为相同（注意这里用了<code>equals()</code>方法,该方法可被重写），判断是否为相同的内容。回到外层的<code>p.hash==hash</code>这个判断，就是将已有索引处对应的元素(元素是存在<code>Node</code>上的)的<code>hash</code>值取出与当前元素的<code>Hash</code>进行比较。</p>
<p>所以归纳起来也就是当二者<code>hash</code>相同并且<code>key</code>也相同(同一个对象)的情况下，执行<code>e=p</code>赋值操作，将原位置的值进行覆盖。</p>
<p>如果上面的条件不成立，会判断<code>p</code>是否是红黑树，如果是，就调用对应的添加方法<code>putTreeVal()</code>进行添加，也就是下面的代码。这里的 <code>instanceof</code>关键字用来判断一个对象是否为一个类的实例。另外，<code>putTreeVal()</code>方法内部涉及到大量红黑树的代码，相对复杂很多，如果跳进去的话，估计一时半会出不来，所以这里暂时不作探究，会另外分开来学习，还是围绕着主线继续分析。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">else if </span><span>(p instanceof </span><span style="color:#ebcb8b;">TreeNode</span><span>)
</span><span>    e = ((</span><span style="color:#ebcb8b;">TreeNode</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt;)p).</span><span style="color:#bf616a;">putTreeVal</span><span>(</span><span style="color:#bf616a;">this</span><span>, tab, hash, key, value);
</span></code></pre>
<p>否则，进入<code>else</code>逻辑中：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">else </span><span>{
</span><span>    </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> binCount = </span><span style="color:#d08770;">0</span><span>; ; ++binCount) {
</span><span>        </span><span style="color:#b48ead;">if </span><span>((e = p.next) == </span><span style="color:#d08770;">null</span><span>) {
</span><span>            p.next = </span><span style="color:#bf616a;">newNode</span><span>(hash, key, value, </span><span style="color:#d08770;">null</span><span>);
</span><span>            </span><span style="color:#b48ead;">if </span><span>(binCount &gt;= </span><span style="color:#d08770;">TREEIFY_THRESHOLD </span><span>- </span><span style="color:#d08770;">1</span><span>) </span><span style="color:#65737e;">// -1 for 1st
</span><span>                </span><span style="color:#bf616a;">treeifyBin</span><span>(tab, hash);
</span><span>            </span><span style="color:#b48ead;">break</span><span>;
</span><span>        }
</span><span>        </span><span style="color:#b48ead;">if </span><span>(e.hash == hash &amp;&amp;
</span><span>            ((k = e.key) == key || (key != </span><span style="color:#d08770;">null </span><span>&amp;&amp; key.</span><span style="color:#bf616a;">equals</span><span>(k))))
</span><span>            </span><span style="color:#b48ead;">break</span><span>;
</span><span>        p = e;
</span><span>    }
</span><span>}
</span></code></pre>
<p>开局一个<code>for</code>，目的明确，<strong>既然上面两种情况都不成立，那么说明该元素可能会在某一条链表节点上出现</strong>，比如下面这样：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#bf616a;">Java</span><span style="color:#b48ead;">-&gt;</span><span style="color:#ebcb8b;">C</span><span>++-&gt;</span><span style="color:#bf616a;">Javascript</span><span style="color:#b48ead;">-&gt;</span><span style="color:#ebcb8b;">Java
</span></code></pre>
<p>所以我们需要以遍历的方式去检查链表上的每一个节点，循环内部，通过<code>p</code>和<code>e</code>两个指针不停的循环比较。</p>
<p>如果过程中发现有一个和当前元素重复的元素，循环会立即结束，元素添加失败，否则就将当前元素直接挂到节点后面，完成添加。注意其中这段代码:</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">if </span><span>(binCount &gt;= </span><span style="color:#d08770;">TREEIFY_THRESHOLD </span><span>- </span><span style="color:#d08770;">1</span><span>) </span><span style="color:#65737e;">// -1 for 1st
</span><span>    </span><span style="color:#bf616a;">treeifyBin</span><span>(tab, hash);
</span><span style="color:#65737e;">//TREEIFY_THRESHOLD的定义
</span><span style="color:#b48ead;">static final int </span><span style="color:#d08770;">TREEIFY_THRESHOLD </span><span>= </span><span style="color:#d08770;">8</span><span>;
</span></code></pre>
<p>这是在进行<strong>添加之后对当前这条链表进行一个判断</strong>，如果长度<code>&gt;=(TREEIFY_THRESHOLD=8)-1</code>的话，会调用<code>treeifBin()</code>方法对当前链表进行树化(转红黑树)，但是注意，光是这个条件满足还不足以开始树化，在这个方法的实现中，还添加了其他的添加用来判断，<code>treeifBin()</code>源码：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">final</span><span> void </span><span style="color:#bf616a;">treeifyBin</span><span>(</span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt;</span><span style="color:#b48ead;">[]</span><span> tab, </span><span style="color:#b48ead;">int</span><span> hash) {
</span><span>    </span><span style="color:#b48ead;">int</span><span> n, index; </span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt; e;
</span><span>    </span><span style="color:#b48ead;">if </span><span>(tab == </span><span style="color:#d08770;">null </span><span>|| (n = tab.length) &lt; </span><span style="color:#d08770;">MIN_TREEIFY_CAPACITY</span><span>)
</span><span>        </span><span style="color:#bf616a;">resize</span><span>();
</span><span>    </span><span style="color:#b48ead;">else if </span><span>((e = tab[index = (n - </span><span style="color:#d08770;">1</span><span>) &amp; hash]) != </span><span style="color:#d08770;">null</span><span>) {
</span><span>        </span><span style="color:#ebcb8b;">TreeNode</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt; hd = </span><span style="color:#d08770;">null</span><span>, tl = </span><span style="color:#d08770;">null</span><span>;
</span><span>        </span><span style="color:#b48ead;">do </span><span>{
</span><span>            </span><span style="color:#ebcb8b;">TreeNode</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt; p = </span><span style="color:#bf616a;">replacementTreeNode</span><span>(e, </span><span style="color:#d08770;">null</span><span>);
</span><span>            </span><span style="color:#b48ead;">if </span><span>(tl == </span><span style="color:#d08770;">null</span><span>)
</span><span>                hd = p;
</span><span>            </span><span style="color:#b48ead;">else </span><span>{
</span><span>                p.prev = tl;
</span><span>                tl.next = p;
</span><span>            }
</span><span>            tl = p;
</span><span>        } </span><span style="color:#b48ead;">while </span><span>((e = e.next) != </span><span style="color:#d08770;">null</span><span>);
</span><span>        </span><span style="color:#b48ead;">if </span><span>((tab[index] = hd) != </span><span style="color:#d08770;">null</span><span>)
</span><span>            hd.</span><span style="color:#bf616a;">treeify</span><span>(tab);
</span><span>    }
</span><span>}
</span></code></pre>
<p>就是说，就算前面的条件(<code>&gt;=8</code>)已经成立，这里还会进行一个判断，具体逻辑如下：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">if </span><span>(tab == </span><span style="color:#d08770;">null </span><span>|| (n = tab.length) &lt; </span><span style="color:#d08770;">MIN_TREEIFY_CAPACITY</span><span>)
</span><span>    </span><span style="color:#bf616a;">resize</span><span>();
</span></code></pre>
<p>它还会判断当前这个<code>table</code>的大小是否<code>&lt;MIN_TREEIFY_CAPACITY</code>也就是是否<code>&lt;64</code>。如果这个条件成立，那么会先对数组进行一个<code>resize()</code>扩容操作，而不是直接转红黑树。最后如果添加失败，会返回一个之前元素的<code>value</code>值。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">if </span><span>(e != </span><span style="color:#d08770;">null</span><span>) { </span><span style="color:#65737e;">// existing mapping for key
</span><span>    </span><span style="color:#ebcb8b;">V</span><span> oldValue = e.value;
</span><span>    </span><span style="color:#b48ead;">if </span><span>(!onlyIfAbsent || oldValue == </span><span style="color:#d08770;">null</span><span>)
</span><span>        e.value = value;
</span><span>    </span><span style="color:#bf616a;">afterNodeAccess</span><span>(e);
</span><span>    </span><span style="color:#b48ead;">return</span><span> oldValue;
</span><span>	}
</span><span style="background-color:#bf616a;color:#2b303b;">}</span><span>
</span></code></pre>
<h6 id="-15">扩容原理</h6>
<p>前面对整个流程有了大致的了解之后，下面主要针对它的<strong>扩容原理</strong>进行一个简单的总结。</p>
<p>关于扩容的原理，先说结论：</p>
<ul>
<li>
<p><code>HashSet</code>底层是<code>HashMap</code>，首次添加时，<code>table</code>数组的容量扩为16，初始临界值为12:</p>
<blockquote>
<p>threshold(阈值) = table.size()(table数组大小) * loadFactor(加载因子)</p>
<p>=16*0.75</p>
<p>=12</p>
</blockquote>
</li>
<li>
<p>如果<code>table</code>数组使用的部分达到了阈值，就会触发扩容，具体的扩容为<code>16*2=32</code>,也就是<strong>会按照两倍的扩容</strong>方式进行，基于这个容量再次计算新的扩容阈值:<code>32*0.75=24</code>,也就是如果本次扩容后的容量(32)使用达到24之后，就会再次触发下一次的2倍扩容机制，以此类推。</p>
</li>
</ul>
<p><strong>简单来说，以上就是<code>HashSet(本质HashMap)</code>的扩容原理，具体的，看下面源码分析。</strong></p>
<blockquote>
<p>在resize()方法中有这样一段代码</p>
</blockquote>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">else if </span><span>((newCap = oldCap &lt;&lt; </span><span style="color:#d08770;">1</span><span>) &lt; </span><span style="color:#d08770;">MAXIMUM_CAPACITY </span><span>&amp;&amp;
</span><span>         oldCap &gt;= </span><span style="color:#d08770;">DEFAULT_INITIAL_CAPACITY</span><span>)
</span><span>    newThr = oldThr &lt;&lt; </span><span style="color:#d08770;">1</span><span>; </span><span style="color:#65737e;">// double threshold
</span></code></pre>
<p>可以看到，新的容量是在原有容量的基础作了一个左移的操作，也就是和乘2是等效的，但用位运算效率会快很多。</p>
<blockquote>
<p>这是在pustVal()源码的部分代码：</p>
</blockquote>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span>++modCount;
</span><span style="color:#b48ead;">if </span><span>(++size &gt; threshold)
</span><span>    </span><span style="color:#bf616a;">resize</span><span>();
</span><span style="color:#bf616a;">afterNodeInsertion</span><span>(evict);
</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">null</span><span>;
</span></code></pre>
<blockquote>
<p>resize();就是触发扩容时调用的扩容方法。具体的源码前面有讲过，不再赘述。</p>
</blockquote>
<p>在Java8中，如果一条链表的元素个数达到<code> TREEIFY_THRESHOLD</code>且此时<code>table</code>的大小&gt;=<code>MIN_TREEIFY_CAPACITY</code></p>
<p>时就会触发链表转红黑树的操作。提高性能。</p>
<blockquote>
<p>上面涉及到的两个常量在源代码中的定义如下：</p>
</blockquote>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">static final int </span><span style="color:#d08770;">TREEIFY_THRESHOLD </span><span>= </span><span style="color:#d08770;">8</span><span>;
</span><span style="color:#b48ead;">static final int </span><span style="color:#d08770;">MIN_TREEIFY_CAPACITY </span><span>= </span><span style="color:#d08770;">64</span><span>;
</span></code></pre>
<p>转红黑树的方法源码如下，这里只需要看看大致的执行逻辑就好，关于红黑树具体的实现，不是本章的主要内容。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">final</span><span> void </span><span style="color:#bf616a;">treeifyBin</span><span>(</span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt;</span><span style="color:#b48ead;">[]</span><span> tab, </span><span style="color:#b48ead;">int</span><span> hash) {
</span><span>    </span><span style="color:#b48ead;">int</span><span> n, index; </span><span style="color:#ebcb8b;">Node</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt; e;
</span><span>    </span><span style="color:#b48ead;">if </span><span>(tab == </span><span style="color:#d08770;">null </span><span>|| (n = tab.length) &lt; </span><span style="color:#d08770;">MIN_TREEIFY_CAPACITY</span><span>)
</span><span>        </span><span style="color:#bf616a;">resize</span><span>();
</span><span>    </span><span style="color:#b48ead;">else if </span><span>((e = tab[index = (n - </span><span style="color:#d08770;">1</span><span>) &amp; hash]) != </span><span style="color:#d08770;">null</span><span>) {
</span><span>        </span><span style="color:#ebcb8b;">TreeNode</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt; hd = </span><span style="color:#d08770;">null</span><span>, tl = </span><span style="color:#d08770;">null</span><span>;
</span><span>        </span><span style="color:#b48ead;">do </span><span>{
</span><span>            </span><span style="color:#ebcb8b;">TreeNode</span><span>&lt;</span><span style="color:#ebcb8b;">K</span><span>,</span><span style="color:#ebcb8b;">V</span><span>&gt; p = </span><span style="color:#bf616a;">replacementTreeNode</span><span>(e, </span><span style="color:#d08770;">null</span><span>);
</span><span>            </span><span style="color:#b48ead;">if </span><span>(tl == </span><span style="color:#d08770;">null</span><span>)
</span><span>                hd = p;
</span><span>            </span><span style="color:#b48ead;">else </span><span>{
</span><span>                p.prev = tl;
</span><span>                tl.next = p;
</span><span>            }
</span><span>            tl = p;
</span><span>        } </span><span style="color:#b48ead;">while </span><span>((e = e.next) != </span><span style="color:#d08770;">null</span><span>);
</span><span>        </span><span style="color:#b48ead;">if </span><span>((tab[index] = hd) != </span><span style="color:#d08770;">null</span><span>)
</span><span>            hd.</span><span style="color:#bf616a;">treeify</span><span>(tab);
</span><span>    }
</span><span>}
</span></code></pre>
<p><strong>注意如果只是满足链表长度达到8的条件时，它还是会采用<code>resize()</code>方法对数组扩容，而不是直接转红黑树。</strong></p>
<p><strong>注意了！！</strong></p>
<blockquote>
<p>上面提到的触发数组扩容的条件中，<code>size</code>的大小大于负载因子才会触发，这里的<code>size</code>指<code>的是数组和链表中元素的和</code>，也就是只要我们向其中添加一个元素，不论这个元素是存在数组第一个位置，还是存在链表中某个位置，<code>size都会自增1</code>，这是一个比较容易搞错的地方，<strong>不要认为size就是指数组的长度，这是错误的。</strong></p>
</blockquote>
<hr />
<p><strong>为什么不直接使用<code>hash</code>来计算索引，而是要进行取模运算？</strong></p>
<blockquote>
<p>如果将哈希码映射到数组中的一个索引。可能会因为<code>hash</code>值过大而因此导致索引超出范围。所以一个最简单的方法是对哈希码和数组的长度进行模运算，如<code>hash(key) % n</code>。如此可以<strong>确保索引i总是在0和n之间。</strong></p>
</blockquote>
<p>但是Java在实现的时候，用的并不是上面说的算法，而是将<strong>数组的长度n减去1之后再与<code>hash</code>作<code>&amp;</code>运算得到</strong>，实现代码如下:</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span>i = (n - </span><span style="color:#d08770;">1</span><span>) &amp; hash;
</span></code></pre>
<hr />
<h4 id="-16">LinkedHashSet</h4>
<h5 id="-17">概述</h5>
<ul>
<li><code>LinkedHashSet</code>是<code>Set</code>接口的一个实现子类，也是<code>HashSet</code>的子类。</li>
<li><code>LinkedHashSet</code>的底层是一个<code>LinkedHashMap</code>，底层维护了一个<strong>数组+双向链表</strong>。</li>
<li><code>LinkedHashSet</code>根据元素的<code>hashCode</code>值来决定元素的存储位置，同时<strong>使用链表来维护元素的次序</strong>，这就使得元素看起来是以插入的顺序保存的。</li>
<li>其次，<code>LinkedHashSet</code>也<strong>不允许添加重复元素</strong>。</li>
</ul>
<p><img src="https://images.waer.ltd/img/LinkedHashSet.png" alt="" loading="lazy" decoding="async" /></p>
<p>在<code>LinkedHashSet</code>中维护了一个<code>hash</code>表和双向链表，每一个节点有<code>pre</code>和<code>next</code>属性，这样可以形成双向链表。在添加元素时，先求<code>hash</code>值，再求索引，确定该元素在哈希表中的位置，然后将添加的元素加入到双向链表（如果已经存在，不添加(原理和<code>hashset类似</code>)）。</p>
<h5 id="-18">源码解读</h5>
<ul>
<li>通过下面的示例来配合讲解：</li>
</ul>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#ebcb8b;">Set</span><span> set = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">LinkedHashSet</span><span>();
</span><span>set.</span><span style="color:#bf616a;">add</span><span>(&quot;</span><span style="color:#a3be8c;">A</span><span>&quot;);
</span><span>set.</span><span style="color:#bf616a;">add</span><span>(</span><span style="color:#d08770;">120</span><span>);
</span><span>set.</span><span style="color:#bf616a;">add</span><span>(</span><span style="color:#d08770;">120</span><span>);
</span><span>set.</span><span style="color:#bf616a;">add</span><span>(</span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">User</span><span>(&quot;</span><span style="color:#a3be8c;">李</span><span>&quot;,</span><span style="color:#d08770;">1001</span><span>));
</span><span>set.</span><span style="color:#bf616a;">add</span><span>(</span><span style="color:#d08770;">123</span><span>);
</span><span>set.</span><span style="color:#bf616a;">add</span><span>(</span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">String</span><span>(&quot;</span><span style="color:#a3be8c;">hello</span><span>&quot;));
</span><span style="color:#ebcb8b;">System</span><span>.out.</span><span style="color:#bf616a;">println</span><span>(set);
</span></code></pre>
<p>如果断点的方式，我们可以看到，<code>LinkedHashSet</code>的一个基本结构如下：</p>
<p><img src="https://images.waer.ltd/img/20220426085807.png" alt="" loading="lazy" decoding="async" /></p>
<p>通过上图可以发现，其中存在一个<code>tail</code>和<code>head</code>的属性，这是典型的双向链表中才会用到的两个引用，或者指针(c/c++)，<strong>代表双向链表的头尾指针</strong>。即进一步验证了前面提到的<code>LinkedHashSet</code>的是一个<code>HashTable</code>和双向链表的组合。</p>
<p>其中的<code>table</code>类型其实是一个<code>HashMap$Node[]</code>类型，而每一个节点又是维护的<code>LinkedHashMap$Entry[]</code>类型。</p>
<p><img src="https://images.waer.ltd/img/20220426090925.png" alt="" loading="lazy" decoding="async" /></p>
<p>为什么数组为<code>HashMap$Node[]数组类型</code>而存放的元素却是<code>LinkedHashMap$Entry[]</code>类型？</p>
<blockquote>
<p>说明<code>LinkedHashMap$Entry[]</code>肯定继<strong>承或者实现</strong>了<code>HashMap$Node[]</code>的，即通过<strong>数组多态</strong>的方式实现。注意这里的<code>$</code>符号标识$之后的类作为<code>$</code>之前的一个静态内部类，也即表示在<code>LinkedHashMap$Entry</code>中，<code>Entry</code>是<code>LinkedHashMap</code>的一个<strong>静态内部类。</strong></p>
</blockquote>
<p>在<code>LinkdeHashMap</code>中我们可以找到对应的源码验证。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">static class </span><span style="color:#ebcb8b;">Entry</span><span style="color:#eff1f5;">&lt;</span><span style="color:#bf616a;">K</span><span style="color:#eff1f5;">,</span><span style="color:#bf616a;">V</span><span style="color:#eff1f5;">&gt; </span><span style="color:#b48ead;">extends </span><span style="color:#a3be8c;">HashMap</span><span style="color:#eff1f5;">.</span><span style="color:#a3be8c;">Node</span><span style="color:#eff1f5;">&lt;</span><span style="color:#ebcb8b;">K</span><span style="color:#eff1f5;">,</span><span style="color:#ebcb8b;">V</span><span style="color:#eff1f5;">&gt; {
</span><span style="color:#eff1f5;">    </span><span style="color:#ebcb8b;">Entry</span><span style="color:#eff1f5;">&lt;</span><span style="color:#ebcb8b;">K</span><span style="color:#eff1f5;">,</span><span style="color:#ebcb8b;">V</span><span style="color:#eff1f5;">&gt; before, after;
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Entry</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">hash</span><span style="color:#eff1f5;">, </span><span style="color:#ebcb8b;">K </span><span style="color:#bf616a;">key</span><span style="color:#eff1f5;">, </span><span style="color:#ebcb8b;">V </span><span style="color:#bf616a;">value</span><span style="color:#eff1f5;">, </span><span style="color:#ebcb8b;">Node</span><span style="color:#eff1f5;">&lt;</span><span style="color:#ebcb8b;">K</span><span style="color:#eff1f5;">,</span><span style="color:#ebcb8b;">V</span><span style="color:#eff1f5;">&gt; </span><span style="color:#bf616a;">next</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">super</span><span style="color:#eff1f5;">(hash, key, value, next);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span></code></pre>
<p>从上述的源码中不仅说明<code>Entry</code>是<code>LinkedHashMap</code>的内部类，也说明<code>LinkedHashMap$Entry[]</code>继承了<code>HashMap$Node[]</code>。</p>
<p>其中有两个<code>Entry&lt;K,V&gt;</code>类型的属性：<code>before</code>和<code>after</code>，可以理解为两个引用，主要用来完成各节点之间的连接。</p>
<p>同样，我们也可以通过查看<code>HashMap</code>的源码，验证上面的说法：<code>Node</code>同样作为其一个静态的内部类实现。并且该类还实现了其父接口<code>Map</code>中的<code>Entry&lt;K,V&gt;</code>。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">static class </span><span style="color:#ebcb8b;">Node</span><span style="color:#eff1f5;">&lt;</span><span style="color:#bf616a;">K</span><span style="color:#eff1f5;">,</span><span style="color:#bf616a;">V</span><span style="color:#eff1f5;">&gt; </span><span style="color:#b48ead;">implements </span><span style="color:#a3be8c;">Map</span><span style="color:#eff1f5;">.</span><span style="color:#a3be8c;">Entry</span><span style="color:#eff1f5;">&lt;</span><span style="color:#ebcb8b;">K</span><span style="color:#eff1f5;">,</span><span style="color:#ebcb8b;">V</span><span style="color:#eff1f5;">&gt; {
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">final int </span><span style="color:#eff1f5;">hash;
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">final </span><span style="color:#ebcb8b;">K </span><span style="color:#eff1f5;">key;
</span><span style="color:#eff1f5;">    </span><span style="color:#ebcb8b;">V </span><span style="color:#eff1f5;">value;
</span><span style="color:#eff1f5;">    </span><span style="color:#ebcb8b;">Node</span><span style="color:#eff1f5;">&lt;</span><span style="color:#ebcb8b;">K</span><span style="color:#eff1f5;">,</span><span style="color:#ebcb8b;">V</span><span style="color:#eff1f5;">&gt; next;
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Node</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">hash</span><span style="color:#eff1f5;">, </span><span style="color:#ebcb8b;">K </span><span style="color:#bf616a;">key</span><span style="color:#eff1f5;">, </span><span style="color:#ebcb8b;">V </span><span style="color:#bf616a;">value</span><span style="color:#eff1f5;">, </span><span style="color:#ebcb8b;">Node</span><span style="color:#eff1f5;">&lt;</span><span style="color:#ebcb8b;">K</span><span style="color:#eff1f5;">,</span><span style="color:#ebcb8b;">V</span><span style="color:#eff1f5;">&gt; </span><span style="color:#bf616a;">next</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">this</span><span style="color:#eff1f5;">.hash </span><span>=</span><span style="color:#eff1f5;"> hash;
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">this</span><span style="color:#eff1f5;">.key </span><span>=</span><span style="color:#eff1f5;"> key;
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">this</span><span style="color:#eff1f5;">.value </span><span>=</span><span style="color:#eff1f5;"> value;
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">this</span><span style="color:#eff1f5;">.next </span><span>=</span><span style="color:#eff1f5;"> next;
</span><span style="color:#eff1f5;">    }
</span></code></pre>
<p><img src="https://images.waer.ltd/img/20220426092722.png" alt="" loading="lazy" decoding="async" /></p>
<p>在存储元素时，每一个元素中依然是使用的<code>key</code>来存储，而<code>value</code>只是一个<code>object</code>类型的占位符，这里没有实际的意义。因为在<code>LinkedHashSet</code>中，我们<strong>不需要显式的去像Map中存一个<code>K,V</code>形式的值。</strong></p>
<ul>
<li>当我们添加一个重复元素时，<code>LinkedHashSet</code>会直接调用父类<code>HashSet</code>中的比较方法，对重复元素进行一个判断并去重，其实这里的原理和之前讲的<code>HashSet</code>原理是一样的，当添加元素是，<code>LinkedHashSet</code>还是会直接调用父类<code>HashSet</code>中的<code>add()</code>方法(该方法本质还是调用<code>HashMap</code>中的<code>put()</code>方法)，接着是<code>putVal()</code>关于这两个方法的源码在前面讲<code>HashSet</code>源码的时候就已经讲过，这里不再赘述。所以说，经管是不同的结构实现，但在元素判重的原理上其实使用的还是同一个逻辑。</li>
</ul>
<p><strong>说白了，LinkedHashSet本质上大部分还是HashMap</strong></p>
<ul>
<li>
<p><code>LinkedHashset</code>底层维护了一个<code>LinkedHashMap</code>结构，这一点可以类比于<code>HashSet</code>底层维护一个<code>HashMap</code>来进行对比记忆。而前面我们已经知道，<code>LinkedHashMap</code>其实就是<code>HashMap</code>的一个子类。</p>
</li>
<li>
<p>对于<code>LinkedHashSet</code>我们在理解了前面<code>HashSet</code>源码的基础上，只需要理解它底层的一个实现结构即可，也就是数组+双向链表的结构，回到一开始的哪个示例中，我们向set集合中添加了：</p>
</li>
</ul>
<blockquote>
<p>“A”，120, User,123</p>
</blockquote>
<p>之后，通过断点的方式可以看到他们之间的一个指向关系如下</p>
<p><img src="https://images.waer.ltd/img/20220426100922.png" alt="" loading="lazy" decoding="async" /></p>
<blockquote>
<p>上图展示了内部元素节点中<code>after</code>和<code>before</code>的引用关系。仔细观察每一个<code>LinkedHashMap$Entry</code>后都会跟一个<code>@number</code>的标识，**这是用来标识该位置元素的一个唯一标记，或者你也可以理解为该元素在该结构中的一个地址。**因此，我们可以用该标识来唯一性的代表一元素值，注意其中每一各<code>after</code>或者<code>before</code>的指向关系，具体在后面我回画个图帮助理解。</p>
</blockquote>
<ul>
<li>再跳出元素内部<code>Entry</code>，我们看到在<code>table</code>中有两个名为<code>head</code>和<code>tail</code>的引用属性。用来标识该双向链表的头尾节点。</li>
</ul>
<p><img src="https://images.waer.ltd/img/20220426101903.png" alt="" loading="lazy" decoding="async" /></p>
<p>将上面的逻辑以图片的形式展示出来大概就是下面这样：</p>
<p><img src="https://images.waer.ltd/img/LinkedHashSet.jpg" alt="" loading="lazy" decoding="async" /></p>
<p>简单捋一下：</p>
<blockquote>
<ul>
<li>每向<code>LinkedHashSet</code>中添加一个元素，首先会根据该元素计算一个<code>hash</code>值，用来确定它在上面图中<code>table</code>数组中的索引位置。</li>
<li>通过上面的步骤添加多个元素之后，元素内部是一个<code>Entry[]</code>类型的结构，其中每一个元素都有一个<code>after</code>和<code>before</code>属性，用<strong>来指向它的前一个元素和后一个元素的位置。</strong></li>
<li>再通过两个属性<code>head</code>和<code>tail</code>来指向整个链表的头和尾，从而构成一个<strong>完整的含有头尾指针(引用)的双向链表。</strong></li>
<li>将该链表具象化出来可以大致表示为图中右边部分。换句话说，这里的<code>after</code>和<code>before</code>其实就相当于平时常用的<code>pre</code>和<code>next</code>指针，即前驱后继指针，只不过命名不同而已，没什么高深莫测的。</li>
<li>注意，和前面<code>HashSet</code>的数组+单链表的结构类似，每一个索引位都可以是一条完整的双向链表，就像图中索引为7的位置一样，而不是每个索引为只能有一个链表节点，这取决于元素计算出来的<code>hash</code>。</li>
<li>正是由于双向链表的特性，使得我们添加的元素顺序是相对有序的，<strong>也就是添加的顺序和打印出来的顺序是一样的。</strong></li>
</ul>
</blockquote>
<p><strong>关于扩容</strong></p>
<p>首先，<code>LinkedHashSet</code>如果使用无参数构造器初始化，那么它默认会开辟一个<code>16</code>大小的空间，负载因子依旧是<code>0.74</code>，首次扩容的阈值为<code>12</code>。这些数值是不是很眼熟？如果你看了前面<code>HashSet</code>的源码分析的话。</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">public </span><span style="color:#bf616a;">LinkedHashSet</span><span>() {
</span><span>    </span><span style="color:#bf616a;">super</span><span>(</span><span style="color:#d08770;">16</span><span>, </span><span style="color:#d08770;">.75</span><span style="color:#b48ead;">f</span><span>, </span><span style="color:#d08770;">true</span><span>);
</span><span>}
</span></code></pre>
<p>虽然讲的是<code>LinkdeHashSet</code>，但本质上分析的还是<code>HashSet</code>，再本质就是<code>LinkedHashMap</code>，再继续套娃你会发现，<strong>就是讲的<code>HashMap</code>，可见这家伙才是主角。</strong></p>
<hr />
<p>未完待续……</p>

        </div>
      </div>
      <div class="prompt" id="terminal"><input
    type="text"
    id="setter"
    onkeydown="writeit(this, event);moveIt(this.value.length, event)"
    onchange="writeit(this, event)"
    onkeyup="writeit(this, event)"
    onkeypress="writeit(this, event);"
    >
<label for="setter" id="writer"> </label><b class="cursor" id="cursor"></b></div>
      <footer class="footer">
        <div class="footer-content">
          <p class="icp-info">
            <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer">黔ICP备2021010295号</a>
          </p>
        </div>
      </footer>
    </main>
  </body>

</html>
