<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>慕予博客</title>
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"
    integrity="sha256-WCzAhd2P6gRJF9Hv3oOOd+hFJi/QJbv+Azn4CGB8gfY=" crossorigin="anonymous" defer></script>
  <script src="/js/index.js" defer></script>
  <script src="/js/prompt.js" defer></script>
  <script src="/js/keyboard.js" defer></script>
  <script src="/js/tab.js" defer></script>
  <script src="/js/commands.js" defer></script>
  <script src="/js/config.js" defer></script><script src="/config.js"></script><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="style.css"><link rel="stylesheet" href="/css/page.css"></head><body onkeydown="exec(event)" style="background-image: url(&quot;&#x2F;assets&#x2F;bg.jpg&quot;); "><main>
      <div class="files" id="files" tabindex="0">
<ul>

  <li class="file">
    <span><a href='https://ilikexff.cn/8-kuan-rang-ni-kai-fa-qi-fei-de-intellijidea-cha-jian/'
      tabindex="-2">  8款让你开发起飞的IntellijIDEA插件</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/aop-jie-mi-qie-mian-bian-cheng-de-zong-he-zhi-nan/'
      tabindex="-3">  AOP揭秘：切面编程的综合指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-mei-ju-pian-yi-wu-fan-wei-mei-ju/'
      tabindex="-4">  C++游戏开发基础-枚举篇一：无范围枚举</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-std-optional/'
      tabindex="-5">  C++游戏开发基础-深入解析std::optional</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shen-ru-jie-xi-thiszhi-zhen-de-ying-yong-yu-ji-qiao/'
      tabindex="-6">  C++游戏开发基础-深入解析this指针的应用与技巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-fu-zhi-gou-zao-han-shu/'
      tabindex="-7">  C++游戏开发基础-深入解析复制构造函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-mo-ban-he-can-shu-tui-dao-zhi-nan/'
      tabindex="-8">  C++游戏开发基础-类模版和参数推导指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/dockerbi-zhi-bi-hui/'
      tabindex="-9">  Docker必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/githithub-xiao-ce/'
      tabindex="-10">  GitGitHub小册</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/google-hacking/'
      tabindex="-11">  Google Hacking</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/googleguan-fang-ti-shi-gong-cheng-bai-pi-shu-zhong-wen-yi-ben/'
      tabindex="-12">  Google官方《提示工程白皮书（中文译本）》</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-dai-ma-bu-quan-ti-shi-gong-neng-xiao-shi-de-ji-chong-jie-jue-fang-an-re-geng-ban/'
      tabindex="-13">  IDEA代码补全&amp;提示功能消失的几种解决方案(热更版)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-chen-jin-shi-bian-cheng-ti-yan/'
      tabindex="-14">  IDEA沉浸式编程体验</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-han-shu-shi-bian-cheng/'
      tabindex="-15">  Java函数式编程</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-ji-he-yuan-ma-qian-xi/'
      tabindex="-16">  Java集合源码浅析</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mysql-shi-wu-te-xing-yu-ge-chi-ji-bie-xiang-jie/'
      tabindex="-17">  MySQL_事务特性与隔离级别详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ocao-zuo-fu-shi-xian-mei-ju-de-shu-ru-shu-chu/'
      tabindex="-18">  O操作符,实现枚举的输入输出</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/prdsuan-fa-ting-shuo-ni-xiang-ping-yun-qi-chou-yi-ke-rong-yao-shui-jing/'
      tabindex="-19">  PRD算法：听说你想凭运气抽一颗荣耀水晶?</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/picgo-pei-zhi-ge-chong-tu-chuang/'
      tabindex="-20">  PicGo配置各种图床</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/redis-bi-zhi-bi-hui/'
      tabindex="-21">  Redis必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-zhong-de-move-yu-yi-sui-bi/'
      tabindex="-22">  Rust中的move语义随笔</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ssm-kuang-jia-shi-xian-ji-cheng-duan-xin-yan-zheng-ma-gong-neng/'
      tabindex="-23">  SSM框架实现集成短信验证码功能</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/slf4jyu-logbackshi-yong-zhi-nan-ji-yu-gradle/'
      tabindex="-24">  Slf4j与Logback实用指南(基于Gradle)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/spring-security5-xdao-spring-security6-xde-qian-yi/'
      tabindex="-25">  Spring Security5.x到Spring Security6.x的迁移</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springboot-webkai-fa-jing-jie/'
      tabindex="-26">  SpringBoot Web开发精解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springsecurity/'
      tabindex="-27">  SpringSecurity</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/unity6xia-jia-zhong-guo-qu-tuan-jie-yin-qing-jie-bang-zhe-shi-fen-lie-huan-shi-ben-di-hua-de-kai-shi/'
      tabindex="-28">  Unity6下架中国区，团结引擎接棒：这是分裂，还是本地化的开始？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-cong-0-dao-1-da-zao-quan-yu-yan-zhi-chi-de-mo-neng-bian-ji-qi-yu-fa-pian/'
      tabindex="-29">  Vim从0到1打造全语言支持的万能编辑器-语法篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-tiao-tou-powershell-pian/'
      tabindex="-30">  Vim折腾之 PowerShell篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-di-zhi-chuan-di-xiang-jie/'
      tabindex="-31">  [C++游戏开发基础]:地址传递详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-yin-yong-fan-hui-he-di-zhi-fan-hui/'
      tabindex="-32">  [C++游戏开发基础]:引用返回和地址返回</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-he-const/'
      tabindex="-33">  [C++游戏开发基础]:指针和const</a></span>
  </li><li class="file">
    <span><a class="selected"href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shu-ju-feng-zhuang-yin-cang-de-hao-chu/'
      tabindex="-34">  [C++游戏开发基础]:数据封装(隐藏)的好处</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-gou-zao-han-shu-qian-xi-8000zi/'
      tabindex="-35">  [C++游戏开发基础]:构造函数浅析(8000字)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-li-jie-kong-zhi-zhen/'
      tabindex="-36">  [C++游戏开发基础]:理解空指针</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-zhong-de-fang-wen-han-shu/'
      tabindex="-37">  [C++游戏开发基础]:类中的访问函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-de-ji-ben-gai-nian-li-jie/'
      tabindex="-38">  [C++游戏开发基础]指针的基本概念理解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/fanatical-wu-yue-feng-kuang-te-hui-wei-ni-de-steam-ku-jia-dian-liao/'
      tabindex="-39">  _Fanatical 五月疯狂特惠：为你的 Steam 库加点料！</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-kai-yuan-mi-ma-gong-ju-xpwd-zhong-wen-ban-bian-geng-ri-zhi/'
      tabindex="-40">  _Rust开源密码工具xpwd中文版变更日志</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/readme/'
      tabindex="-41">  readme</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wblog-bo-ke-xian-shang-bu-shu/'
      tabindex="-42">  wblog博客线上部署</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/shang-gu-shen-qi-vim-su-cheng-bei-wang-lu/'
      tabindex="-43">  上古神器_Vim速成备忘录</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mian-fei-ji-huo-quan-ban-ben-typora-zui-xin-ban-wei-li/'
      tabindex="-44">  免费激活全版本Typora，最新版为例</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-lombokxian-wei-ren-zhi-de-ji-ge-qi-ji-yin-qiao/'
      tabindex="-45">  关于Lombok鲜为人知的几个奇技淫巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-jie-kou-xian-liu-de-yi-ci-jian-dan-shi-jian/'
      tabindex="-46">  关于接口限流的一次简单实践</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/tu-jie-er-jin-zhi/'
      tabindex="-47">  图解二进制</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ru-he-xie-de-yi-shou-you-ya-gui-fan-de-springboot-jie-kou/'
      tabindex="-48">  如何写得一手优雅规范的SpringBoot 接口？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/kai-fa-bi-hui-xi-lie-jwtqian-tan/'
      tabindex="-49">  开发必会系列_JWT浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ji-qiao-jiu-shi-xiao-lu-chatgpt-diao-jiao-zhi-bei/'
      tabindex="-50">  技巧就是效率，ChatGPT调教指北</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-sheng-intellij-kai-fa-xiao-lu-zhe-kuan-dai-ma-tu-ding-cha-jian-codepins-zhi-de-yi-shi/'
      tabindex="-51">  提升 IntelliJ 开发效率？这款代码图钉插件 CodePins 值得一试</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-wen-de-zhi-hui-zhuan-zai/'
      tabindex="-52">  提问的智慧转载</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiao-lu-gong-ju-markdown/'
      tabindex="-53">  效率工具Markdown</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wu-wei-bing-fa-rust-sheng-ming-zhou-qi-qian-tan/'
      tabindex="-54">  无畏并发_Rust 生命周期浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-yu-de-bei-sai-er-qu-xian-gan-shou-si-hua-de-shu-xue-zhi-mei/'
      tabindex="-55">  游戏开发与的贝塞尔曲线_感受丝滑的数学之美</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-bi-bei-gao-xiao-de-aabb-qiu-ti-he-obb-peng-zhuang-jian-ce-suan-fa/'
      tabindex="-56">  游戏开发必备：高效的 AABB、球体和 OBB 碰撞检测算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-suan-fa-ji-chu-a-xun-lu-suan-fa-chi-xu-wei-hu/'
      tabindex="-57">  游戏算法基础-深入解析A*寻路算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/du-li-you-xi-kai-fa-zhe-gong-ju-xiang-2025jing-xuan-tui-jian-yu-shi-yong-zhi-nan/'
      tabindex="-58">  独立游戏开发者工具箱：2025精选推荐与实用指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xu-huan-yin-qing-you-xi-kai-fa-xi-lie-zhuan-ti-guan-fang-bian-ma-biao-zhun-huo-gui-yue/'
      tabindex="-59">  虚幻引擎游戏开发系列专题-官方编码标准或规约</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiang-jie-she-ji-mo-shi-dan-li-de-jin-hua-zhi-lu/'
      tabindex="-60">  详解设计模式_单例的进化之路</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xie-e-de-fei-chang-liang-quan-ju-bian-liang/'
      tabindex="-61">  邪恶的非常量全局变量</a></span>
  </li>
</ul>
</div>
      <div class="viewer page" id="viewer" tabindex="0">
        <div class="tab">
<div class="file-manager" onclick='document.getElementById("files").classList.toggle("open"); document.getElementById("content").classList.toggle("close")'> </div>
<ul id="tabs">
</ul>


</div>
        <div class="content" id="content"><ul>
<li>
<p>在现代生活中，我们有许多机械或电子设备。你通过遥控器开关电视。你通过踩油门使汽车前进。你通过开关来打开灯。</p>
</li>
<li>
<p>实际上这些设备是如何运作的对你来说是隐藏起来的。当你按下遥控器上的按钮时，你不需要知道遥控器是如何与电视进行通信的。</p>
</li>
<li>
<p>当你踩下汽车的油门时，你不需要知道内燃机是如何让车轮转动的。当你拍照时，你不需要知道传感器是如何收集光线并将光线转换成像素图像的。</p>
</li>
<li>
<p>这种接口和实现的分离非常有用，因为它允许我们在不需要理解它们如何工作的情况下使用对象——我们只需要了解如何与它们交互。这大大减少了使用这些对象的复杂性，并增加了我们可以交互的对象数量。</p>
</li>
</ul>
<hr />
<h2 id="lei-de-jie-kou-yu-shi-xian-de-fen-chi">类的接口与实现的分离</h2>
<p>在编程中，接口（interface）和实现（implementation）的分离是非常有用的概念。让我们先明确在类（class）类型中，这两个术语的含义。</p>
<p><strong>什么是接口</strong></p>
<p>类的接口（也称为<strong>类接口</strong>）定义了类的用户如何与该类的对象进行交互。由于<strong>只有公有成员（public members）</strong> 可以被类外部访问，因此，<strong>类的公有成员构成了该类的接口</strong>。由于接口由公有成员组成，因此它有时也被称为<strong>公有接口（public interface）</strong>。</p>
<p>接口是<strong>类的作者</strong>和<strong>类的使用者</strong>之间的一种<strong>隐式契约（implicit contract）</strong>。</p>
<ul>
<li><strong>一旦类的接口被使用，就不能轻易修改</strong>，因为任何对接口的更改都可能导致依赖它的代码发生错误。</li>
<li>因此，我们应该<strong>确保类的接口设计良好且稳定</strong>，尽量减少不必要的更改。</li>
</ul>
<p><strong>什么是实现</strong></p>
<p>类的<strong>实现</strong>指的是<strong>使类按照预期行为运行的代码</strong>，它包括：</p>
<ul>
<li><strong>成员变量（member variables）：</strong> 用于存储数据。</li>
<li><strong>成员函数的具体实现（bodies of member functions）：</strong> 包含程序逻辑并操作成员变量。</li>
</ul>
<p>换句话说，<strong>实现是支撑类功能的幕后代码</strong>，它决定了类的行为方式，而接口只是提供了与外部交互的方式。</p>
<hr />
<h2 id="shu-ju-feng-zhuang-shi-lei-geng-rong-yi-shi-yong-bing-jiang-di-liao-fu-za-xing">数据封装使类更容易使用并降低了复杂性</h2>
<p>使用封装类时，你不需要知道它的实现细节。你只需要理解它的接口：哪些成员函数是公开的，它们接受什么参数，以及返回什么值。</p>
<p>比如:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string_view</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    std::string_view </span><span style="color:#bf616a;">sv</span><span>{ &quot;</span><span style="color:#a3be8c;">Hello, world!</span><span>&quot; };
</span><span>    std::cout &lt;&lt; sv.</span><span style="color:#bf616a;">length</span><span>();
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>在这个简短的程序中，我们看不到 <code>std::string_view</code> 的实现细节。我们不知道 <code>std::string_view</code> 有多少个数据成员、它们的名字或类型是什么。我们也不知道 <code>length()</code> 成员函数是如何返回所查看字符串的长度的。</p>
<p>不必关心这些细节极大地降低了程序的复杂性，从而减少了错误。这是封装的关键优势，比其他任何原因都更为重要。</p>
<p>不妨想象一下:如果要使用 <code>std::string</code> 、 <code>std::vector</code> 或 <code>std::cout</code> ，就必须理解它们的实现细节，C++ 会变得多么复杂！</p>
<hr />
<h2 id="shu-ju-feng-zhuang-neng-geng-hao-de-wei-hu-bu-bian-liang">数据封装能更好的维护不变量</h2>
<p>所谓不变量,即为了使对象在整个生命周期内保持有效状态而必须满足的条件。</p>
<p>考虑下面程序:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">struct </span><span>Employee </span><span style="color:#65737e;">// 结构体的成员默认是 public（公有的）
</span><span>{
</span><span>    std::string </span><span style="color:#bf616a;">name</span><span>{ &quot;</span><span style="color:#a3be8c;">John</span><span>&quot; }; </span><span style="color:#65737e;">// 员工姓名，默认值为 &quot;John&quot;
</span><span>    </span><span style="color:#b48ead;">char </span><span style="color:#bf616a;">firstInitial</span><span>{ &#39;</span><span style="color:#a3be8c;">J</span><span>&#39; };   </span><span style="color:#65737e;">// 员工的首字母，默认值为 &#39;J&#39;（应与 name 的首字母匹配）
</span><span>
</span><span>    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span>() </span><span style="color:#b48ead;">const </span><span style="color:#65737e;">// 输出员工信息
</span><span>    {
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Employee </span><span>&quot; &lt;&lt; name &lt;&lt; &quot;</span><span style="color:#a3be8c;"> has first initial </span><span>&quot; &lt;&lt; firstInitial &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>    }
</span><span>};
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Employee </span><span style="color:#bf616a;">e</span><span>{}; </span><span style="color:#65737e;">// 使用默认值初始化 Employee（name=&quot;John&quot;, firstInitial=&#39;J&#39;）
</span><span>    e.</span><span style="color:#bf616a;">print</span><span>(); </span><span style="color:#65737e;">// 输出：&quot;Employee John has first initial J&quot;
</span><span>
</span><span>    e.</span><span style="color:#bf616a;">name </span><span>= &quot;</span><span style="color:#a3be8c;">Mark</span><span>&quot;; </span><span style="color:#65737e;">// 修改员工的姓名为 &quot;Mark&quot;
</span><span>    e.</span><span style="color:#bf616a;">print</span><span>(); </span><span style="color:#65737e;">// 由于 firstInitial 没有同步更新，此时仍然是 &#39;J&#39;，导致输出的首字母错误
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>因为 <code>name</code> 成员是公共的， <code>main()</code> 中的代码能够将 <code>e.name</code> 设置为 <code>"Mark"</code> ，而 <code>firstInitial</code> 成员没有被更新。我们的不变式被破坏了，所以对 <code>print()</code> 的第二次调用没有按预期工作。</p>
<p>如果我们直接给用户提供类的实现访问权限，他们就需要负责维护所有不变量,这显然不太现实。</p>
<p>让我们重写这个程序，将我们的成员变量设为私有，并暴露一个成员函数来设置 Employee 的名字：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string_view</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Employee 
</span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    std::string </span><span style="color:#bf616a;">m_name</span><span style="color:#eff1f5;">{};
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">char </span><span style="color:#bf616a;">m_firstInitial</span><span style="color:#eff1f5;">{};
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">setName</span><span style="color:#eff1f5;">(std::string_view </span><span style="color:#bf616a;">name</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">m_name </span><span>=</span><span style="color:#eff1f5;"> name;
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">m_firstInitial </span><span>=</span><span style="color:#eff1f5;"> name.</span><span style="color:#bf616a;">front</span><span style="color:#eff1f5;">(); </span><span style="color:#65737e;">// use std::string::front() to get first letter of `name`
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Employee </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_name </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;"> has first initial </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_firstInitial </span><span>&lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Employee </span><span style="color:#bf616a;">e</span><span>{};
</span><span>    e.</span><span style="color:#bf616a;">setName</span><span>(&quot;</span><span style="color:#a3be8c;">John</span><span>&quot;);
</span><span>    e.</span><span style="color:#bf616a;">print</span><span>();
</span><span>
</span><span>    e.</span><span style="color:#bf616a;">setName</span><span>(&quot;</span><span style="color:#a3be8c;">Mark</span><span>&quot;);
</span><span>    e.</span><span style="color:#bf616a;">print</span><span>();
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>上面的程序的变更,从用户的角度来看，唯一的变化是他们不再直接给 <code>name</code> 分配一个值，而是调用成员函数 <code>setName()</code> ，该函数负责同时设置 <code>m_name</code> 和 <code>m_firstInitial</code> 。用户不再需要维护这个不变量！</p>
<hr />
<h2 id="shu-ju-feng-zhuang-ke-yi-geng-hao-de-jin-xing-cuo-wu-jian-ce-he-chu-li">数据封装可以更好的进行错误检测和处理</h2>
<p>在上述程序中， <code>m_firstInitial</code> 必须与 <code>m_name</code> 的第一个字符匹配这一不变量存在是因为 <code>m_firstInitial</code> 独立于 <code>m_name</code> 存在。我们可以通过将数据成员 <code>m_firstInitial</code> 替换为一个返回第一个字符的成员函数来移除这个特定的不变量。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Employee
</span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    std::string </span><span style="color:#bf616a;">m_name</span><span style="color:#eff1f5;">{ </span><span>&quot;</span><span style="color:#a3be8c;">John</span><span>&quot; </span><span style="color:#eff1f5;">};
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">setName</span><span style="color:#eff1f5;">(std::string_view </span><span style="color:#bf616a;">name</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">m_name </span><span>=</span><span style="color:#eff1f5;"> name;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// use std::string::front() to get first letter of `m_name`
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">char </span><span style="color:#8fa1b3;">firstInitial</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#eff1f5;">{ </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_name</span><span style="color:#eff1f5;">.</span><span style="color:#bf616a;">front</span><span style="color:#eff1f5;">(); }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Employee </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_name </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;"> has first initial </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">firstInitial</span><span style="color:#eff1f5;">() </span><span>&lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Employee </span><span style="color:#bf616a;">e</span><span>{}; </span><span style="color:#65737e;">// defaults to &quot;John&quot;
</span><span>    e.</span><span style="color:#bf616a;">setName</span><span>(&quot;</span><span style="color:#a3be8c;">Mark</span><span>&quot;);
</span><span>    e.</span><span style="color:#bf616a;">print</span><span>();
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>对于上面的程序,还存在一个问题,<code>m_name</code> 不应该是一个空字符串（因为每个 <code>Employee</code> 都应该有一个名称）。如果 <code>m_name</code> 被设置为空字符串，立即不会发生任何糟糕的事情。但如果随后调用了 <code>firstInitial()</code> ， <code>front()</code> 成员将会尝试获取空字符串的第一个字母，这会导致未定义行为。</p>
<p>如果用户对 <code>m_name</code> 成员有公共访问权限，他们可以直接设置 <code>m_name = ""</code> ，而我们无法阻止这种情况发生。</p>
<p>然而，因为我们要求用户通过公共接口函数 <code>setName()</code> 设置 <code>m_name</code> ，我们可以在 <code>setName()</code> 中验证用户传递的是一个有效的名称。如果名称非空，我们可以将其赋值给 <code>m_name</code> 。如果名称是空字符串，我们可以采取任何数量的措施进行响应：</p>
<ul>
<li>忽略将名称设置为“”的请求，并返回给调用者。</li>
<li>错误断言</li>
<li>抛出异常</li>
<li>其他</li>
</ul>
<hr />
<h2 id="yi-dian-jian-yi-you-xian-shi-yong-fei-cheng-yuan-han-shu-er-bu-shi-cheng-yuan-han-shu">一点建议:优先使用非成员函数而不是成员函数</h2>
<p>在C++中,如果一个函数可以合理的作为非成员函数实现,应该优先将其实现为非成员函数,而不是成员函数。 这样做是有原因的:</p>
<ul>
<li>非成员函数不是你类接口的一部分,因此,类接口将会变得更小更简洁,使类更容易理解和维护。</li>
<li>非成员函数能够强化封装性，因为它们必须通过类的公共接口来工作。这样就不会因为方便而直接访问类的内部实现。</li>
<li>非成员函数通常更容易调试;</li>
<li>非成员函数可以帮助将应用特定的逻辑从类中分离出来，从而提高类的通用性和可复用性。</li>
</ul>
<p>如果你之前有现代面向对象编程（OOP）语言的经验（比如 Java 或 C#），这种做法可能会让你感到意外。这些语言采用了不同的概念模型，在它们的设计中，<strong>类是核心</strong>，所有东西都围绕类展开。</p>
<p>因此，这些语言强调成员函数（member functions），并且实际上 <strong>Java 和 C# 甚至不支持非成员函数（non-member functions）</strong>。</p>
<p>这里针对上面最后一条举个例子:</p>
<p><strong>反向示例:</strong></p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">cmath</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Vector3D
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">double </span><span style="color:#bf616a;">m_x</span><span style="color:#eff1f5;">, </span><span style="color:#bf616a;">m_y</span><span style="color:#eff1f5;">, </span><span style="color:#bf616a;">m_z</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Vector3D</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">double </span><span style="color:#bf616a;">x</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">double </span><span style="color:#bf616a;">y</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">double </span><span style="color:#bf616a;">z</span><span style="color:#eff1f5;">) : </span><span style="color:#bf616a;">m_x</span><span style="color:#eff1f5;">(x), </span><span style="color:#bf616a;">m_y</span><span style="color:#eff1f5;">(y), </span><span style="color:#bf616a;">m_z</span><span style="color:#eff1f5;">(z) {}
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">double </span><span style="color:#8fa1b3;">length</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#65737e;">// 计算向量长度
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return </span><span style="color:#eff1f5;">std::</span><span style="color:#96b5b4;">sqrt</span><span style="color:#eff1f5;">(</span><span style="color:#bf616a;">m_x </span><span>* </span><span style="color:#bf616a;">m_x </span><span>+ </span><span style="color:#bf616a;">m_y </span><span>* </span><span style="color:#bf616a;">m_y </span><span>+ </span><span style="color:#bf616a;">m_z </span><span>* </span><span style="color:#bf616a;">m_z</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// 这个方法把游戏特定的逻辑放进了 Vector3D 中
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">applyGravity</span><span style="color:#eff1f5;">()
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">m_y </span><span>-= </span><span style="color:#d08770;">9.81</span><span style="color:#eff1f5;">; </span><span style="color:#65737e;">// 物理重力，属于游戏逻辑
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Vector(</span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_x </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">, </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_y </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">, </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_z </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">)</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Vector3D </span><span style="color:#bf616a;">velocity</span><span>(</span><span style="color:#d08770;">10</span><span>, </span><span style="color:#d08770;">20</span><span>, </span><span style="color:#d08770;">30</span><span>);
</span><span>    velocity.</span><span style="color:#bf616a;">applyGravity</span><span>(); </span><span style="color:#65737e;">// 调用物理引擎逻辑
</span><span>    velocity.</span><span style="color:#bf616a;">print</span><span>(); </span><span style="color:#65737e;">// Vector(10, 10.19, 30) (不符合通用设计)
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<ul>
<li>applyGravity() 是<strong>游戏特定</strong>的逻辑，而 Vector3D 本身应该是一个通用的数学类。</li>
<li>如果未来需要在物理模拟、3D 渲染等不同场景使用 Vector3D，这个方法可能就不适用了。</li>
<li>这导致 Vector3D 变得<strong>不够通用，难以复用</strong>。</li>
</ul>
<p><strong>使用非成员函数分离应用逻辑以改进</strong></p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">cmath</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Vector3D
</span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">private</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">double </span><span style="color:#bf616a;">m_x</span><span style="color:#eff1f5;">, </span><span style="color:#bf616a;">m_y</span><span style="color:#eff1f5;">, </span><span style="color:#bf616a;">m_z</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">Vector3D</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">double </span><span style="color:#bf616a;">x</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">double </span><span style="color:#bf616a;">y</span><span style="color:#eff1f5;">, </span><span style="color:#b48ead;">double </span><span style="color:#bf616a;">z</span><span style="color:#eff1f5;">) : </span><span style="color:#bf616a;">m_x</span><span style="color:#eff1f5;">(x), </span><span style="color:#bf616a;">m_y</span><span style="color:#eff1f5;">(y), </span><span style="color:#bf616a;">m_z</span><span style="color:#eff1f5;">(z) {}
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">double </span><span style="color:#8fa1b3;">length</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#65737e;">// 计算向量长度
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return </span><span style="color:#eff1f5;">std::</span><span style="color:#96b5b4;">sqrt</span><span style="color:#eff1f5;">(</span><span style="color:#bf616a;">m_x </span><span>* </span><span style="color:#bf616a;">m_x </span><span>+ </span><span style="color:#bf616a;">m_y </span><span>* </span><span style="color:#bf616a;">m_y </span><span>+ </span><span style="color:#bf616a;">m_z </span><span>* </span><span style="color:#bf616a;">m_z</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        std::cout </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">Vector(</span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_x </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">, </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_y </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">, </span><span>&quot; &lt;&lt; </span><span style="color:#bf616a;">m_z </span><span>&lt;&lt; &quot;</span><span style="color:#a3be8c;">)</span><span style="color:#96b5b4;">\n</span><span>&quot;</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// 提供访问和修改 y 分量的接口
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">double </span><span style="color:#8fa1b3;">getY</span><span style="color:#eff1f5;">() </span><span style="color:#b48ead;">const </span><span style="color:#eff1f5;">{ </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">m_y</span><span style="color:#eff1f5;">; }
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">setY</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">double </span><span style="color:#bf616a;">y</span><span style="color:#eff1f5;">) { </span><span style="color:#bf616a;">m_y </span><span>=</span><span style="color:#eff1f5;"> y; }
</span><span style="color:#eff1f5;">}</span><span>;
</span><span>
</span><span style="color:#65737e;">// 应用层的游戏逻辑：用非成员函数实现重力影响
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">applyGravity</span><span>(Vector3D&amp; </span><span style="color:#bf616a;">velocity</span><span>)
</span><span>{
</span><span>    velocity.</span><span style="color:#bf616a;">setY</span><span>(velocity.</span><span style="color:#bf616a;">getY</span><span>() - </span><span style="color:#d08770;">9.81</span><span>); </span><span style="color:#65737e;">// 物理引擎的重力影响
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    Vector3D </span><span style="color:#bf616a;">velocity</span><span>(</span><span style="color:#d08770;">10</span><span>, </span><span style="color:#d08770;">20</span><span>, </span><span style="color:#d08770;">30</span><span>);
</span><span>    </span><span style="color:#bf616a;">applyGravity</span><span>(velocity); </span><span style="color:#65737e;">// 现在 applyGravity() 只影响游戏逻辑
</span><span>    velocity.</span><span style="color:#bf616a;">print</span><span>(); </span><span style="color:#65737e;">// Vector(10, 10.19, 30)
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<hr />
<h2 id="guan-yu-lei-cheng-yuan-sheng-ming-shun-xu-de-tao-lun">关于类成员声明顺序的讨论</h2>
<p>在类外部编写代码时,我们必须在使用变量和函数之前声明它们,然而,在类内部,这种限制并不存在。</p>
<p>关于如何排序,下面有两种观点:</p>
<ul>
<li>首先列出你的私有成员，然后列出你的公有成员函数。这遵循了先声明后使用的传统风格。任何查看你类代码的人可以看到你在使用数据成员之前是如何定义它们的，这可以使阅读和理解实现细节变得更加容易。</li>
<li>首先列出你的公共成员，然后将私有成员放在底部。因为使用你类的人关心的是公共接口，所以把公共成员放在前面可以让他们需要的信息放在顶部，而把实现细节（这些细节是最不重要的）放在最后。</li>
</ul>
<p>在现代C++中,第二种方式更为推荐,尤其是在团队开发中。所以 <strong>最佳实践:</strong></p>
<blockquote>
<p>首先声明公共成员,接着声明受保护成员,最后声明私有成员。这样可以突出公共接口并弱化实现细节。</p>
</blockquote>
<p>在<code>Google C++</code>风格指南中对这部分有更加详细的阅读,可以自己看看[Google C++style guide](<a class="" href="https://google.github.io/styleguide/cppguide.html#Declaration_Order">Google C++ style guide</a>:)</p>

        </div>
      </div>
      <div class="prompt" id="terminal"><input
    type="text"
    id="setter"
    onkeydown="writeit(this, event);moveIt(this.value.length, event)"
    onchange="writeit(this, event)"
    onkeyup="writeit(this, event)"
    onkeypress="writeit(this, event);"
    >
<label for="setter" id="writer"> </label><b class="cursor" id="cursor"></b></div>
      <footer class="footer">
        <div class="footer-content">
          <p class="icp-info">
            <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer">黔ICP备2021010295号</a>
          </p>
        </div>
      </footer>
    </main>
  </body>

</html>
