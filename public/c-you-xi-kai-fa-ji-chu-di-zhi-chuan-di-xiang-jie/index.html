<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>慕予博客</title>
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"
    integrity="sha256-WCzAhd2P6gRJF9Hv3oOOd+hFJi/QJbv+Azn4CGB8gfY=" crossorigin="anonymous" defer></script>
  <script src="/js/index.js" defer></script>
  <script src="/js/prompt.js" defer></script>
  <script src="/js/keyboard.js" defer></script>
  <script src="/js/tab.js" defer></script>
  <script src="/js/commands.js" defer></script>
  <script src="/js/config.js" defer></script><script src="/config.js"></script><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="style.css"><link rel="stylesheet" href="/css/page.css"></head><body onkeydown="exec(event)" style="background-image: url(&#x27;&#x2F;assets&#x2F;bg.jpg&#x27;); "><main>
      <div class="files" id="files" tabindex="0">
<ul>

  <li class="file">
    <span><a href='https://ilikexff.cn/8-kuan-rang-ni-kai-fa-qi-fei-de-intellijidea-cha-jian/'
      tabindex="-2">  8款让你开发起飞的IntellijIDEA插件</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/aop-jie-mi-qie-mian-bian-cheng-de-zong-he-zhi-nan/'
      tabindex="-3">  AOP揭秘：切面编程的综合指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-mei-ju-pian-yi-wu-fan-wei-mei-ju/'
      tabindex="-4">  C++游戏开发基础-枚举篇一：无范围枚举</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-std-optional/'
      tabindex="-5">  C++游戏开发基础-深入解析std::optional</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shen-ru-jie-xi-thiszhi-zhen-de-ying-yong-yu-ji-qiao/'
      tabindex="-6">  C++游戏开发基础-深入解析this指针的应用与技巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-fu-zhi-gou-zao-han-shu/'
      tabindex="-7">  C++游戏开发基础-深入解析复制构造函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-mo-ban-he-can-shu-tui-dao-zhi-nan/'
      tabindex="-8">  C++游戏开发基础-类模版和参数推导指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/dockerbi-zhi-bi-hui/'
      tabindex="-9">  Docker必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/githithub-xiao-ce/'
      tabindex="-10">  GitGitHub小册</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/google-hacking/'
      tabindex="-11">  Google Hacking</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/googleguan-fang-ti-shi-gong-cheng-bai-pi-shu-zhong-wen-yi-ben/'
      tabindex="-12">  Google官方《提示工程白皮书（中文译本）》</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-dai-ma-bu-quan-ti-shi-gong-neng-xiao-shi-de-ji-chong-jie-jue-fang-an-re-geng-ban/'
      tabindex="-13">  IDEA代码补全&amp;提示功能消失的几种解决方案(热更版)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/idea-chen-jin-shi-bian-cheng-ti-yan/'
      tabindex="-14">  IDEA沉浸式编程体验</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-han-shu-shi-bian-cheng/'
      tabindex="-15">  Java函数式编程</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/java-ji-he-yuan-ma-qian-xi/'
      tabindex="-16">  Java集合源码浅析</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mysql-shi-wu-te-xing-yu-ge-chi-ji-bie-xiang-jie/'
      tabindex="-17">  MySQL_事务特性与隔离级别详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ocao-zuo-fu-shi-xian-mei-ju-de-shu-ru-shu-chu/'
      tabindex="-18">  O操作符,实现枚举的输入输出</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/prdsuan-fa-ting-shuo-ni-xiang-ping-yun-qi-chou-yi-ke-rong-yao-shui-jing/'
      tabindex="-19">  PRD算法：听说你想凭运气抽一颗荣耀水晶?</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/picgo-pei-zhi-ge-chong-tu-chuang/'
      tabindex="-20">  PicGo配置各种图床</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/redis-bi-zhi-bi-hui/'
      tabindex="-21">  Redis必知必会</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-zhong-de-move-yu-yi-sui-bi/'
      tabindex="-22">  Rust中的move语义随笔</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ssm-kuang-jia-shi-xian-ji-cheng-duan-xin-yan-zheng-ma-gong-neng/'
      tabindex="-23">  SSM框架实现集成短信验证码功能</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/slf4jyu-logbackshi-yong-zhi-nan-ji-yu-gradle/'
      tabindex="-24">  Slf4j与Logback实用指南(基于Gradle)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/spring-security5-xdao-spring-security6-xde-qian-yi/'
      tabindex="-25">  Spring Security5.x到Spring Security6.x的迁移</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springboot-webkai-fa-jing-jie/'
      tabindex="-26">  SpringBoot Web开发精解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/springsecurity/'
      tabindex="-27">  SpringSecurity</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/unity6xia-jia-zhong-guo-qu-tuan-jie-yin-qing-jie-bang-zhe-shi-fen-lie-huan-shi-ben-di-hua-de-kai-shi/'
      tabindex="-28">  Unity6下架中国区，团结引擎接棒：这是分裂，还是本地化的开始？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-cong-0-dao-1-da-zao-quan-yu-yan-zhi-chi-de-mo-neng-bian-ji-qi-yu-fa-pian/'
      tabindex="-29">  Vim从0到1打造全语言支持的万能编辑器-语法篇</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/vim-tiao-tou-powershell-pian/'
      tabindex="-30">  Vim折腾之 PowerShell篇</a></span>
  </li><li class="file">
    <span><a class="selected"href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-di-zhi-chuan-di-xiang-jie/'
      tabindex="-31">  [C++游戏开发基础]:地址传递详解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-yin-yong-fan-hui-he-di-zhi-fan-hui/'
      tabindex="-32">  [C++游戏开发基础]:引用返回和地址返回</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-he-const/'
      tabindex="-33">  [C++游戏开发基础]:指针和const</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-shu-ju-feng-zhuang-yin-cang-de-hao-chu/'
      tabindex="-34">  [C++游戏开发基础]:数据封装(隐藏)的好处</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-gou-zao-han-shu-qian-xi-8000zi/'
      tabindex="-35">  [C++游戏开发基础]:构造函数浅析(8000字)</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-li-jie-kong-zhi-zhen/'
      tabindex="-36">  [C++游戏开发基础]:理解空指针</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-lei-zhong-de-fang-wen-han-shu/'
      tabindex="-37">  [C++游戏开发基础]:类中的访问函数</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/c-you-xi-kai-fa-ji-chu-zhi-zhen-de-ji-ben-gai-nian-li-jie/'
      tabindex="-38">  [C++游戏开发基础]指针的基本概念理解</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/fanatical-wu-yue-feng-kuang-te-hui-wei-ni-de-steam-ku-jia-dian-liao/'
      tabindex="-39">  _Fanatical 五月疯狂特惠：为你的 Steam 库加点料！</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/rust-kai-yuan-mi-ma-gong-ju-xpwd-zhong-wen-ban-bian-geng-ri-zhi/'
      tabindex="-40">  _Rust开源密码工具xpwd中文版变更日志</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/readme/'
      tabindex="-41">  readme</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wblog-bo-ke-xian-shang-bu-shu/'
      tabindex="-42">  wblog博客线上部署</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/shang-gu-shen-qi-vim-su-cheng-bei-wang-lu/'
      tabindex="-43">  上古神器_Vim速成备忘录</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/mian-fei-ji-huo-quan-ban-ben-typora-zui-xin-ban-wei-li/'
      tabindex="-44">  免费激活全版本Typora，最新版为例</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-lombokxian-wei-ren-zhi-de-ji-ge-qi-ji-yin-qiao/'
      tabindex="-45">  关于Lombok鲜为人知的几个奇技淫巧</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/guan-yu-jie-kou-xian-liu-de-yi-ci-jian-dan-shi-jian/'
      tabindex="-46">  关于接口限流的一次简单实践</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/tu-jie-er-jin-zhi/'
      tabindex="-47">  图解二进制</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ru-he-xie-de-yi-shou-you-ya-gui-fan-de-springboot-jie-kou/'
      tabindex="-48">  如何写得一手优雅规范的SpringBoot 接口？</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/kai-fa-bi-hui-xi-lie-jwtqian-tan/'
      tabindex="-49">  开发必会系列_JWT浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ji-qiao-jiu-shi-xiao-lu-chatgpt-diao-jiao-zhi-bei/'
      tabindex="-50">  技巧就是效率，ChatGPT调教指北</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-sheng-intellij-kai-fa-xiao-lu-zhe-kuan-dai-ma-tu-ding-cha-jian-codepins-zhi-de-yi-shi/'
      tabindex="-51">  提升 IntelliJ 开发效率？这款代码图钉插件 CodePins 值得一试</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/ti-wen-de-zhi-hui-zhuan-zai/'
      tabindex="-52">  提问的智慧转载</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiao-lu-gong-ju-markdown/'
      tabindex="-53">  效率工具Markdown</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/wu-wei-bing-fa-rust-sheng-ming-zhou-qi-qian-tan/'
      tabindex="-54">  无畏并发_Rust 生命周期浅谈</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-yu-de-bei-sai-er-qu-xian-gan-shou-si-hua-de-shu-xue-zhi-mei/'
      tabindex="-55">  游戏开发与的贝塞尔曲线_感受丝滑的数学之美</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-kai-fa-bi-bei-gao-xiao-de-aabb-qiu-ti-he-obb-peng-zhuang-jian-ce-suan-fa/'
      tabindex="-56">  游戏开发必备：高效的 AABB、球体和 OBB 碰撞检测算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/you-xi-suan-fa-ji-chu-a-xun-lu-suan-fa-chi-xu-wei-hu/'
      tabindex="-57">  游戏算法基础-深入解析A*寻路算法</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/du-li-you-xi-kai-fa-zhe-gong-ju-xiang-2025jing-xuan-tui-jian-yu-shi-yong-zhi-nan/'
      tabindex="-58">  独立游戏开发者工具箱：2025精选推荐与实用指南</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xu-huan-yin-qing-you-xi-kai-fa-xi-lie-zhuan-ti-guan-fang-bian-ma-biao-zhun-huo-gui-yue/'
      tabindex="-59">  虚幻引擎游戏开发系列专题-官方编码标准或规约</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xiang-jie-she-ji-mo-shi-dan-li-de-jin-hua-zhi-lu/'
      tabindex="-60">  详解设计模式_单例的进化之路</a></span>
  </li><li class="file">
    <span><a href='https://ilikexff.cn/xie-e-de-fei-chang-liang-quan-ju-bian-liang/'
      tabindex="-61">  邪恶的非常量全局变量</a></span>
  </li>
</ul>
</div>
      <div class="viewer page" id="viewer" tabindex="0">
        <div class="tab">
<div class="file-manager" onclick='document.getElementById("files").classList.toggle("open"); document.getElementById("content").classList.toggle("close")'> </div>
<ul id="tabs">
</ul>


</div>
        <div class="content" id="content"><h3 id="2025-3-1-geng-xin">2025-3-1 更新:</h3>
<blockquote>
<ul>
<li>对原有内容的补充和完善</li>
</ul>
</blockquote>
<hr />
<p>在阅读本文的同时,默认你已经了解了<code>C++</code>中参数传递的其他两种方式:</p>
<ul>
<li>按值传递</li>
<li>引用传递</li>
</ul>
<p>下面的程序对这俩中 传递方式做了一个简单的使用演示:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">printByValue</span><span>(std::string </span><span style="color:#bf616a;">val</span><span>) </span><span style="color:#65737e;">// 函数参数是 str 的一个副本
</span><span>{
</span><span>    std::cout &lt;&lt; val &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;; </span><span style="color:#65737e;">// 通过副本打印值
</span><span>}
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">printByReference</span><span>(</span><span style="color:#b48ead;">const</span><span> std::string&amp; </span><span style="color:#bf616a;">ref</span><span>) </span><span style="color:#65737e;">// 函数参数是一个引用，绑定到 str
</span><span>{
</span><span>    std::cout &lt;&lt; ref &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;; </span><span style="color:#65737e;">// 通过引用打印值
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    std::string </span><span style="color:#bf616a;">str</span><span>{ &quot;</span><span style="color:#a3be8c;">Hello, world!</span><span>&quot; };
</span><span>
</span><span>    </span><span style="color:#bf616a;">printByValue</span><span>(str); </span><span style="color:#65737e;">// 按值传递 str，创建 str 的副本
</span><span>    </span><span style="color:#bf616a;">printByReference</span><span>(str); </span><span style="color:#65737e;">// 按引用传递 str，不创建 str 的副本
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<ul>
<li>当我们使用值传递参数<code>str</code>时,函数参数<code>val</code>接收参数的一个副本。所以每次对传递进来的参数的修改都不会直接影响原始参数,因为它修改的其实是原始参数的副本而已。</li>
<li>通过引用传递参数时,引用参数<code>ref</code>绑定到实际参数。这避免了复制参数,因为我们的引用参数是<code>const</code>修饰的,因此不允许修改<code>ref</code>,但是如果没有这个常量修复符,那么我们对<code>ref</code>所做的任何修改都会影响<code>str</code></li>
</ul>
<blockquote>
<p>以上两种 情况下,函数的调用者都提供了实际的对象<code>str</code>作为函数调用的参数。</p>
</blockquote>
<hr />
<h2 id="di-zhi-chuan-di">地址传递</h2>
<p><code>C++</code>提供了一种将值传递给函数的第三种方式，称为按地址传递。在按地址传递中，调用者不是提供对象作为参数，而是提供对象的地址（通过指针）。这个指针（包含对象的地址）被复制到被调用函数的指针参数中（现在也包含对象的地址）。然后函数可以取消引用该指针以访问传递的地址的对象。</p>
<p>基于此,考虑下面的程序,在上面示例方法的基础上新增了按地址传递版本:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">string</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">printByValue</span><span>(std::string </span><span style="color:#bf616a;">val</span><span>) </span><span style="color:#65737e;">// 函数参数是 str 的副本
</span><span>{
</span><span>    std::cout &lt;&lt; val &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;; </span><span style="color:#65737e;">// 通过副本打印值
</span><span>}
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">printByReference</span><span>(</span><span style="color:#b48ead;">const</span><span> std::string&amp; </span><span style="color:#bf616a;">ref</span><span>) </span><span style="color:#65737e;">// 函数参数是一个引用，绑定到 str
</span><span>{
</span><span>    std::cout &lt;&lt; ref &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;; </span><span style="color:#65737e;">// 通过引用打印值
</span><span>}
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">printByAddress</span><span>(</span><span style="color:#b48ead;">const</span><span> std::string* </span><span style="color:#bf616a;">ptr</span><span>) </span><span style="color:#65737e;">// 函数参数是一个指针，保存 str 的地址
</span><span>{
</span><span>    std::cout &lt;&lt; *ptr &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;; </span><span style="color:#65737e;">// 通过解引用指针打印值
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    std::string </span><span style="color:#bf616a;">str</span><span>{ &quot;</span><span style="color:#a3be8c;">Hello, world!</span><span>&quot; };
</span><span>
</span><span>    </span><span style="color:#bf616a;">printByValue</span><span>(str); </span><span style="color:#65737e;">// 按值传递 str，创建 str 的副本
</span><span>    </span><span style="color:#bf616a;">printByReference</span><span>(str); </span><span style="color:#65737e;">// 按引用传递 str，不创建 str 的副本
</span><span>    </span><span style="color:#bf616a;">printByAddress</span><span>(&amp;str); </span><span style="color:#65737e;">// 按地址传递 str，不创建 str 的副本
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<ul>
<li>首先、由于我们希望<code>printByAddress()</code>函数使用地址传递,所以需要把函数的参数调整为一个名为<code>ptr</code>的指针。再者,考虑到该函数将以只读的方式使用这个<code>ptr</code>指针,所以该指针声明为一个指向常量值的指针。如果你是直接点开的本文,对指针类型尚未学习,建议查看这篇文章:<a class="" href="https://www.ilikexff.cn/articles/150#google_vignette">[通俗易懂C++]:指针和const</a></li>
<li>其次、当调用函数时,我们不仅不能直接传入<code>str</code>对象,还需要传入<code>str</code>的地址,你可能也想到了,可以使用取地址运算符(<code>&amp;</code>)来获取包含<code>str</code>的=地址的指针。</li>
</ul>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#bf616a;">printByAddress</span><span>(&amp;str);
</span></code></pre>
<p>当执行调用时,<code>&amp;str</code>将会创建一个持有<code>str</code>地址的指针。然后,该地址呗复制到函数参数<code>ptr</code>作为函数调用的一部分。因为该指针<code>ptr</code>持有<code>str</code>的地址,当函数使用<code>*</code>解引用<code>ptr</code>时,它将获取<code>str</code>的值,该值通过函数的调用会被打印到控制台上。</p>
<blockquote>
<ul>
<li>当我们使用 <code>operator&amp;</code> 将变量的地址作为参数传递时，我们说变量是通过地址传递的。</li>
<li>当我们有一个指针变量持有对象的地址，并且我们将指针作为相同类型的参数传递时，我们说对象是通过地址传递的，指针是通过值传递的。</li>
</ul>
</blockquote>
<hr />
<h3 id="di-zhi-chuan-di-bu-hui-fu-zhi-suo-zhi-xiang-de-dui-xiang">地址传递不会复制所指向的对象</h3>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>std::string </span><span style="color:#bf616a;">str</span><span>{ &quot;</span><span style="color:#a3be8c;">Hello, world!</span><span>&quot; };
</span><span style="color:#bf616a;">printByAddress</span><span>(&amp;str); </span><span style="color:#65737e;">// 使用取地址操作符 (&amp;) 获取一个指针，指向 str 的地址
</span></code></pre>
<p>你需要知道的是,一味的通过复制形式的传递,那个复制的成本是比较高的,特别是<code>sstd::tring</code>,因此尽可能的避免使用基于复制的值传递,当我们通过地址传递<code>std::string</code>时,我们并不需要复制实际的<code>std::string</code>对象,而只是在调用者到被调用者之间复制指针(该指针持有对象的地址)。由于地址通常只有4或者8个字节,指针也只有4或8个字节,因此复制指针的成本很低,速度也很快。</p>
<blockquote>
<p>因此，就像按引用传递一样，按地址传递速度快，且避免了复制参数对象。</p>
</blockquote>
<hr />
<h3 id="di-zhi-chuan-di-yun-xu-han-shu-xiu-gai-can-shu-de-zhi">地址传递允许函数修改参数的值</h3>
<p>当我们通过地址传递一个对象时,函数接收传递对象的地址,他可以通过解引用来访问。</p>
<p>因为这是实际参数对象的地址而不是副本,如果函数参数是指向非<code>const</code>的指针,则函数可以通过指针参数修改参数的值:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">changeValue</span><span>(</span><span style="color:#b48ead;">int</span><span>* </span><span style="color:#bf616a;">ptr</span><span>) </span><span style="color:#65737e;">// 注意：ptr 在这个例子中是一个指向非 const 类型的指针
</span><span>{
</span><span>    *ptr = </span><span style="color:#d08770;">6</span><span>; </span><span style="color:#65737e;">// 将值修改为 6
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span>{ </span><span style="color:#d08770;">5 </span><span>};
</span><span>
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">x = </span><span>&quot; &lt;&lt; x &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;; </span><span style="color:#65737e;">// 打印 x 的初始值
</span><span>
</span><span>    </span><span style="color:#bf616a;">changeValue</span><span>(&amp;x); </span><span style="color:#65737e;">// 将 x 的地址传递给函数
</span><span>
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">x = </span><span>&quot; &lt;&lt; x &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;; </span><span style="color:#65737e;">// 打印修改后的 x 的值
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p><img src="https://images.waer.ltd/notes/202502231826546.png" alt="image-20250223182608419" loading="lazy" decoding="async" /></p>
<p>如果一个函数不应该修改传入的对象，则函数参数应该是一个指向常量的指针：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">changeValue</span><span>(</span><span style="color:#b48ead;">const int</span><span>* </span><span style="color:#bf616a;">ptr</span><span>) </span><span style="color:#65737e;">// 注意：ptr 现在是一个指向 const 的指针
</span><span>{
</span><span>    *ptr = </span><span style="color:#d08770;">6</span><span>; </span><span style="color:#65737e;">// 错误：不能修改 const 值
</span><span>}
</span></code></pre>
<p>由于和通常不为普通（非指针、非引用）函数参数添加 <code>const</code> 关键字,我们也通常不会为指针函数参数添加<code> const</code> 关键字。</p>
<p>一下是两个说明:</p>
<ul>
<li>
<p><strong>将 const 关键字用于指针函数参数</strong>，使其成为 <strong>常量指针</strong>，几乎没有什么价值（因为它对调用者没有影响，且主要作为文档说明指针不会改变）。</p>
</li>
<li>
<p><strong>将 const 关键字用于区分指向常量的指针与可以修改传入对象的非常量指针</strong>，则非常重要（因为调用者需要知道函数是否可能修改传入参数的值）。</p>
</li>
</ul>
<p>如果我们只使用非<code> const</code> 的指针函数参数，那么所有 <code>const</code> 的使用都是有意义的。一旦我们开始为指针函数参数使用 <code>const</code>，就会变得更加难以判断 <code>const</code> 的使用是否真的有意义。更重要的是，这也会使得难以察觉 <strong>指向非 const 参数</strong>。例如：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">foo</span><span>(</span><span style="color:#b48ead;">const char</span><span>* </span><span style="color:#bf616a;">source</span><span>, </span><span style="color:#b48ead;">char</span><span>* </span><span style="color:#bf616a;">dest</span><span>, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">count</span><span>);             </span><span style="color:#65737e;">// 使用非 const 指针，所有的 const 都是有意义的。
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">foo</span><span>(</span><span style="color:#b48ead;">const char</span><span>* </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">source</span><span>, </span><span style="color:#b48ead;">char</span><span>* </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">dest</span><span>, </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">count</span><span>); </span><span style="color:#65737e;">// 使用 const 指针，`dest` 是指向非 const 的指针，可能会在大量无关紧要的 const 中被忽略。
</span></code></pre>
<p>在前一种情况中，很容易看出 <code>source</code> 是指向常量的指针，而 <code>dest</code> 是指向非常量的指针。 在后一种情况下，就很难看出 <code>dest</code> 是一个常量指针指向非常量的对象，而函数可以修改它所指向的对象！</p>
<p><strong>最佳实践</strong></p>
<blockquote>
<ul>
<li>优先使用指向常量的函数参数，而不是指向非常量的函数参数，除非函数需要修改传入的对象。</li>
<li>不要在没有特定原因的情况下将函数参数设置为常量指针。</li>
</ul>
</blockquote>
<hr />
<h3 id="">空指针检查</h3>
<p>考虑下面这个看似人畜无害的代码:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span>(</span><span style="color:#b48ead;">int</span><span>* </span><span style="color:#bf616a;">ptr</span><span>)
</span><span>{
</span><span>	std::cout &lt;&lt; *ptr &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>	</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span>{ </span><span style="color:#d08770;">5 </span><span>};
</span><span>	</span><span style="color:#bf616a;">print</span><span>(&amp;x);
</span><span>
</span><span>	</span><span style="color:#b48ead;">int</span><span>* </span><span style="color:#bf616a;">myPtr </span><span>{};
</span><span>	</span><span style="color:#bf616a;">print</span><span>(myPtr);
</span><span>
</span><span>	</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>当运行此程序时，它将打印值 <code>5</code> 然后很可能会崩溃。</p>
<p>在调用 <code>print(myPtr)</code> 时， <code>myPtr</code> 是一个空指针，因此函数参数 <code>ptr</code> 也将是一个空指针。当在这个函数体中解引用这个空指针时，将产生未定义行为。</p>
<p>在通过地址传递参数时，在解引用值之前应确保指针不是空指针关于空指针的检查,之前的文章也是提到过的,这里就不再赘述。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span>(</span><span style="color:#b48ead;">int</span><span>* </span><span style="color:#bf616a;">ptr</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">if </span><span>(ptr) </span><span style="color:#65737e;">// 检查空指针
</span><span>    {
</span><span>        std::cout &lt;&lt; *ptr &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;;
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>	</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span>{ </span><span style="color:#d08770;">5 </span><span>};
</span><span>
</span><span>	</span><span style="color:#bf616a;">print</span><span>(&amp;x);
</span><span>	</span><span style="color:#bf616a;">print</span><span>(</span><span style="color:#d08770;">nullptr</span><span>);
</span><span>
</span><span>	</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<ul>
<li>虽然这对于这样一个简单的函数来说是可以的，但在更复杂的函数中，这可能会导致冗余的逻辑（多次测试指针是否为空）或函数主要逻辑的嵌套冗余。</li>
</ul>
<p>在大多数情况下,采取下面的写法更为建议:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">print</span><span>(</span><span style="color:#b48ead;">int</span><span>* </span><span style="color:#bf616a;">ptr</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">if </span><span>(!ptr) </span><span style="color:#65737e;">// 如果 ptr 是空指针，提前返回到调用者
</span><span>        </span><span style="color:#b48ead;">return</span><span>;
</span><span>
</span><span>    </span><span style="color:#65737e;">// 如果执行到这里，我们可以假设 ptr 是有效的
</span><span>    </span><span style="color:#65737e;">// 所以不需要再进行测试或嵌套检查
</span><span>
</span><span>    std::cout &lt;&lt; *ptr &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;; </span><span style="color:#65737e;">// 打印指针指向的值
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span>{ </span><span style="color:#d08770;">5 </span><span>};
</span><span>
</span><span>    </span><span style="color:#bf616a;">print</span><span>(&amp;x);     </span><span style="color:#65737e;">// 传递 x 的地址，打印 5
</span><span>    </span><span style="color:#bf616a;">print</span><span>(</span><span style="color:#d08770;">nullptr</span><span>); </span><span style="color:#65737e;">// 传递空指针，不会打印任何内容
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<hr />
<h2 id="-1">优先使用const引用传递</h2>
<ul>
<li>
<p>通过引用传递具有与通过地址传递相同的优点，而不存在意外解除空指针的风险。</p>
</li>
<li>
<p>通过 <code>const</code> 引用传递有一些比通过地址传递的优势。</p>
</li>
</ul>
<p>首先，因为通过地址传递的对象必须有一个地址，所以只有左值可以按地址传递（因为右值没有地址）。按 const 引用传递更灵活，因为它可以接受左值和右值：</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">printByValue</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">val</span><span>) </span><span style="color:#65737e;">// 函数参数是参数的副本
</span><span>{
</span><span>    std::cout &lt;&lt; val &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;; </span><span style="color:#65737e;">// 通过副本打印值
</span><span>}
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">printByReference</span><span>(</span><span style="color:#b48ead;">const int</span><span>&amp; </span><span style="color:#bf616a;">ref</span><span>) </span><span style="color:#65737e;">// 函数参数是一个绑定到参数的引用
</span><span>{
</span><span>    std::cout &lt;&lt; ref &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;; </span><span style="color:#65737e;">// 通过引用打印值
</span><span>}
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">printByAddress</span><span>(</span><span style="color:#b48ead;">const int</span><span>* </span><span style="color:#bf616a;">ptr</span><span>) </span><span style="color:#65737e;">// 函数参数是一个指针，持有参数的地址
</span><span>{
</span><span>    std::cout &lt;&lt; *ptr &lt;&lt; &#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;; </span><span style="color:#65737e;">// 通过解引用指针打印值
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#bf616a;">printByValue</span><span>(</span><span style="color:#d08770;">5</span><span>);     </span><span style="color:#65737e;">// 有效（但会创建一个副本）
</span><span>    </span><span style="color:#bf616a;">printByReference</span><span>(</span><span style="color:#d08770;">5</span><span>); </span><span style="color:#65737e;">// 有效（因为参数是常量引用）
</span><span>    </span><span style="color:#bf616a;">printByAddress</span><span>(&amp;</span><span style="color:#d08770;">5</span><span>);  </span><span style="color:#65737e;">// 错误：不能对右值取地址
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>其次，按引用传递的语法很自然，因为我们只需传递字面量或对象。使用按地址传递，我们的代码最终会充斥着与号<code>（&amp;）</code>和星号<code>（*）</code>。代码量很大的情况下,会让你看的头皮发麻我给你讲!!!</p>
<p>在现代 <code>C++</code>中，大多数可以用按地址传递完成的事情，通过其他方法做得更好。遵循这个常见的原则：“<strong>能通过引用传递时就传递引用，必须时才传递地址</strong>”。</p>
<p>所以最佳实践是:<strong>优先使用引用传递而非地址传递，除非你有特定理由使用地址传递。</strong></p>
<hr />
<h3 id="-2">通过地址传递可选参数</h3>
<p>函数通过地址传递的一个更加常见的用途是允许函数接受一个“可选”参数。看个例子:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">printIDNumber</span><span>(</span><span style="color:#b48ead;">const int </span><span>*</span><span style="color:#bf616a;">id </span><span>= </span><span style="color:#d08770;">nullptr</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">if </span><span>(id)  </span><span style="color:#65737e;">// 如果 id 不为 null，则输出 ID 号码
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Your ID number is </span><span>&quot; &lt;&lt; *id &lt;&lt; &quot;</span><span style="color:#a3be8c;">.</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">else  </span><span style="color:#65737e;">// 如果 id 为 null，则表示 ID 未知
</span><span>        std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Your ID number is not known.</span><span style="color:#96b5b4;">\n</span><span>&quot;;
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#bf616a;">printIDNumber</span><span>(); </span><span style="color:#65737e;">// 调用时不传入参数，ID 未知
</span><span>
</span><span>    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">userid </span><span>{ </span><span style="color:#d08770;">34 </span><span>};
</span><span>    </span><span style="color:#bf616a;">printIDNumber</span><span>(&amp;userid); </span><span style="color:#65737e;">// 传入 userid 的地址，ID 已知
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>在这个程序中， <code>printIDNumber()</code> 函数有一个参数，通过地址传递并默认为 <code>nullptr</code> 。在 <code>main()</code> 中，我们调用这个函数两次。第一次调用时，我们不知道用户的 ID，所以不带参数调用 <code>printIDNumber()</code> 。 <code>id</code> 参数默认为 <code>nullptr</code> ，函数打印 <code>Your ID number is not known.</code> 。第二次调用时，我们现在有一个有效的 ID，所以调用 <code>printIDNumber(&amp;userid)</code> 。 <code>id</code> 参数接收 <code>userid</code> 的地址，因此函数打印 <code>Your ID number is 34.</code> 。</p>
<p>然而,在许多情况下,使用函数重载可以达到相同的目的,这是一个不更好的替代方案:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">printIDNumber</span><span>()  </span><span style="color:#65737e;">// 函数版本1：无参数版本
</span><span>{
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Your ID is not known</span><span style="color:#96b5b4;">\n</span><span>&quot;;  </span><span style="color:#65737e;">// 如果没有提供 ID，则打印此消息
</span><span>}
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">printIDNumber</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">id</span><span>)  </span><span style="color:#65737e;">// 函数版本2：接收一个整数类型的参数
</span><span>{
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">Your ID is </span><span>&quot; &lt;&lt; id &lt;&lt; &quot;</span><span style="color:#96b5b4;">\n</span><span>&quot;;  </span><span style="color:#65737e;">// 打印 ID
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#bf616a;">printIDNumber</span><span>(); </span><span style="color:#65737e;">// 调用无参数版本，输出 &quot;Your ID is not known&quot;
</span><span>
</span><span>    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">userid </span><span>{ </span><span style="color:#d08770;">34 </span><span>};
</span><span>    </span><span style="color:#bf616a;">printIDNumber</span><span>(userid); </span><span style="color:#65737e;">// 调用带整数参数的版本，输出 &quot;Your ID is 34&quot;
</span><span>
</span><span>    </span><span style="color:#bf616a;">printIDNumber</span><span>(</span><span style="color:#d08770;">62</span><span>); </span><span style="color:#65737e;">// 直接传递一个整数值作为参数，输出 &quot;Your ID is 62&quot;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>除此之外,使用函数重载的实现方式,我们不再需要担心空指针解引的问题,并且可以传递字面量或者其他右值作为参数。</p>
<hr />
<h3 id="-3">改变指针参数指向的内容</h3>
<p>当我们从函数传递一个地址时,该地址从参数(实参)复制到指针参数(形参)中。</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#65737e;">// [[maybe_unused]] 用来防止编译器因为 ptr2 设置但没有使用而发出警告
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">nullify</span><span>([[maybe_unused]] </span><span style="color:#b48ead;">int</span><span>* </span><span style="color:#bf616a;">ptr2</span><span>)
</span><span>{
</span><span>    ptr2 = </span><span style="color:#d08770;">nullptr</span><span>; </span><span style="color:#65737e;">// 将函数参数指针设置为 null
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span>{ </span><span style="color:#d08770;">5 </span><span>};  </span><span style="color:#65737e;">// 定义一个整型变量 x，初始化为 5
</span><span>    </span><span style="color:#b48ead;">int</span><span>* </span><span style="color:#bf616a;">ptr</span><span>{ &amp;x }; </span><span style="color:#65737e;">// 定义一个指针 ptr，指向 x
</span><span>
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">ptr is </span><span>&quot; &lt;&lt; (ptr ? &quot;</span><span style="color:#a3be8c;">non-null</span><span style="color:#96b5b4;">\n</span><span>&quot; : &quot;</span><span style="color:#a3be8c;">null</span><span style="color:#96b5b4;">\n</span><span>&quot;); </span><span style="color:#65737e;">// 判断 ptr 是否为空指针
</span><span>
</span><span>    </span><span style="color:#bf616a;">nullify</span><span>(ptr);  </span><span style="color:#65737e;">// 调用 nullify 函数，尝试将 ptr 设置为 nullptr
</span><span>
</span><span>    </span><span style="color:#65737e;">// 判断 ptr 是否为空指针
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">ptr is </span><span>&quot; &lt;&lt; (ptr ? &quot;</span><span style="color:#a3be8c;">non-null</span><span style="color:#96b5b4;">\n</span><span>&quot; : &quot;</span><span style="color:#a3be8c;">null</span><span style="color:#96b5b4;">\n</span><span>&quot;); 
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>如你所见，改变指针参数所持有的地址对参数（ <code>ptr</code> 仍然指向 <code>x</code> ）没有影响。当调用函数 <code>nullify()</code> 时， <code>ptr2</code> 接收了传入地址的副本（在这种情况下， <code>ptr</code> 所持有的地址，即 <code>x</code> 的地址）。当函数改变 <code>ptr2</code> 所指向的内容时，这只会影响 <code>ptr2</code> 所持有的副本。</p>
<p>就像我们可以通过引用传递一个普通变量时一样,我们可以通过引用来传递指针。下面是将上面程序中的<code>ptr2</code>更改为地址引用的版本:</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">nullify</span><span>(</span><span style="color:#b48ead;">int</span><span>*&amp; </span><span style="color:#bf616a;">refptr</span><span>)  </span><span style="color:#65737e;">// refptr 是一个指向指针的引用
</span><span>{
</span><span>    refptr = </span><span style="color:#d08770;">nullptr</span><span>;  </span><span style="color:#65737e;">// 将函数参数指针修改为 null
</span><span>}
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">x</span><span>{ </span><span style="color:#d08770;">5 </span><span>};  </span><span style="color:#65737e;">// 定义一个整型变量 x，初始化为 5
</span><span>    </span><span style="color:#b48ead;">int</span><span>* </span><span style="color:#bf616a;">ptr</span><span>{ &amp;x };  </span><span style="color:#65737e;">// 定义一个指针 ptr，指向 x
</span><span>
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">ptr is </span><span>&quot; &lt;&lt; (ptr ? &quot;</span><span style="color:#a3be8c;">non-null</span><span style="color:#96b5b4;">\n</span><span>&quot; : &quot;</span><span style="color:#a3be8c;">null</span><span style="color:#96b5b4;">\n</span><span>&quot;);  </span><span style="color:#65737e;">// 判断 ptr 是否为空指针
</span><span>
</span><span>    </span><span style="color:#bf616a;">nullify</span><span>(ptr);  </span><span style="color:#65737e;">// 调用 nullify 函数，传递 ptr 的引用，修改 ptr 的值
</span><span>
</span><span>    std::cout &lt;&lt; &quot;</span><span style="color:#a3be8c;">ptr is </span><span>&quot; &lt;&lt; (ptr ? &quot;</span><span style="color:#a3be8c;">non-null</span><span style="color:#96b5b4;">\n</span><span>&quot; : &quot;</span><span style="color:#a3be8c;">null</span><span style="color:#96b5b4;">\n</span><span>&quot;);  </span><span style="color:#65737e;">// 判断 ptr 是否为空指针
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>因为 <code>refptr</code> 现在是一个指向指针的引用，当 <code>ptr</code> 作为参数传递时， <code>refptr</code> 绑定到 <code>ptr</code> 。这意味着对 <code>refptr</code> 的任何更改都会应用到 <code>ptr</code> 。</p>
<hr />
<blockquote>
<p>感谢阅读,欢迎指正!</p>
</blockquote>

        </div>
      </div>
      <div class="prompt" id="terminal"><input
    type="text"
    id="setter"
    onkeydown="writeit(this, event);moveIt(this.value.length, event)"
    onchange="writeit(this, event)"
    onkeyup="writeit(this, event)"
    onkeypress="writeit(this, event);"
    >
<label for="setter" id="writer"> </label><b class="cursor" id="cursor"></b></div>
      <footer class="footer">
        <div class="footer-content">
          <p class="icp-info">
            <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer">黔ICP备2021010295号</a>
          </p>
        </div>
      </footer>
    </main>
  </body>

</html>
