<!DOCTYPE html>
<html lang="zh" data-theme="light" dir="ltr">
  <head>
    <title>C++游戏开发基础-深入解析std::optional - 慕予博客</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="description" content="详细介绍C++17引入的std::optional类型，包括其用法、应用场景以及最佳实践。"/>

    <meta property="og:title" content="慕予博客 -&nbsp;C++游戏开发基础-深入解析std::optional" />
    <meta property="og:type" content="website"/><meta property="og:url" content="https:&#x2F;&#x2F;ilikexff.cn&#x2F;c-you-xi-kai-fa-ji-chu-std-optional&#x2F;"/><meta property="og:description" content="详细介绍C++17引入的std::optional类型，包括其用法、应用场景以及最佳实践。"/>


    <meta name="twitter:card" content="summary">


    <link rel="stylesheet" href="https://ilikexff.cn/spectre/spectre.css">
    <link rel="stylesheet" href="https://ilikexff.cn/theme.css"><link rel="stylesheet" href="https://ilikexff.cn/custom.css">
    

        
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>

    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script>
        function doRenderMath() {
            renderMathInElement(document.body, {
                delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false},
                {left: "\\(", right: "\\)", display: false},
                {left: "\\begin{equation}", right: "\\end{equation}", display: true},
                {left: "\\begin{align}", right: "\\end{align}", display: true},
                {left: "\\begin{alignat}", right: "\\end{alignat}", display: true},
                {left: "\\begin{gather}", right: "\\end{gather}", display: true},
                {left: "\\begin{CD}", right: "\\end{CD}", display: true},
                {left: "\\[", right: "\\]", display: true}
                ]
            });
        }
    </script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
        onload="doRenderMath()"></script>

      </head>
  <body id="top" class="sticky-footer"><div id="page-wrapper">
<header id="header" class="section">
  <section class="container grid-xl">
    <nav class="navbar">
      <section class="navbar-section">
        
<a class="site-logo" href="https:&#x2F;&#x2F;ilikexff.cn">
  
  <div class="col-mx-auto">
    <figure style="margin: 8px">
      <img class="img-responsive"
           style="max-height: 45px"
           alt="frontmatter image"
           src="https://ilikexff.cn/./logo.svg">
    </figure>
  </div>
  
</a>

      </section><!-- ./home button -->

      <section class="navbar-center hide-md"></section>

      <section class="navbar-section">
        <nav class="dropmenu animated hide-md">

<ul><li>
        <a href="https://ilikexff.cn/tags">标签</a>
    </li><li>
        <a href="https://ilikexff.cn/categories">分类</a>
    </li><li>
        <a href="https://ilikexff.cn/about">关于</a>
    </li></ul>


          </nav>
      </section><!-- ./desktop-menu -->
    </nav>
  </section><!-- ./container -->
</header>


<div class="mobile-menu">
  <div class="button_container" id="toggle" onclick="openOverlay()">
    <span class="top"></span>
    <span class="middle"></span>
    <span class="bottom"></span>
  </div>
</div><!--./mobile-menu-->


<section id="start"><section id="body-wrapper" class="section">
          <section class="container grid-xl">
<div id="breadcrumbs" itemtype="http://schema.org/BreadcrumbList" class="hide-sm">
  
    
    <span><a href="https:&#x2F;&#x2F;ilikexff.cn&#x2F;">Home</a></span>
  
    <span><a href="https:&#x2F;&#x2F;ilikexff.cn&#x2F;c-you-xi-kai-fa-ji-chu-std-optional&#x2F;">C++游戏开发基础-深入解析std::optional</a></span>
</div>
<div class="columns">
              <div id="item" class="column col-8 col-md-12 extra-spacing">
<div class="card">
  

    <div class="card-header">
      <div class="card-title" style="margin-top: .25rem;"><div>
          <h1 class="post-title">C++游戏开发基础-深入解析std::optional</h1>
          
    <div class="post-meta" style="display: inline-flex">
        <span class="blog-date" style="display: inline-flex;">
          <i class="gg-calendar" style="margin-right: 5px;"></i><time datetime="2025.06.19">
          2025.06.19
          </time></span><span class="post-author" style="margin-left: 5px; display: inline-flex;">
          - 
    慕予
        </span></div>

        </div></div>
    </div><!--./card-header-->

    <div class="card-body">
      
        <p>考虑下面这样一个函数:</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#268bd2;">int </span><span style="color:#b58900;">doIntDivision</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int x</span><span>, </span><span style="color:#268bd2;">int y</span><span style="color:#657b83;">)
</span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#859900;">return</span><span> x </span><span style="color:#657b83;">/</span><span> y;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>如果调用者传入一个语义上无效的值（例如 <code>y</code> = <code>0</code> ），此函数无法计算一个返回值（因为除以 0 在数学上是未定义的）。在这种情况下我们该怎么办？</p>
<p>这种情况下,通常的做法是让函数检测错误,然后将错误返回给调用者以适当的方式处理。比如;</p>
<ul>
<li>函数返回一个bool值类型,表示成功或者失败!</li>
<li>让一个有返回值的函数返回一个哨兵值（一个特殊的值，该值不会出现在函数可能返回的其他值的集合中），以此来指示错误。</li>
</ul>
<p>以下示例中， <code>reciprocal()</code> 函数在用户为 <code>x</code> 传递语义上无效的参数时返回值 <code>0.0</code> （这种情况在其他情况下不会发生）</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span style="color:#268bd2;">double </span><span style="color:#b58900;">reciprocal</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">double x</span><span style="color:#657b83;">)
</span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>x </span><span style="color:#657b83;">== </span><span style="color:#6c71c4;">0.0</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// 如果x在语义上无效
</span><span>       </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0.0</span><span>; </span><span style="color:#586e75;">// 返回0.0作为前哨指示发生错误的哨兵标识
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">1.0 </span><span style="color:#657b83;">/</span><span> x;
</span><span style="color:#657b83;">}
</span><span>
</span><span style="color:#268bd2;">void </span><span style="color:#b58900;">testReciprocal</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">double d</span><span style="color:#657b83;">)
</span><span style="color:#657b83;">{
</span><span>     </span><span style="color:#268bd2;">double </span><span style="color:#b58900;">result </span><span style="color:#657b83;">{ </span><span style="color:#b58900;">reciprocal</span><span style="color:#657b83;">(</span><span>d</span><span style="color:#657b83;">) }</span><span>;
</span><span>     std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">The reciprocal of </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt;</span><span> d </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;"> is </span><span>&quot;;
</span><span>     </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>result </span><span style="color:#657b83;">!= </span><span style="color:#6c71c4;">0.0</span><span style="color:#657b83;">)
</span><span>         std::cout </span><span style="color:#657b83;">&lt;&lt;</span><span> result </span><span style="color:#657b83;">&lt;&lt; </span><span>&#39;</span><span style="color:#dc322f;">\n</span><span>&#39;;
</span><span>     </span><span style="color:#859900;">else
</span><span>         std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">undefined</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span style="color:#657b83;">}
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#b58900;">testReciprocal</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">5.0</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#b58900;">testReciprocal</span><span style="color:#657b83;">(-</span><span style="color:#6c71c4;">4.0</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#b58900;">testReciprocal</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">0.0</span><span style="color:#657b83;">)</span><span>;
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>尽管这是一个不错的解决方案,但也存在一些潜在的不足:</p>
<ul>
<li>作为程序员必须知道函数使用哪个哨兵值来表示错误;</li>
<li>同一个函数的不同版本可能会使用不同的哨兵值;</li>
<li>此方法不适用于所有可能的哨兵值都是有效返回值的函数。</li>
</ul>
<p>再考虑我们上面的 <code>doIntDivision()</code> 函数。如果用户传入 <code>0</code> 作为 <code>y</code> 的值，它可能返回什么值？我们不能使用 <code>0</code> ，因为 <code>0</code> 除以任何数都不会得到 <code>0</code> 作为有效结果。实际上，并不存在我们无法返回且无法自然出现的值。</p>
<p>那么,如果要使用哨兵值表示法,我们可以选择一些不常见的返回值作为哨兵,并用它来表示错误信息的标识;比如,采用指定类型的极值。 </p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">limits</span><span>&gt;
</span><span>
</span><span>std::optional</span><span style="color:#657b83;">&lt;</span><span style="color:#268bd2;">int</span><span style="color:#657b83;">&gt; </span><span style="color:#b58900;">doIntDivision</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int a</span><span>,</span><span style="color:#268bd2;">int b</span><span style="color:#657b83;">)
</span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#859900;">if</span><span style="color:#657b83;">(</span><span>b </span><span style="color:#657b83;">== </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">)
</span><span>        </span><span style="color:#859900;">return</span><span> std::numeric_limits</span><span style="color:#657b83;">&lt;</span><span style="color:#268bd2;">int</span><span style="color:#657b83;">&gt;</span><span>::</span><span style="color:#b58900;">lowest</span><span style="color:#657b83;">()</span><span>;
</span><span>    </span><span style="color:#859900;">return</span><span> a </span><span style="color:#657b83;">/</span><span> b;
</span><span style="color:#657b83;">}
</span></code></pre>
<p><code>std::numeric_limits&lt;T&gt;::lowest()</code> 是一个返回类型 <code>T</code> 的最负值的函数,相对应的还有<code>std::numeric_limits&lt;T&gt;::max()</code> 对应函数（<code>std::numeric_limits&lt;T&gt;::max()</code> 函数返回类型 <code>T</code> 的最大正值）</p>
<p>在上面的实例中,如果 <code>doIntDivision()</code> 无法继续执行，我们返回 <code>std::numeric_limits&lt;int&gt;::lowest()</code> ，这将返回最负的整数值给调用者以指示函数执行失败。</p>
<p>虽然这是可行的一种方式,当它存在两个缺点:</p>
<ul>
<li>每次调用这个函数时，都需要测试返回值是否与 <code>std::numeric_limits&lt;int&gt;::lowest()</code> 相等以判断是否失败。这既繁琐又难看。</li>
<li>考虑这样一种情况,如果用户调用 <code>doIntDivision(std::numeric_limits&lt;int&gt;::lowest(), 1)</code> ，返回的结果 <code>std::numeric_limits&lt;int&gt;::lowest()</code> 将无法明确地表明函数是成功还是失败。当然这种问题的出现取决于实际的使用方式,也许出现的几率不是很大,但不得不作为一个可能导致程序出现一些潜在危险的途径。</li>
</ul>
<p>其次,你可能也想到了,我们可以放弃使用这种返回哨兵值的方式来标识错误返回,并使用异常机制来进行。然而,异常本身也有其复杂性和性能开销,并不一定合适每一种类似的场景,起码对于我们正在讨论的这种情况来说未免有些过于繁琐了。</p>
<hr />
<h2 id="std-optional">std::optional<a class="zola-anchor" href="#std-optional" aria-label="Anchor link for: std-optional">🔗</a></h2>
<p>基于上面讨论的情况和各种解决方案,你可能也想到了,既然使用返回单个哨兵值的方式存在局限,那么我们是不是可以考虑返回两个值呢?一个用来标识函数是否成功,一个用于存储实际的返回值(取决于函数的执行结果)。</p>
<p>在C++17中引入了<code>std::optional</code>,这是一个类模版类型,实现了 可选值。也即是说,一个 <code>std::optional&lt;T&gt;</code> 可以有类型为T的值,或者没有值。我们可以使用这个特性来实现上面这种双返回值的方案。</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">optional</span><span>&gt; </span><span style="color:#586e75;">// for std::optional (C++17)
</span><span>
</span><span>
</span><span>std::optional</span><span style="color:#657b83;">&lt;</span><span style="color:#268bd2;">int</span><span style="color:#657b83;">&gt; </span><span style="color:#b58900;">doIntDivision</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int a</span><span>, </span><span style="color:#268bd2;">int b</span><span style="color:#657b83;">)
</span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>b </span><span style="color:#657b83;">== </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">)
</span><span>        </span><span style="color:#859900;">return </span><span style="color:#657b83;">{}</span><span>; </span><span style="color:#586e75;">// or return std::nullopt
</span><span>    </span><span style="color:#859900;">return</span><span> a </span><span style="color:#657b83;">/</span><span> b;
</span><span style="color:#657b83;">}
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    std::optional</span><span style="color:#657b83;">&lt;</span><span style="color:#268bd2;">int</span><span style="color:#657b83;">&gt; </span><span style="color:#b58900;">result1 </span><span style="color:#657b83;">{ </span><span style="color:#b58900;">doIntDivision</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">20</span><span>, </span><span style="color:#6c71c4;">5</span><span style="color:#657b83;">) }</span><span>;
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>result1</span><span style="color:#657b83;">) 
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Result 1: </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#859900;">*</span><span>result1 </span><span style="color:#657b83;">&lt;&lt; </span><span>&#39;</span><span style="color:#dc322f;">\n</span><span>&#39;; 
</span><span>    </span><span style="color:#859900;">else
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Result 1: failed</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>
</span><span>    std::optional</span><span style="color:#657b83;">&lt;</span><span style="color:#268bd2;">int</span><span style="color:#657b83;">&gt; </span><span style="color:#b58900;">result2 </span><span style="color:#657b83;">{ </span><span style="color:#b58900;">doIntDivision</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">5</span><span>, </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">) }</span><span>;
</span><span>
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>result2</span><span style="color:#657b83;">)
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Result 2: </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#859900;">*</span><span>result2 </span><span style="color:#657b83;">&lt;&lt; </span><span>&#39;</span><span style="color:#dc322f;">\n</span><span>&#39;;
</span><span>    </span><span style="color:#859900;">else
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Result 2: failed</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>使用 <code>std::optional</code> 非常容易。我们可以使用下面三种方式来初始化构造一个 <code>std::optional&lt;T&gt;</code> ：</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>std::optional</span><span style="color:#657b83;">&lt;</span><span style="color:#268bd2;">int</span><span style="color:#657b83;">&gt;</span><span> o1 </span><span style="color:#657b83;">{</span><span style="color:#6c71c4;">6</span><span style="color:#657b83;">}</span><span>;
</span><span>std::optional</span><span style="color:#657b83;">&lt;</span><span style="color:#268bd2;">int</span><span style="color:#657b83;">&gt;</span><span> o2 </span><span style="color:#657b83;">{}</span><span>;
</span><span>std::optional</span><span style="color:#657b83;">&lt;</span><span style="color:#268bd2;">int</span><span style="color:#657b83;">&gt;</span><span> o3 </span><span style="color:#657b83;">{</span><span>std::nullopt</span><span style="color:#657b83;">}</span><span>;
</span></code></pre>
<p>要检查一个<code>std::optional</code>是否有值,我们可以选择下面方式之一:</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>o1.</span><span style="color:#b58900;">has_value</span><span style="color:#657b83;">()) </span><span style="color:#586e75;">// 1.使用has_value()函数检查
</span><span style="color:#859900;">if</span><span style="color:#657b83;">(</span><span>o2</span><span style="color:#657b83;">) </span><span style="color:#586e75;">//2.使用隐式转换进行bool以检查O2是否具有值  
</span></code></pre>
<p>同样,要从<code>std::optional</code>中获取值,我们可以选择以下方式之一:</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#859900;">*</span><span>o1; </span><span style="color:#586e75;">//1. 解引用以获取存储在 o1 中的值（如果 o1 中没有值，则会导致未定义行为）。
</span><span>std::cout </span><span style="color:#657b83;">&lt;&lt;</span><span> o2.</span><span style="color:#b58900;">value</span><span style="color:#657b83;">()</span><span>; </span><span style="color:#586e75;">//2. 调用 value() 以获取存储在 o2 中的值（如果 o2 中没有值，则会抛出 std::bad_optional_access 异常）。
</span><span>std::cout </span><span style="color:#657b83;">&lt;&lt;</span><span> o3.</span><span style="color:#b58900;">value_or</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">5</span><span style="color:#657b83;">)</span><span>; </span><span style="color:#586e75;">// 3.调用 value_or() 以获取存储在 o3 中的值（如果 o3 中没有值，则返回一个指定的默认值,这里返回5）。
</span></code></pre>
<p><code>std::optional</code>用法看起来和指针有些相似,但是从语义上讲,他们存在不小的差异:</p>
<ul>
<li>指针具有引用语义,意味着它引用其他对象,赋值时复制的是指针,而不是对象。如果我们通过地址返回指针,复制回去的是指针本身而不是被指向的对象。 这就意味着我们不能通过地址返回局部对象,因为这会将该对象的地址复制回调用者,然后该对象会被销毁,导致返回的指针成为悬空指针。下面是一个简单的例子:</li>
</ul>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#268bd2;">int</span><span style="color:#859900;">* </span><span style="color:#b58900;">getPtr</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#268bd2;">int</span><span> lovalVal </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">10</span><span>;
</span><span>    </span><span style="color:#859900;">return &amp;</span><span>localVal;
</span><span style="color:#657b83;">}
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#268bd2;">int</span><span style="color:#859900;">*</span><span> ptr </span><span style="color:#657b83;">= </span><span style="color:#b58900;">getPtr</span><span style="color:#657b83;">()</span><span>;
</span><span>    std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#859900;">*</span><span>ptr </span><span style="color:#657b83;">&lt;&lt; </span><span>&#39;</span><span style="color:#dc322f;">\n</span><span>&#39;;
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<ul>
<li><code>std::optional</code> 具有值语义，意味着它实际上包含其值，并且赋值会复制该值。如果我们按值返回一个 <code>std::optional</code> ，那么 <code>std::optional</code> （包括其中包含的值）会被复制回调用者。这意味着我们可以使用 <code>std::optional</code> 从函数返回一个值给调用者。</li>
</ul>
<blockquote>
<p>考虑到这一点，让我们看看我们的示例是如何工作的。我们的 <code>doIntDivision()</code> 现在返回一个 <code>std::optional&lt;int&gt;</code> ，而不是一个 <code>int</code> 。在函数体内，如果我们检测到错误，我们将返回 <code>{}</code> ，这会隐式返回一个 <code>std::optional</code> ，其中不包含任何值。如果我们有一个值，我们将返回该值，这会隐式返回一个 <code>std::optional</code> ，其中包含该值。</p>
<p>在 <code>main()</code> 中，我们使用隐式转换为 bool 来检查我们返回的 <code>std::optional</code> 是否有值。如果有值，我们解引用 <code>std::optional</code> 对象以获取值。如果没有值，我们执行错误条件。</p>
</blockquote>
<hr />
<h2 id="fan-hui-std-optionalde-you-que-dian">返回<code>std::optional</code>的优缺点<a class="zola-anchor" href="#fan-hui-std-optionalde-you-que-dian" aria-label="Anchor link for: fan-hui-std-optionalde-you-que-dian">🔗</a></h2>
<p>好处多多:</p>
<ul>
<li>
<p>有效使用<code> std::optional</code> 可以明确地表示一个函数可能返回一个值，也可能不返回值。</p>
</li>
<li>
<p>不需要记住哪个值是作为哨兵值返回的;</p>
</li>
<li>
<p>语法简洁直观。</p>
</li>
</ul>
<p>一些缺点:</p>
<ul>
<li>我们必须确保<code>std::optional</code>包含一个值再去执行获取的操作,否则解引用一个不包含值的<code>std::optional</code>将会发生为定义行为。</li>
<li><code>std::optional</code>无法提供关于函数失败原因的信息。</li>
</ul>
<p><strong>最佳实践</strong></p>
<blockquote>
<p>如果需要,请返回一个 <code>std::optional</code> （而不是哨兵值），除非你的函数需要返回有关失败原因的额外信息。</p>
</blockquote>
<hr />
<h2 id="shi-yong-std-optional-zuo-wei-ke-xuan-han-shu-can-shu"><strong>使用</strong> <code>std::optional</code> <strong>作为可选函数参数</strong><a class="zola-anchor" href="#shi-yong-std-optional-zuo-wei-ke-xuan-han-shu-can-shu" aria-label="Anchor link for: shi-yong-std-optional-zuo-wei-ke-xuan-han-shu-can-shu">🔗</a></h2>
<p>在之前的文章中提到过,如何使用通过地址传递来允许函数接受一个“可选”的参数（即调用者可以传递 <code>nullptr</code> 来表示“没有参数”或一个对象）。然而，这种方法的一个缺点是，非 nullptr 参数必须是 lvalue(左值)（以便其地址可以传递给函数）。</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#268bd2;">void </span><span style="color:#b58900;">processValue</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span style="color:#859900;">* </span><span style="color:#268bd2;">ptr</span><span style="color:#657b83;">) {
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>ptr</span><span style="color:#657b83;">) {
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Value: </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#859900;">*</span><span>ptr </span><span style="color:#657b83;">&lt;&lt;</span><span> std::endl;
</span><span>    </span><span style="color:#657b83;">} </span><span style="color:#859900;">else </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">No value provided.</span><span>&quot; </span><span style="color:#657b83;">&lt;&lt;</span><span> std::endl;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">() {
</span><span>    </span><span style="color:#268bd2;">int</span><span> x </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">10</span><span>;
</span><span>    </span><span style="color:#b58900;">processValue</span><span style="color:#657b83;">(</span><span style="color:#859900;">&amp;</span><span>x</span><span style="color:#657b83;">)</span><span>;    </span><span style="color:#586e75;">// 传入一个左值的地址
</span><span>    </span><span style="color:#b58900;">processValue</span><span style="color:#657b83;">(</span><span style="color:#b58900;">nullptr</span><span style="color:#657b83;">)</span><span>; </span><span style="color:#586e75;">// 传入 nullptr 表示无参数
</span><span>
</span><span>    </span><span style="color:#586e75;">// 错误示例: 传入右值（临时值）的地址
</span><span>    </span><span style="color:#586e75;">// processValue(&amp;5); // 编译错误，5 是一个右值，没有地址
</span><span style="color:#657b83;">}
</span></code></pre>
<p>更好的做法是,使用 <code>std::optional</code> 使参数可选，而不需要依赖 <code>nullptr</code> 和指针传递。例如：</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">optional</span><span>&gt;
</span><span>
</span><span style="color:#586e75;">// 打印用户的ID号，如果未提供ID号，则输出“未知”
</span><span style="color:#268bd2;">void </span><span style="color:#b58900;">printIDNumber</span><span style="color:#657b83;">(</span><span>std::optional</span><span style="color:#657b83;">&lt;</span><span style="color:#859900;">const </span><span style="color:#268bd2;">int</span><span style="color:#657b83;">&gt; </span><span style="color:#268bd2;">id </span><span style="color:#657b83;">=</span><span> std::nullopt</span><span style="color:#657b83;">)
</span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>id</span><span style="color:#657b83;">)
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Your ID number is </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#859900;">*</span><span>id </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">.</span><span style="color:#dc322f;">\n</span><span>&quot;; </span><span style="color:#586e75;">// 如果提供了ID，解引用并打印
</span><span>    </span><span style="color:#859900;">else
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Your ID number is not known.</span><span style="color:#dc322f;">\n</span><span>&quot;; </span><span style="color:#586e75;">// 如果没有提供ID，输出“未知”
</span><span style="color:#657b83;">}
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#b58900;">printIDNumber</span><span style="color:#657b83;">()</span><span>; </span><span style="color:#586e75;">// 我们还不知道用户的ID号
</span><span>
</span><span>    </span><span style="color:#268bd2;">int </span><span style="color:#b58900;">userid </span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">34 </span><span style="color:#657b83;">}</span><span>;
</span><span>    </span><span style="color:#b58900;">printIDNumber</span><span style="color:#657b83;">(</span><span>userid</span><span style="color:#657b83;">)</span><span>; </span><span style="color:#586e75;">// 现在我们知道用户的ID号
</span><span>
</span><span>    </span><span style="color:#b58900;">printIDNumber</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">62</span><span style="color:#657b83;">)</span><span>; </span><span style="color:#586e75;">// 我们也可以传递一个右值
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>这种用法有两个优点;</p>
<ol>
<li>它有效的说明了该参数是可选的。</li>
<li>我们以传递一个右值,因为<code>std::optional</code>会生成一个副本。</li>
</ol>
<blockquote>
<p>然而，因为 <code>std::optional</code> 会复制其参数，当 <code>T</code> 是一个复制成本高的类型（比如 <code>std::string</code> ）时，这就会变得有问题。在使用普通函数参数时，我们通过将参数改为 <code>const lvalue reference</code> 的方式来解决这个问题，这样就不会进行复制。不幸的是，截至 C++23， <code>std::optional</code> 仍然不支持引用。</p>
</blockquote>
<p><code>std::optional&lt;T&gt;</code> 适合用于小而简单的类型（如<code>int、float、enum</code>等）作为可选参数，因为它会将值直接存储在 <code>optional </code>对象内部。</p>
<ul>
<li>
<p>对于较大的对象或复杂类型（如大型结构体、类对象），按值传递（pass by value）会导致拷贝整个对象，可能影响性能。</p>
</li>
<li>
<p>当 <code>T</code> 是复杂对象时，更好的选择是使用指针（<code>const T*</code>），这样只传递对象的地址，而不是对象本身，避免了不必要的拷贝。</p>
</li>
<li>
<p><code>const T*</code> 同样可以使用 <code>nullptr</code> 表示“无值”的情况，实现可选参数的效果。</p>
</li>
</ul>
<p>因此，建议仅在通常会按值传递 <code>T</code> 时，使用 <code>std::optional&lt;T&gt;</code> 作为可选参数。否则，请使用 <code>const T*</code> 。</p>
<p><strong>最佳实践:</strong></p>
<blockquote>
<p>优先使用函数重载处理可选函数参数（如果可能）。否则，对于可选参数，使用 <code>std::optional&lt;T&gt;</code> 。如果 <code>T</code> 的复制代价高昂，请优先使用 <code>const T*</code> 。</p>
</blockquote>

      
    </div><!--./card-body-->

    <div class="card-footer">
      <div class="columns">
        <div class="column col-9 col-sm-7">
          <div class="taxonomies text-left">
            

    
          </div>
        </div><!--./col-6-->
        
        </div><!--./columns-->
    </div><!--./card-footer-->
</div><!--./card-->
</div>
              <div id="sidebar" class="column col-4 col-md-12">
                <div class="sidebar-content">
                  
                  
<div class="sidebar-widget">
  <div class="tile">
    <div class="tile-icon">
      <figure class="avatar avatar-xl">
        <img src="https://ilikexff.cn/avatar.png" alt="author avatar image">
      </figure>
    </div>
    <div class="tile-content">
      <p class="tile-title" style="font-weight: 600;">慕予</p>
      <p class="tile-subtitle">热爱编程，专注于技术分享和学习</p>
    </div>
</div><!--./tile-->
</div>

                  
                  
<div class="sidebar-widget">
  欢迎来到<strong>慕予博客</strong>！这里分享技术文章和编程心得。
</div><!-- end text widget -->

                  

                  </div><!--./sidebar-content-->
              </div>
            </div>
            
          </section>
        </section></section>
<section class="container grid-xl">
<ul class="pagination paginator">
  
  
</ul>
</section>
</div><!-- ./page-wrapper -->

    
<div class="mobile-container">
        <div class="overlay" id="overlay">
            <div style="padding: 1rem;">
              
<a class="site-logo" href="https:&#x2F;&#x2F;ilikexff.cn">
  
  <div class="col-mx-auto">
    <figure style="margin: 8px">
      <img class="img-responsive"
           style="max-height: 45px"
           alt="frontmatter image"
           src="https://ilikexff.cn/./logo.svg">
    </figure>
  </div>
  
</a>

            </div>
            <nav class="overlay-menu">
              

<ul class="tree treemenu treemenu-root"><li class="tree-empty">
      <span class="toggler"></span>
      <a href="https://ilikexff.cn/tags">标签</a>
    </li><li class="tree-empty">
      <span class="toggler"></span>
      <a href="https://ilikexff.cn/categories">分类</a>
    </li><li class="tree-empty">
      <span class="toggler"></span>
      <a href="https://ilikexff.cn/about">关于</a>
    </li></ul>


              </nav>
        </div>
    </div>

<script type="text/javascript">
  var overlay = document.getElementById('overlay');
  var toggle = document.getElementById('toggle');

  function openOverlay(){
      // Open overlay
      if (overlay.classList.contains("open")) {
          overlay.classList.remove("open");
      }
      else {
          overlay.classList.add("open");
      }

      // Button transition
      if (toggle.classList.contains("active")) {
          toggle.classList.remove("active");
      }
      else {
          toggle.classList.add("active");
      }
    }
</script>

<section id="footer" class="bg-gray">
  <div class="container grid-xl">
    


    <div class="columns">
      
      <div class="column col-6 col-lg-12 col-mx-auto" style="text-align: center;">
        简单是效率的灵魂 | 黔ICP备2021010295号
      </div>
      
      <div class="column col-6 col-lg-12 col-mx-auto" style="text-align: center;">
        Made by <a href="https://github.com/gicrisf/">gicrisf</a> -
        <strong>Zhuia</strong>&nbsp;<a href="https://github.com/gicrisf/zhuia">source code</a>
        is licensed under <a href="http://opensource.org/licenses/mit-license.php" target="_blank">MIT</a>.
      </div>
    </div>
  </div>
</section>
</body>
</html>
