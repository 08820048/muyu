+++
title = "PRD算法：听说你想凭运气抽一颗荣耀水晶?"
date = 2025-06-19
tags = ["游戏算法", "PRD", "概率", "游戏开发"]
description = "详解游戏开发中常用的伪随机分布(PRD)算法原理及其在抽奖系统中的应用"
+++





![PRD](https://images.waer.ltd/notes/PRD.jpg)

`PRD`算法全称`Pseudo-Random Distribution`。是概率分布中的一种常见算法，在游戏开发领域中很常用。

`PRD`用于控制随机事件的触发概率，使其表现得更加符合预期，相比于传统得随机数生成，`PRD`算法可以平滑得控制随机事件的触发次数，确保不会出现过于极端的情况，比如长时间未触发或者频繁触发。

> 如果你觉得它离你很远，那么举个栗子，玩“王者荣耀”的多少都知道其中有一个道具叫**荣耀水晶**，这玩意就是靠抽奖的方式获得的，而根据官方抽奖的方式与概率公布等信息来看，抽取荣耀水晶的算法大概率也是`PRD`或者它的变种算法。

在游戏中，`PRD`算法的主要应用场景包括掉落系统、抽奖系统等。这些场景下，开发者通常希望在随机事件的发生上保持某种平衡，而`PRD`算法正是为了解决这一问题。

---

## 基本原理

`PRD`算法通过调整事件发生的概率来实现分布平滑。简单来说，它会随着事件未触发的次数增加，动态提升触发的概率，直到事件发生。一旦事件触发，概率会重置为初始值，重新开始计算。

`PRD`的公式通常为：$ P(n) = \frac{1}{k-f(n)}$

其中，`P(n)` 是事件在第 `n` 次尝试时的概率，`k` 是一个常数（通常设为 1），`f(n)` 是一个随尝试次数递增的函数，用于控制概率的增长。这个公式的作用是保证随着尝试次数的增加，概率不断增大，直至事件发生。

---

##  基本实现

> 下面就以使用`PRD`算法模拟抽取荣耀水晶的方式带着各位实现一下`PRD`算法吧!

- **初始概率与递增概率**：使用`PRD`算法，逐步提高未中奖后的中奖概率。
- **保底次数**：设置一个保底的次数上限，在达到该上限时，无论当前概率如何，玩家都会中奖。

- **中奖后重置**：当玩家中奖后，概率重置为初始值，并重新开始计算。

---

```cpp
#include<iostream>
#include<cstdlib>
#include<ctime>
class PRDWithPity
{
private:
    double initialProb; // 初始中奖概率
    double increment; // 每次中奖时增加的概率
    double currentProb; // 当前中奖概率
    int pityLimit; // 保底次数
    int currentTry; // 当前抽奖次数

public:
    // 构造函数、初始化初始概率、递增概率和保底次数
    PRDWithPity (double initProb = 0.05,double inc = 0.02,int pity = 10) :
    initialProb(initProb),increment(inc),currentProb(initProb),pityLimit(pity),currentTry(0) {}

    bool draw()
    {
        currentTry++;

        // 达到保底，直接中奖
        if (currentTry >= pityLimit)
        {
            reset();
            return true;
        }

        // 生成0-1随机数
        double randNum = static_cast<double>(rand()) / RAND_MAX;

        // 如果随机数小于当前概率、表示中奖
        if (randNum < currentProb)
        {
            reset();
            return true;
        }else
        {
           currentProb += increment;
            return false;
        }
    }

    // reset函数
    void reset()
    {
        currentProb = initialProb;
        currentTry = 0;
    }
};
```

> 实现代码大致如上，没什么复杂的逻辑，关键地方也都添加了注释，这里就不再赘述了。

下面模拟测试一下看看效果

```cpp
int main()
{
    srand(static_cast<unsigned>(time(0)));  // 初始化随机数种子
    PRDWithPity prd(0.000001, 0.0000002, 360);  // 初始中奖概率0.05，每次未中奖增加0.02，保底次数10次
    for (int i = 1; i <= 365; ++i) {
        if (prd.draw()) {
            std::cout << "恭喜屏幕前这位大佬第 " << i << " 次抽中一颗[荣耀水晶]" << std::endl;
        } else {
            std::cout << "第 " << i << " 次抽奖未中奖，幸运值+1，幸运值为： "
                      << prd.getCurrentTry()
                      << "，幸运值达到360必中一颗[荣耀水晶]。" << std::endl;
        }
    }
    return 0;
}
```

> 由于我们必须保证在触发保底之前中奖的概率足够低，因此这里直接将初始中奖率设置为`0.000001`也就是十万分之一，每次抽奖后递增中奖率也不能过高，比如可以设置在`0.0000002`（百万分之一）。这样可以保证在触发保底之前你大概率是不会抽到 **荣耀水晶**的，只能通过氪金不断的获取抽奖机会，直到抽够`360`次触发保底。

**下面是本次抽奖的模拟结果:**

第 1 次抽奖未中奖，幸运值+1，幸运值为： 1，幸运值达到360必中一颗[荣耀水晶]。
第 2 次抽奖未中奖，幸运值+1，幸运值为： 2，幸运值达到360必中一颗[荣耀水晶]。
第 3 次抽奖未中奖，幸运值+1，幸运值为： 3，幸运值达到360必中一颗[荣耀水晶]。
第 4 次抽奖未中奖，幸运值+1，幸运值为： 4，幸运值达到360必中一颗[荣耀水晶]。
第 5 次抽奖未中奖，幸运值+1，幸运值为： 5，幸运值达到360必中一颗[荣耀水晶]。
第 6 次抽奖未中奖，幸运值+1，幸运值为： 6，幸运值达到360必中一颗[荣耀水晶]。
第 7 次抽奖未中奖，幸运值+1，幸运值为： 7，幸运值达到360必中一颗[荣耀水晶]。
第 8 次抽奖未中奖，幸运值+1，幸运值为： 8，幸运值达到360必中一颗[荣耀水晶]。
第 9 次抽奖未中奖，幸运值+1，幸运值为： 9，幸运值达到360必中一颗[荣耀水晶]。
第 10 次抽奖未中奖，幸运值+1，幸运值为： 10，幸运值达到360必中一颗[荣耀水晶]。
第 11 次抽奖未中奖，幸运值+1，幸运值为： 11，幸运值达到360必中一颗[荣耀水晶]。
第 12 次抽奖未中奖，幸运值+1，幸运值为： 12，幸运值达到360必中一颗[荣耀水晶]。
第 13 次抽奖未中奖，幸运值+1，幸运值为： 13，幸运值达到360必中一颗[荣耀水晶]。
第 14 次抽奖未中奖，幸运值+1，幸运值为： 14，幸运值达到360必中一颗[荣耀水晶]。

[次数省略好多行].......................

第 348 次抽奖未中奖，幸运值+1，幸运值为： 348，幸运值达到360必中一颗[荣耀水晶]。
第 349 次抽奖未中奖，幸运值+1，幸运值为： 349，幸运值达到360必中一颗[荣耀水晶]。
第 350 次抽奖未中奖，幸运值+1，幸运值为： 350，幸运值达到360必中一颗[荣耀水晶]。
第 351 次抽奖未中奖，幸运值+1，幸运值为： 351，幸运值达到360必中一颗[荣耀水晶]。
第 352 次抽奖未中奖，幸运值+1，幸运值为： 352，幸运值达到360必中一颗[荣耀水晶]。
第 353 次抽奖未中奖，幸运值+1，幸运值为： 353，幸运值达到360必中一颗[荣耀水晶]。
第 354 次抽奖未中奖，幸运值+1，幸运值为： 354，幸运值达到360必中一颗[荣耀水晶]。
第 355 次抽奖未中奖，幸运值+1，幸运值为： 355，幸运值达到360必中一颗[荣耀水晶]。
第 356 次抽奖未中奖，幸运值+1，幸运值为： 356，幸运值达到360必中一颗[荣耀水晶]。
第 357 次抽奖未中奖，幸运值+1，幸运值为： 357，幸运值达到360必中一颗[荣耀水晶]。
第 358 次抽奖未中奖，幸运值+1，幸运值为： 358，幸运值达到360必中一颗[荣耀水晶]。
第 359 次抽奖未中奖，幸运值+1，幸运值为： 359，幸运值达到360必中一颗[荣耀水晶]。
**恭喜屏幕前这位大佬第 360 次抽中一颗[荣耀水晶]**
第 361 次抽奖未中奖，幸运值+1，幸运值为： 1，幸运值达到360必中一颗[荣耀水晶]。
第 362 次抽奖未中奖，幸运值+1，幸运值为： 2，幸运值达到360必中一颗[荣耀水晶]。
第 363 次抽奖未中奖，幸运值+1，幸运值为： 3，幸运值达到360必中一颗[荣耀水晶]。
第 364 次抽奖未中奖，幸运值+1，幸运值为： 4，幸运值达到360必中一颗[荣耀水晶]。
第 365 次抽奖未中奖，幸运值+1，幸运值为： 5，幸运值达到360必中一颗[荣耀水晶]。

---

## PRD的优点

**平衡性**：`PRD`通过调整概率，使得随机事件更加平衡。例如，在掉落系统中，`PRD`确保物品不会长时间不掉落，也不会短时间内频繁掉落。

**易于控制**：开发者可以通过调节初始概率或递增函数的参数，来控制事件的发生频率和分布特性。

**提升用户体验**：`PRD`可以防止用户在面对纯粹的随机系统时感到挫败，尤其是游戏中的奖励机制，通过PRD可以避免极端运气差的情况。

当然了，算法并非一成不变的，具体实现还得基于我们在开发业务中的具体需求来决定是否对原算法进行扩展、优化、变种。

比如下面这些扩展建议：

> 1. **递增机制**：可以根据具体需求将递增值设计为动态调整，而不仅仅是固定值。
> 2. **外部配置**：如果`PRD`用于实际的游戏开发中，概率和递增值通常从外部配置表中读取，而不是硬编码在程序中。

---

## 小结

如果你不从事游戏开发相关领域工作，那么这篇文章可以帮你了解身边游戏抽奖的中奖机制和原理，在面对华丽的游戏虚拟道具抽奖时，请务必保持**理性消费**(有钱人忽略,因为本质就是来圈你们这些所谓有钱人的**RMB**滴!)代码面前，不要对自己的运气抱有过高的自信!

如果你是一个即将或者是正在从事游戏开发工作，那么学无止境，共勉!

> 这是一个连载的专题，欢迎持续关注哦！