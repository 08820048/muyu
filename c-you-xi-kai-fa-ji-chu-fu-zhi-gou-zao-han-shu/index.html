<!DOCTYPE html>
<html lang="zh" data-theme="light" dir="ltr">
  <head>
    <title>C++游戏开发基础-深入解析复制构造函数 - 八尺妖剑</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="description" content="详细介绍C++面向对象编程中的复制构造函数,包括隐式复制构造函数、显式复制构造函数等最佳实践。"/>

    <meta property="og:title" content="八尺妖剑 -&nbsp;C++游戏开发基础-深入解析复制构造函数" />
    <meta property="og:type" content="website"/><meta property="og:url" content="https:&#x2F;&#x2F;ilikexff.cn&#x2F;c-you-xi-kai-fa-ji-chu-fu-zhi-gou-zao-han-shu&#x2F;"/><meta property="og:description" content="详细介绍C++面向对象编程中的复制构造函数,包括隐式复制构造函数、显式复制构造函数等最佳实践。"/>


    <meta name="twitter:card" content="summary">


    <link rel="stylesheet" href="https://ilikexff.cn/spectre/spectre.css">
    <link rel="stylesheet" href="https://ilikexff.cn/theme.css"><link rel="stylesheet" href="https://ilikexff.cn/custom.css">
    
<link rel="shortcut icon" href="https://ilikexff.cn/./assets/bachiico.ico" type="image/x-icon" />
        
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>

    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script>
        function doRenderMath() {
            renderMathInElement(document.body, {
                delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false},
                {left: "\\(", right: "\\)", display: false},
                {left: "\\begin{equation}", right: "\\end{equation}", display: true},
                {left: "\\begin{align}", right: "\\end{align}", display: true},
                {left: "\\begin{alignat}", right: "\\end{alignat}", display: true},
                {left: "\\begin{gather}", right: "\\end{gather}", display: true},
                {left: "\\begin{CD}", right: "\\end{CD}", display: true},
                {left: "\\[", right: "\\]", display: true}
                ]
            });
        }
    </script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
        onload="doRenderMath()"></script>

      </head>
  <body id="top" class="sticky-footer"><div id="page-wrapper">
<header id="header" class="section">
  <section class="container grid-xl">
    <nav class="navbar">
      <section class="navbar-section">
        
<a class="site-logo" href="https:&#x2F;&#x2F;ilikexff.cn">
  
  <div class="col-mx-auto">
    <figure style="margin: 8px">
      <img class="img-responsive"
           style="max-height: 45px"
           alt="frontmatter image"
           src="https://ilikexff.cn/./assets/logo.png">
    </figure>
  </div>
  
</a>

      </section><!-- ./home button -->

      <section class="navbar-center hide-md"></section>

      <section class="navbar-section">
        <nav class="dropmenu animated hide-md">

<ul><li>
        <a href="https://ilikexff.cn/tags">标签</a>
    </li><li>
        <a href="https://ilikexff.cn/categories">分类</a>
    </li><li>
        <a href="https://ilikexff.cn/about">关于</a>
    </li></ul>


          <!-- 暗色模式滑动切换按钮 -->
          <div class="theme-toggle">
            <label class="theme-switch" for="theme-toggle-checkbox">
              <input type="checkbox" id="theme-toggle-checkbox" class="theme-switch-checkbox">
              <div class="theme-switch-slider">
                <div class="theme-switch-handle">
                  <svg class="sun-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                    <circle cx="12" cy="12" r="5"></circle>
                    <line x1="12" y1="1" x2="12" y2="3"></line>
                    <line x1="12" y1="21" x2="12" y2="23"></line>
                    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                    <line x1="1" y1="12" x2="3" y2="12"></line>
                    <line x1="21" y1="12" x2="23" y2="12"></line>
                    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                  </svg>
                  <svg class="moon-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                  </svg>
                </div>
              </div>
            </label>
          </div>

          <!-- 暗色模式切换脚本 -->
          <script>
            (function() {
              'use strict';

              // 主题管理
              function initTheme() {
                const savedTheme = localStorage.getItem('theme');
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                const theme = savedTheme || (prefersDark ? 'dark' : 'light');
                setTheme(theme, false);
              }

              function setTheme(theme, animate = true) {
                const html = document.documentElement;
                const checkbox = document.getElementById('theme-toggle-checkbox');

                if (animate) {
                  html.style.transition = 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
                  setTimeout(() => { html.style.transition = ''; }, 400);
                }

                if (theme === 'dark') {
                  html.setAttribute('data-theme', 'dark');
                  if (checkbox) checkbox.checked = true;
                } else {
                  html.removeAttribute('data-theme');
                  if (checkbox) checkbox.checked = false;
                }

                localStorage.setItem('theme', theme);
              }

              function toggleTheme() {
                const currentTheme = document.documentElement.getAttribute('data-theme');
                setTheme(currentTheme === 'dark' ? 'light' : 'dark');
              }

              // 初始化
              if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initTheme);
              } else {
                initTheme();
              }

              // 绑定事件
              document.addEventListener('DOMContentLoaded', function() {
                const checkbox = document.getElementById('theme-toggle-checkbox');
                if (checkbox) {
                  checkbox.addEventListener('change', toggleTheme);
                }

                // 键盘快捷键
                document.addEventListener('keydown', function(e) {
                  if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'D') {
                    e.preventDefault();
                    toggleTheme();
                  }
                });
              });
            })();
          </script>
        </nav>
      </section><!-- ./desktop-menu -->
    </nav>
  </section><!-- ./container -->
</header>


<div class="mobile-menu">
  <div class="button_container" id="toggle" onclick="openOverlay()">
    <span class="top"></span>
    <span class="middle"></span>
    <span class="bottom"></span>
  </div>
</div><!--./mobile-menu-->


<section id="start"><section id="body-wrapper" class="section">
          <section class="container grid-xl">
<div id="breadcrumbs" itemtype="http://schema.org/BreadcrumbList" class="hide-sm">
  
    
    <span><a href="https:&#x2F;&#x2F;ilikexff.cn&#x2F;">Home</a></span>
  
    <span><a href="https:&#x2F;&#x2F;ilikexff.cn&#x2F;c-you-xi-kai-fa-ji-chu-fu-zhi-gou-zao-han-shu&#x2F;">C++游戏开发基础-深入解析复制构造函数</a></span>
</div>
<div class="columns">
              <div id="item" class="column col-8 col-md-12 extra-spacing">
<div class="card">
  

    <div class="card-header">
      <div class="card-title" style="margin-top: .25rem;"><div>
          <h1 class="post-title">C++游戏开发基础-深入解析复制构造函数</h1>
          
    <div class="post-meta" style="display: inline-flex">
        <span class="blog-date" style="display: inline-flex;">
          <i class="gg-calendar" style="margin-right: 5px;"></i><time datetime="2024.12.15">
          2024.12.15
          </time></span><span class="post-author" style="margin-left: 5px; display: inline-flex;">
          - 
    八尺妖剑
        </span></div>

        </div></div>
    </div><!--./card-header-->

    <div class="card-body">
      
        <p>考虑下面程序:</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Fraction
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#268bd2;">int m_numerator</span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">0 </span><span style="color:#657b83;">}</span><span>;
</span><span>    </span><span style="color:#268bd2;">int m_denominator</span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">1 </span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#586e75;">// Default constructor
</span><span>    </span><span style="color:#b58900;">Fraction</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int numerator</span><span style="color:#657b83;">=</span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#268bd2;">int denominator</span><span style="color:#657b83;">=</span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">)
</span><span>        : </span><span style="color:#268bd2;">m_numerator</span><span style="color:#657b83;">{</span><span>numerator</span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_denominator</span><span style="color:#657b83;">{</span><span>denominator</span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#268bd2;">void </span><span style="color:#b58900;">print</span><span style="color:#657b83;">() </span><span style="color:#859900;">const
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Fraction(</span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_numerator </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">, </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_denominator </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">)</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    Fraction </span><span style="color:#b58900;">f </span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">5</span><span>, </span><span style="color:#6c71c4;">3 </span><span style="color:#657b83;">}</span><span>;  </span><span style="color:#586e75;">// 1
</span><span>    Fraction </span><span style="color:#268bd2;">fCopy </span><span style="color:#657b83;">{</span><span> f </span><span style="color:#657b83;">}</span><span>; </span><span style="color:#586e75;">// 2
</span><span>
</span><span>    f.</span><span style="color:#b58900;">print</span><span style="color:#657b83;">()</span><span>;
</span><span>    </span><span style="color:#268bd2;">fCopy</span><span>.</span><span style="color:#b58900;">print</span><span style="color:#657b83;">()</span><span>;
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>在上面的代码中,除了一系列熟悉的配方之外,我们还发现在25行有一行之前没见过的代码,就是你想的那样,这个就是本文的主角-复制构造函数。 </p>
<p>复制构造函数也是一种构造函数(有一种听君一席话的感觉😊)。用于使用相同类型的现有对象初始化对象,在复制构造函数执行之后,在复制构造函数执行完后，新对象应该是传入的已有对象的副本（拷贝）。</p>
<hr />
<h2 id="yin-shi-fu-zhi-gou-zao-han-shu">隐式复制构造函数<a class="zola-anchor" href="#yin-shi-fu-zhi-gou-zao-han-shu" aria-label="Anchor link for: yin-shi-fu-zhi-gou-zao-han-shu">🔗</a></h2>
<p>如果你没有为你的类提供复制构造函数，C++将为你创建一个公共<strong>隐式复制构造函数</strong> 。在上面的示例中，语句 <code>Fraction fCopy { f };</code> 调用隐式复制构造函数来用 <code>f</code> 初始化 <code>fCopy</code>。</p>
<p>默认情况下，隐式复制构造函数将进行成员初始化。这意味着每个成员都将使用传入的类的相应成员作为初始化器进行初始化。在上例中，<code>fCopy.m_numerator</code> 使用 <code>f.m_numerator</code>（值为 <code>5</code>）初始化，<code>fCopy.m_denominator</code> 使用 <code>f.m_denominator</code>（值为 <code>3</code>）初始化。</p>
<p>在执行复制构造函数之后，<code>f</code> 和 <code>fCopy</code> 的成员具有相同的值，因此 <code>fCopy</code> 是 <code>f</code> 的副本。因此，调用 <code>print（）在</code>任何一个上都有相同的结果。</p>
<hr />
<h2 id="xian-shi-ding-yi-zi-ji-de-fu-zhi-gou-zao-han-shu">显式定义自己的复制构造函数<a class="zola-anchor" href="#xian-shi-ding-yi-zi-ji-de-fu-zhi-gou-zao-han-shu" aria-label="Anchor link for: xian-shi-ding-yi-zi-ji-de-fu-zhi-gou-zao-han-shu">🔗</a></h2>
<p>我们也可以显式的定义自己的复制构造函数。比如下面的示例中,我们将在自己定义的复制构造函数中打印一条消息,以便于提示我们,自己定义的复制构造函数被成功调用。 </p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include</span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Fraction
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_numberator </span><span style="color:#657b83;">{</span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">}</span><span>;
</span><span>    </span><span style="color:#268bd2;">int</span><span> m_denominator </span><span style="color:#657b83;">{</span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">}</span><span>;
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#b58900;">Fraction</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int numerator </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#268bd2;">int denominator </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">)
</span><span>    :</span><span style="color:#268bd2;">m_numberator</span><span style="color:#657b83;">{</span><span>numerator</span><span style="color:#657b83;">}
</span><span>    ,</span><span style="color:#268bd2;">m_denominator</span><span style="color:#657b83;">{</span><span>denominator</span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">{}
</span><span>
</span><span>    </span><span style="color:#586e75;">// 复制构造函数
</span><span>    </span><span style="color:#b58900;">Fraction</span><span style="color:#657b83;">(</span><span style="color:#859900;">const</span><span> Fraction</span><span style="color:#859900;">&amp; </span><span style="color:#268bd2;">fraction</span><span style="color:#657b83;">)
</span><span>    :</span><span style="color:#268bd2;">m_numberator</span><span style="color:#657b83;">{</span><span>fraction.</span><span style="color:#268bd2;">m_numberator</span><span style="color:#657b83;">}
</span><span>    ,</span><span style="color:#268bd2;">m_denominator</span><span style="color:#657b83;">{</span><span>fraction.</span><span style="color:#268bd2;">m_denominator</span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt;</span><span>&quot;</span><span style="color:#2aa198;">Copy constructor called</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#268bd2;">void </span><span style="color:#b58900;">print</span><span style="color:#657b83;">()
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt;</span><span>&quot;</span><span style="color:#2aa198;">Fraction(</span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_numberator </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">,</span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_denominator </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">)</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    Fraction </span><span style="color:#b58900;">f </span><span style="color:#657b83;">{</span><span style="color:#6c71c4;">5</span><span>,</span><span style="color:#6c71c4;">3</span><span style="color:#657b83;">}</span><span>;
</span><span>    Fraction </span><span style="color:#268bd2;">fCopy</span><span style="color:#657b83;">{</span><span>f</span><span style="color:#657b83;">}</span><span>; </span><span style="color:#586e75;">// 复制构造函数
</span><span>
</span><span>    f.</span><span style="color:#b58900;">print</span><span style="color:#657b83;">()</span><span>;
</span><span>    </span><span style="color:#268bd2;">fCopy</span><span>.</span><span style="color:#b58900;">print</span><span style="color:#657b83;">()</span><span>;
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span><span>
</span></code></pre>
<p><img src="https://images.waer.ltd/notes/202503241659794.png" alt="image-20250324165906674" /></p>
<p><strong>提醒⏰</strong></p>
<blockquote>
<p>访问控制是 <strong>基于类</strong>而不是 <strong>基于对象</strong>的。这意味着,同一个类的成员函数可以访问任意该类对象的私有成员（不仅仅是当前对象 this 的私有成员）。</p>
<p>在上面的 Fraction 复制构造函数中，我们利用了这一特性，直接访问了 fraction 参数的私有成员。否则，我们将无法直接访问这些成员（除非添加访问函数，但这里显然没那个必要）。</p>
</blockquote>
<p><strong>最佳实践</strong></p>
<blockquote>
<ul>
<li>复制构造函数不应该做除了复制以外的其他工作。</li>
<li>除非你有特定必要的理由创建自己的复制构造函数,否则请首选使用隐式复制构造函数。</li>
</ul>
</blockquote>
<hr />
<h2 id="fu-zhi-gou-zao-han-shu-de-can-shu-bi-xu-shi-yin-yong-lei-xing">复制构造函数的参数必须是引用类型<a class="zola-anchor" href="#fu-zhi-gou-zao-han-shu-de-can-shu-bi-xu-shi-yin-yong-lei-xing" aria-label="Anchor link for: fu-zhi-gou-zao-han-shu-de-can-shu-bi-xu-shi-yin-yong-lei-xing">🔗</a></h2>
<ul>
<li>当一个对象 <strong>按值传递（pass by value）</strong> 时，函数参数会接收到 <strong>原始对象的副本</strong>，而不是直接操作原对象。如果传递的对象与参数是 <strong>相同的类类型</strong>，那么<strong>复制过程</strong>是通过 <strong>隐式调用拷贝构造函数（copy constructor）</strong> 来完成的。</li>
</ul>
<p>看个例子:</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Fraction
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#268bd2;">int m_numerator</span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">0 </span><span style="color:#657b83;">}</span><span>;   </span><span style="color:#586e75;">// 分子，默认为 0
</span><span>    </span><span style="color:#268bd2;">int m_denominator</span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">1 </span><span style="color:#657b83;">}</span><span>; </span><span style="color:#586e75;">// 分母，默认为 1
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#586e75;">// 默认构造函数（带默认参数）
</span><span>    </span><span style="color:#b58900;">Fraction</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int numerator </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#268bd2;">int denominator </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">)
</span><span>        : </span><span style="color:#268bd2;">m_numerator</span><span style="color:#657b83;">{</span><span> numerator </span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_denominator</span><span style="color:#657b83;">{</span><span> denominator </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#586e75;">// 拷贝构造函数
</span><span>    </span><span style="color:#b58900;">Fraction</span><span style="color:#657b83;">(</span><span style="color:#859900;">const</span><span> Fraction</span><span style="color:#859900;">&amp; </span><span style="color:#268bd2;">fraction</span><span style="color:#657b83;">)
</span><span>        : </span><span style="color:#268bd2;">m_numerator</span><span style="color:#657b83;">{</span><span> fraction.</span><span style="color:#268bd2;">m_numerator </span><span style="color:#657b83;">}  </span><span style="color:#586e75;">// 复制分子
</span><span>        , </span><span style="color:#268bd2;">m_denominator</span><span style="color:#657b83;">{</span><span> fraction.</span><span style="color:#268bd2;">m_denominator </span><span style="color:#657b83;">}  </span><span style="color:#586e75;">// 复制分母
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">复制构造函数被调用</span><span style="color:#dc322f;">\n</span><span>&quot;;  </span><span style="color:#586e75;">// 输出信息，确认拷贝构造函数被调用
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#586e75;">// 打印分数
</span><span>    </span><span style="color:#268bd2;">void </span><span style="color:#b58900;">print</span><span style="color:#657b83;">() </span><span style="color:#859900;">const
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Fraction(</span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_numerator </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">, </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_denominator </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">)</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#586e75;">// 按值传递 Fraction 对象（会调用拷贝构造函数）
</span><span style="color:#268bd2;">void </span><span style="color:#b58900;">printFraction</span><span style="color:#657b83;">(</span><span>Fraction </span><span style="color:#268bd2;">f</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// f 按值传递，会创建副本
</span><span style="color:#657b83;">{
</span><span>    f.</span><span style="color:#b58900;">print</span><span style="color:#657b83;">()</span><span>; </span><span style="color:#586e75;">// 调用 Fraction 类的 print() 方法
</span><span style="color:#657b83;">}
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    Fraction </span><span style="color:#b58900;">f</span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">5</span><span>, </span><span style="color:#6c71c4;">3 </span><span style="color:#657b83;">}</span><span>; </span><span style="color:#586e75;">// 创建 Fraction 对象 f，调用普通构造函数
</span><span>
</span><span>    </span><span style="color:#b58900;">printFraction</span><span style="color:#657b83;">(</span><span>f</span><span style="color:#657b83;">)</span><span>; </span><span style="color:#586e75;">// 传递 f 到 printFraction 函数，按值传递，会调用拷贝构造函数
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span><span>
</span></code></pre>
<p>在上面的例子中，对 <code>printFraction（f）</code> 的调用是通过值传递 <code>f</code>。调用复制构造函数将 <code>f</code> 从 <code>main</code> 复制到函数 <code>printFraction（）</code> 的 <code>f</code> 参数中。</p>
<p>在 C++ 中，<strong>拷贝构造函数（Copy Constructor）的参数必须是</strong> const <strong>引用</strong>，不能按值传递，否则会导致 <strong>无限递归</strong>，最终导致 <strong>栈溢出（stack overflow）</strong>。</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#268bd2;">class </span><span style="color:#b58900;">MyClass
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#b58900;">MyClass</span><span style="color:#657b83;">(</span><span>MyClass </span><span style="color:#268bd2;">obj</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// ❌ 错误：按值传递拷贝构造函数
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Copy Constructor Called</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span></code></pre>
<blockquote>
<p>当你尝试创建一个新对象（例如 MyClass obj2 = obj1;），编译器会这样做：</p>
<ol>
<li>obj1 需要被<strong>复制</strong>到 obj 这个参数中（因为按值传递）。</li>
<li>但 obj 也是一个 MyClass 类型的对象，所以需要调用 <strong>拷贝构造函数</strong> 来复制 obj1。</li>
<li><strong>调用拷贝构造函数时，又要传递 obj 这个参数（按值传递）</strong>，因此：
<ol>
<li><strong>又会调用拷贝构造函数</strong></li>
<li><strong>拷贝构造函数又需要传递 obj</strong></li>
<li><strong>进入无限递归的调用链</strong></li>
</ol>
</li>
<li>最终 <strong>栈溢出（Stack Overflow）</strong>，程序崩溃。</li>
</ol>
</blockquote>
<hr />
<p>如果一个类没有复制构造函数，编译器将隐式地为我们生成一个。如果我们愿意，我们可以显式地告诉编译器使用 <code>= default</code> 语法为我们创建一个默认的复制构造函数：</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Fraction
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#268bd2;">int m_numerator</span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">0 </span><span style="color:#657b83;">}</span><span>;
</span><span>    </span><span style="color:#268bd2;">int m_denominator</span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">1 </span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#586e75;">// 默认构造函数
</span><span>    </span><span style="color:#b58900;">Fraction</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int numerator</span><span style="color:#657b83;">=</span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#268bd2;">int denominator</span><span style="color:#657b83;">=</span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">)
</span><span>        : </span><span style="color:#268bd2;">m_numerator</span><span style="color:#657b83;">{</span><span>numerator</span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_denominator</span><span style="color:#657b83;">{</span><span>denominator</span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    
</span><span>    </span><span style="color:#b58900;">Fraction</span><span style="color:#657b83;">(</span><span style="color:#859900;">const</span><span> Fraction</span><span style="color:#859900;">&amp; </span><span style="color:#268bd2;">fraction</span><span style="color:#657b83;">) = </span><span style="color:#859900;">default</span><span>;
</span><span>
</span><span>    </span><span style="color:#268bd2;">void </span><span style="color:#b58900;">print</span><span style="color:#657b83;">() </span><span style="color:#859900;">const
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Fraction(</span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_numerator </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">, </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_denominator </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">)</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    Fraction </span><span style="color:#b58900;">f </span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">5</span><span>, </span><span style="color:#6c71c4;">3 </span><span style="color:#657b83;">}</span><span>;
</span><span>    Fraction </span><span style="color:#268bd2;">fCopy </span><span style="color:#657b83;">{</span><span> f </span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span>    f.</span><span style="color:#b58900;">print</span><span style="color:#657b83;">()</span><span>;
</span><span>    </span><span style="color:#268bd2;">fCopy</span><span>.</span><span style="color:#b58900;">print</span><span style="color:#657b83;">()</span><span>;
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<hr />
<h2 id="shi-yong-deletefang-zhi-fu-zhi">使用 <code>=delete</code>防止复制<a class="zola-anchor" href="#shi-yong-deletefang-zhi-fu-zhi" aria-label="Anchor link for: shi-yong-deletefang-zhi-fu-zhi">🔗</a></h2>
<p>有时候我们会遇到这样的需求,我们不希望某个类的对象是可以复制的,我们可以通过使用<code>=delete</code>来将复制构造函数标记为删除以实现该需求。</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Fraction
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#268bd2;">int m_numerator</span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">0 </span><span style="color:#657b83;">}</span><span>;
</span><span>    </span><span style="color:#268bd2;">int m_denominator</span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">1 </span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#586e75;">// Default constructor
</span><span>    </span><span style="color:#b58900;">Fraction</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int numerator</span><span style="color:#657b83;">=</span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#268bd2;">int denominator</span><span style="color:#657b83;">=</span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">)
</span><span>        : </span><span style="color:#268bd2;">m_numerator</span><span style="color:#657b83;">{</span><span>numerator</span><span style="color:#657b83;">}</span><span>, </span><span style="color:#268bd2;">m_denominator</span><span style="color:#657b83;">{</span><span>denominator</span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#586e75;">// 删除复制构造函数 无法再复制
</span><span>    </span><span style="color:#b58900;">Fraction</span><span style="color:#657b83;">(</span><span style="color:#859900;">const</span><span> Fraction</span><span style="color:#859900;">&amp; </span><span style="color:#268bd2;">fraction</span><span style="color:#657b83;">) = </span><span style="color:#859900;">delete</span><span>;
</span><span>
</span><span>    </span><span style="color:#268bd2;">void </span><span style="color:#b58900;">print</span><span style="color:#657b83;">() </span><span style="color:#859900;">const
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Fraction(</span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_numerator </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">, </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_denominator </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">)</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    Fraction </span><span style="color:#b58900;">f </span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">5</span><span>, </span><span style="color:#6c71c4;">3 </span><span style="color:#657b83;">}</span><span>;
</span><span>    Fraction </span><span style="color:#268bd2;">fCopy </span><span style="color:#657b83;">{</span><span> f </span><span style="color:#657b83;">}</span><span>; </span><span style="color:#586e75;">//编译错误
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>在这个例子中，当编译器去寻找一个构造函数来用 <code>f</code> 初始化 <code>fCopy</code> 时，它会发现复制构造函数已经被删除了。这将导致它发出编译错误。</p>
<blockquote>
<p>通常，C++ 类的 <strong>拷贝构造函数</strong> 是 public 的，这样外部代码（例如按值传递对象、对象赋值等）可以正常复制对象。但如果你 <strong>不希望对象被随意复制</strong>，可以将拷贝构造函数设为 private，这样就无法在类外部进行复制。</p>
<p>然而，这样做有一个例外：<strong>类的成员函数仍然可以访问私有拷贝构造函数</strong>，所以如果你的类内部有某些代码仍然需要复制对象，这个方法就不适合。</p>
</blockquote>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">NonCopyable
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">private</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#586e75;">// 私有拷贝构造函数，防止外部复制
</span><span>    </span><span style="color:#b58900;">NonCopyable</span><span style="color:#657b83;">(</span><span style="color:#859900;">const</span><span> NonCopyable</span><span style="color:#859900;">&amp; </span><span style="color:#268bd2;">other</span><span style="color:#657b83;">) 
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">拷贝构造函数被调用</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#586e75;">// 默认构造函数
</span><span>    </span><span style="color:#b58900;">NonCopyable</span><span style="color:#657b83;">() 
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">默认构造函数被调用</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#268bd2;">void </span><span style="color:#b58900;">show</span><span style="color:#657b83;">() </span><span style="color:#859900;">const 
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">我是一个 NonCopyable 对象</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    NonCopyable obj1; </span><span style="color:#586e75;">// ✅ 调用默认构造函数
</span><span>
</span><span>    </span><span style="color:#586e75;">// NonCopyable obj2 = obj1; // ❌ 这里会报错，因为拷贝构造函数是 private 的
</span><span>    </span><span style="color:#586e75;">// printNonCopyable(obj1);  // ❌ 这里也会报错，按值传递需要拷贝
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<hr />
<h2 id="lei-chu-shi-hua-he-fu-zhi-sheng-lue">类初始化和复制省略<a class="zola-anchor" href="#lei-chu-shi-hua-he-fu-zhi-sheng-lue" aria-label="Anchor link for: lei-chu-shi-hua-he-fu-zhi-sheng-lue">🔗</a></h2>
<p>先回顾一下具有基本数据类型的对象的6种基本初始化方式:</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#268bd2;">int</span><span> a;         </span><span style="color:#586e75;">// 没有初始化器（默认初始化）  
</span><span style="color:#268bd2;">int</span><span> b </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">5</span><span>;     </span><span style="color:#586e75;">// 在等号后使用初始化器（拷贝初始化）  
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">c</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">6</span><span style="color:#657b83;">)</span><span>;      </span><span style="color:#586e75;">// 使用括号内的初始化器（直接初始化）  
</span><span>
</span><span style="color:#586e75;">// 列表初始化方法（C++11）  
</span><span style="color:#268bd2;">int</span><span> d </span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">7 </span><span style="color:#657b83;">}</span><span>;   </span><span style="color:#586e75;">// 使用大括号的初始化器（直接列表初始化）  
</span><span style="color:#268bd2;">int</span><span> e </span><span style="color:#657b83;">= { </span><span style="color:#6c71c4;">8 </span><span style="color:#657b83;">}</span><span>; </span><span style="color:#586e75;">// 在等号后使用大括号的初始化器（拷贝列表初始化）  
</span><span style="color:#268bd2;">int</span><span> f </span><span style="color:#657b83;">{}</span><span>;      </span><span style="color:#586e75;">// 初始化器为空的大括号（值初始化）  
</span></code></pre>
<p>所有这些初始化类型对于具有类类型的对象都是有效的：</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include </span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Foo
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>
</span><span>    </span><span style="color:#586e75;">// 默认构造函数（无参数）
</span><span>    </span><span style="color:#b58900;">Foo</span><span style="color:#657b83;">()
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Foo()</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#586e75;">// 普通构造函数（带一个 int 参数）
</span><span>    </span><span style="color:#b58900;">Foo</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int x</span><span style="color:#657b83;">)
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Foo(int) </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt;</span><span> x </span><span style="color:#657b83;">&lt;&lt; </span><span>&#39;</span><span style="color:#dc322f;">\n</span><span>&#39;;
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#586e75;">// 拷贝构造函数（用于复制已有对象）
</span><span>    </span><span style="color:#b58900;">Foo</span><span style="color:#657b83;">(</span><span style="color:#859900;">const</span><span> Foo</span><span style="color:#859900;">&amp;</span><span style="color:#657b83;">)
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Foo(const Foo&amp;)</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#586e75;">// 调用 Foo() 默认构造函数
</span><span>    Foo f1;           </span><span style="color:#586e75;">// 默认初始化
</span><span>    Foo </span><span style="color:#b58900;">f2</span><span style="color:#657b83;">{}</span><span>;         </span><span style="color:#586e75;">// 值初始化（推荐）
</span><span>
</span><span>    </span><span style="color:#586e75;">// 调用 Foo(int) 普通构造函数
</span><span>    Foo f3 </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">3</span><span>;       </span><span style="color:#586e75;">// 拷贝初始化（仅适用于非 explicit 构造函数）
</span><span>    Foo </span><span style="color:#b58900;">f4</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">4</span><span style="color:#657b83;">)</span><span>;        </span><span style="color:#586e75;">// 直接初始化
</span><span>    Foo </span><span style="color:#b58900;">f5</span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">5 </span><span style="color:#657b83;">}</span><span>;      </span><span style="color:#586e75;">// 直接列表初始化（推荐）
</span><span>    Foo f6 </span><span style="color:#657b83;">= { </span><span style="color:#6c71c4;">6 </span><span style="color:#657b83;">}</span><span>;   </span><span style="color:#586e75;">// 拷贝列表初始化（仅适用于非 explicit 构造函数）
</span><span>
</span><span>    </span><span style="color:#586e75;">// 调用 Foo(const Foo&amp;) 拷贝构造函数
</span><span>    Foo f7 </span><span style="color:#657b83;">=</span><span> f3;      </span><span style="color:#586e75;">// 拷贝初始化
</span><span>    Foo </span><span style="color:#b58900;">f8</span><span style="color:#657b83;">(</span><span>f3</span><span style="color:#657b83;">)</span><span>;       </span><span style="color:#586e75;">// 直接初始化
</span><span>    Foo </span><span style="color:#b58900;">f9</span><span style="color:#657b83;">{</span><span> f3 </span><span style="color:#657b83;">}</span><span>;     </span><span style="color:#586e75;">// 直接列表初始化（推荐）
</span><span>    Foo f10 </span><span style="color:#657b83;">= {</span><span> f3 </span><span style="color:#657b83;">}</span><span>; </span><span style="color:#586e75;">// 拷贝列表初始化
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>在现代C++中,复制初始化、直接初始化和列表初始化的本质做的都是同一件事: <strong>初始化一个对象</strong>。</p>
<p>对于所有类型的初始化:</p>
<ul>
<li>初始化类类型时,将检查该类的构造函数集,并使用重载解析来确定最佳匹配的构造函数。这可能涉及参数的隐式转换。</li>
<li>初始化非类类型时,编译器会使用<strong>隐式转换规则</strong>来检查是否可以将提供的值转换为目标类型。</li>
</ul>
<blockquote>
<p>同样值得注意的是，在某些情况下，某些形式的初始化是不允许的（例如，在构造函数成员初始化列表中，我们只能使用直接形式的初始化，而不能复制初始化）。</p>
</blockquote>
<hr />
<h2 id="bu-bi-yao-de-fu-zhi">不必要的复制<a class="zola-anchor" href="#bu-bi-yao-de-fu-zhi" aria-label="Anchor link for: bu-bi-yao-de-fu-zhi">🔗</a></h2>
<p>考虑下面的程序:</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#cb4b16;">#include</span><span>&lt;</span><span style="color:#2aa198;">iostream</span><span>&gt;
</span><span>
</span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Something
</span><span style="color:#657b83;">{
</span><span>  </span><span style="color:#268bd2;">int</span><span> m_x </span><span style="color:#657b83;">{}</span><span>;
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#b58900;">Something</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int x</span><span style="color:#657b83;">) </span><span>: </span><span style="color:#268bd2;">m_x</span><span style="color:#657b83;">{</span><span>x</span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt;</span><span>&quot;</span><span style="color:#2aa198;">Normal constructor called</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#b58900;">Something</span><span style="color:#657b83;">(</span><span style="color:#859900;">const</span><span> Something</span><span style="color:#859900;">&amp; </span><span style="color:#268bd2;">s</span><span style="color:#657b83;">)</span><span>:</span><span style="color:#268bd2;">m_x </span><span style="color:#657b83;">{</span><span>s.</span><span style="color:#268bd2;">m_x</span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Copy constructor</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#268bd2;">void </span><span style="color:#b58900;">print</span><span style="color:#657b83;">() </span><span style="color:#859900;">const
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Something(</span><span>&quot; </span><span style="color:#657b83;">&lt;&lt; </span><span style="color:#268bd2;">m_x </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">)</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    Something </span><span style="color:#b58900;">s </span><span style="color:#657b83;">{</span><span style="color:#b58900;">Something </span><span style="color:#657b83;">{</span><span style="color:#6c71c4;">6</span><span style="color:#657b83;">} }</span><span>;
</span><span>    s.</span><span style="color:#b58900;">print</span><span style="color:#657b83;">()</span><span>;
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#657b83;">}
</span><span>
</span></code></pre>
<p>在上面的变量<code>s</code>的初始化中,我们首先构造一个临时的<code>Something</code>,初始化值为<code>6</code>. 然后使用这个临时变量来初始化<code>s</code>  ,因为临时对象和 <code>s</code> 具有相同的类型（它们都是 <code>Something</code> 对象），所以这里通常会调用 <code>Something（const Something）</code> 复制构造函数来将临时对象中的值复制到 <code>s</code> 中。最终结果是 <code>s</code> 被初始化为值 <code>6</code>。</p>
<p>在<strong>没有任何优化</strong>的情况下,上面的程序将会打印:</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>Normal </span><span style="color:#b58900;">constructor
</span><span style="color:#b58900;">Copy constructor
</span><span style="color:#b58900;">Something</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">5</span><span style="color:#657b83;">)
</span></code></pre>
<p>然而，这个程序是不必要的低效率，因为我们必须进行两次构造函数调用：一次是对 Something（int），另一次是对 <code>Something（const Something&amp;）</code>。请注意，上面的最终结果与我们编写以下代码的结果相同：</p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>Something s </span><span style="color:#657b83;">{ </span><span style="color:#6c71c4;">5 </span><span style="color:#657b83;">}</span><span>; 
</span></code></pre>
<hr />
<h2 id="fu-zhi-xiao-chu">复制消除<a class="zola-anchor" href="#fu-zhi-xiao-chu" aria-label="Anchor link for: fu-zhi-xiao-chu">🔗</a></h2>
<p>由于编译器可以自由地重写语句来优化它们，人们可能会想，编译器是否可以优化掉不必要的副本，并将 <code>Something s { Something{5} }</code> 视为我们最终的写法。</p>
<p>答案是肯定的，这样做的过程被称为<em>复制省略</em> 。 <strong>复制省略</strong>是一种编译器优化技术，它允许编译器删除不必要的对象复制。</p>
<p>换句话说，在编译器通常会调用复制构造函数的情况下，编译器可以自由地重写代码以完全避免对复制构造函数的调用。当编译器优化掉对复制构造函数的调用时，我们说该构造函数已被<strong>省略</strong> 。</p>
<p>与其他类型的优化不同，复制省略不受“as-if”规则的约束。也就是说，允许复制省略来省略复制构造函数，即使复制构造函数还会执行其他任务。</p>
<p>这就是前面为什么说 <strong>复制构造函数不应该存在除复制功能之外其他操作</strong>的原因。 </p>
<p>所以上面的程序如果在C++17环境下编译,那么你的打印将和我一样:</p>
<p><img src="https://images.waer.ltd/notes/202503241758804.png" alt="image-20250324175809736" /></p>
<hr />
<h2 id="c-17-zhong-de-qiang-zhi-fu-zhi-sheng-lue"><strong>C++17 中的强制复制省略</strong><a class="zola-anchor" href="#c-17-zhong-de-qiang-zhi-fu-zhi-sheng-lue" aria-label="Anchor link for: c-17-zhong-de-qiang-zhi-fu-zhi-sheng-lue">🔗</a></h2>
<p>在 <code>C++</code>17 之前，复制省略是编译器可以进行的严格的可选优化。在 <code>C++17</code> 中，复制省略在某些情况下是强制性的。在这些情况下，复制省略将自动执行（即使您告诉编译器不要执行复制省略）。</p>
<ul>
<li>在可选的省略情况下，可访问的复制构造函数必须可用（例如未删除），即使对复制构造函数的实际调用被省略。</li>
<li>在强制省略的情况下，可访问的复制构造函数不需要可用（换句话说，即使删除了复制构造函数，也会发生强制省略）。</li>
</ul>
<hr />
<h2 id="ti-yi-zui-explict">提一嘴explict<a class="zola-anchor" href="#ti-yi-zui-explict" aria-label="Anchor link for: ti-yi-zui-explict">🔗</a></h2>
<p>在 <code>C++</code> 中，<code>explicit</code> 关键字用于修饰<strong>构造函数</strong>和<strong>转换运算符</strong>，它的主要作用是<strong>防止隐式转换</strong>，确保类的对象不会被意外地从其他类型的值隐式构造。</p>
<ul>
<li><strong>默认情况下，应该将所有接受单个参数的构造函数声明为 explicit。</strong>
<ul>
<li>这样可以防止<strong>隐式类型转换</strong>，避免意外的类型转换导致的错误。</li>
</ul>
</li>
<li><strong>如果某种类型转换在语义上是合理的，并且性能上没有问题，则可以考虑不使用 explicit，允许隐式转换。</strong>
<ul>
<li>例如，如果类 <code>String</code> 有一个接受 <code>const char*</code> 的构造函数，并且允许从 <code>const char*</code> 隐式转换为 <code>String</code> 是合理的，可以去掉 <code>explicit</code>。</li>
</ul>
</li>
<li><strong>不要将拷贝构造函数或移动构造函数声明为 explicit，因为它们并不会进行类型转换。</strong>
<ul>
<li>拷贝构造<code>（T(const T&amp;)）</code>和移动构造（<code>T(T&amp;&amp;)）</code>的作用是复制或移动相同类型的对象，而不是进行类型转换，因此不应该加 <code>explicit</code>，否则会影响对象的正常复制和移动操作。</li>
</ul>
</li>
</ul>
<p>示例:</p>
<p><strong>✅ 正确：使用 explicit 防止隐式转换</strong></p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#268bd2;">class </span><span style="color:#b58900;">Foo
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#859900;">explicit </span><span style="color:#b58900;">Foo</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int x</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// ✅ 默认加 explicit，防止隐式转换
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">Foo(int) called with </span><span>&quot; </span><span style="color:#657b83;">&lt;&lt;</span><span> x </span><span style="color:#657b83;">&lt;&lt; </span><span>&#39;</span><span style="color:#dc322f;">\n</span><span>&#39;;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">void </span><span style="color:#b58900;">printFoo</span><span style="color:#657b83;">(</span><span>Foo </span><span style="color:#268bd2;">f</span><span style="color:#657b83;">) {}
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    Foo f1 </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">10</span><span>; </span><span style="color:#586e75;">// ❌ 编译错误：explicit 禁止了隐式转换
</span><span>    Foo </span><span style="color:#b58900;">f2</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">10</span><span style="color:#657b83;">)</span><span>;  </span><span style="color:#586e75;">// ✅ 直接初始化可以
</span><span>    </span><span style="color:#b58900;">printFoo</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">10</span><span style="color:#657b83;">)</span><span>; </span><span style="color:#586e75;">// ❌ 编译错误，无法从 int 隐式转换为 Foo
</span><span style="color:#657b83;">}
</span></code></pre>
<p><strong>✅ 合理去掉 explicit 允许隐式转换</strong></p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#268bd2;">class </span><span style="color:#b58900;">String
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#b58900;">String</span><span style="color:#657b83;">(</span><span style="color:#859900;">const </span><span style="color:#268bd2;">char</span><span style="color:#859900;">* </span><span style="color:#268bd2;">str</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// ✅ 允许从 const char* 隐式转换为 String
</span><span>    </span><span style="color:#657b83;">{
</span><span>        std::cout </span><span style="color:#657b83;">&lt;&lt; </span><span>&quot;</span><span style="color:#2aa198;">String constructor called</span><span style="color:#dc322f;">\n</span><span>&quot;;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}</span><span>;
</span><span>
</span><span style="color:#268bd2;">void </span><span style="color:#b58900;">printString</span><span style="color:#657b83;">(</span><span>String </span><span style="color:#268bd2;">s</span><span style="color:#657b83;">) {}
</span><span>
</span><span style="color:#268bd2;">int </span><span style="color:#b58900;">main</span><span style="color:#657b83;">()
</span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#b58900;">printString</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">Hello</span><span>&quot;</span><span style="color:#657b83;">)</span><span>; </span><span style="color:#586e75;">// ✅ 允许隐式转换
</span><span style="color:#657b83;">}
</span></code></pre>
<p><strong>❌ 不要给拷贝/移动构造函数加 explicit</strong></p>
<pre data-lang="cpp" style="background-color:#002b36;color:#839496;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#268bd2;">class </span><span style="color:#b58900;">Bar
</span><span style="color:#657b83;">{
</span><span style="color:#859900;">public</span><span style="color:#657b83;">:
</span><span>    </span><span style="color:#b58900;">Bar</span><span style="color:#657b83;">(</span><span style="color:#859900;">const</span><span> Bar</span><span style="color:#859900;">&amp;</span><span style="color:#657b83;">) = </span><span style="color:#859900;">default</span><span>; </span><span style="color:#586e75;">// ✅ 正确，拷贝构造函数不应 explicit
</span><span>    </span><span style="color:#b58900;">Bar</span><span style="color:#657b83;">(</span><span>Bar</span><span style="color:#657b83;">&amp;&amp;) = </span><span style="color:#859900;">default</span><span>;      </span><span style="color:#586e75;">// ✅ 正确，移动构造函数不应 explicit
</span><span style="color:#657b83;">}</span><span>;
</span></code></pre>
<blockquote>
<p>如果加上 <code>explicit</code>，将会导致 <code>Bar b2 = b1</code>; 无法编译。</p>
</blockquote>
<table><thead><tr><th><strong>规则</strong></th><th><strong>解释</strong></th></tr></thead><tbody>
<tr><td><strong>单参数构造函数默认 explicit</strong></td><td>防止意外的隐式转换</td></tr>
<tr><td><strong>如果隐式转换合理且高效，可去掉 explicit</strong></td><td>例如 String(const char*)</td></tr>
<tr><td><strong>拷贝/移动构造函数不要 explicit</strong></td><td>这些构造函数不会执行类型转换，避免影响正常复制/移动</td></tr>
</tbody></table>

      
    </div><!--./card-body-->

    <div class="card-footer">
      <div class="columns">
        <div class="column col-9 col-sm-7">
          <div class="taxonomies text-left">
            

    
          </div>
        </div><!--./col-6-->
        
        </div><!--./columns-->
    </div><!--./card-footer-->
</div><!--./card-->
</div>
              <div id="sidebar" class="column col-4 col-md-12">
                <div class="sidebar-content">
                  
                  
<div class="sidebar-widget">
  <div class="tile">
    <div class="tile-icon">
      <figure class="avatar avatar-xl">
        <img src="https://ilikexff.cn/avatar.png" alt="author avatar image">
      </figure>
    </div>
    <div class="tile-content">
      <p class="tile-title" style="font-weight: 600;">八尺妖剑</p>
      <p class="tile-subtitle">热爱编程，专注于技术分享和学习</p>
    </div>
</div><!--./tile-->
</div>

                  
                  
<div class="sidebar-widget">
  欢迎来到<strong>八尺妖剑</strong>！这里分享技术文章和编程心得。
</div><!-- end text widget -->

                  

                  </div><!--./sidebar-content-->
              </div>
            </div>
            
          </section>
        </section></section>
<section class="container grid-xl">
<ul class="pagination paginator">
  
  
</ul>
</section>
</div><!-- ./page-wrapper -->

    
<div class="mobile-container">
        <div class="overlay" id="overlay">
            <div style="padding: 1rem;">
              
<a class="site-logo" href="https:&#x2F;&#x2F;ilikexff.cn">
  
  <div class="col-mx-auto">
    <figure style="margin: 8px">
      <img class="img-responsive"
           style="max-height: 45px"
           alt="frontmatter image"
           src="https://ilikexff.cn/./assets/logo.png">
    </figure>
  </div>
  
</a>

            </div>
            <nav class="overlay-menu">
              

<ul class="tree treemenu treemenu-root"><li class="tree-empty">
      <span class="toggler"></span>
      <a href="https://ilikexff.cn/tags">标签</a>
    </li><li class="tree-empty">
      <span class="toggler"></span>
      <a href="https://ilikexff.cn/categories">分类</a>
    </li><li class="tree-empty">
      <span class="toggler"></span>
      <a href="https://ilikexff.cn/about">关于</a>
    </li></ul>


              </nav>
        </div>
    </div>

<script type="text/javascript">
  var overlay = document.getElementById('overlay');
  var toggle = document.getElementById('toggle');

  function openOverlay(){
      // Open overlay
      if (overlay.classList.contains("open")) {
          overlay.classList.remove("open");
      }
      else {
          overlay.classList.add("open");
      }

      // Button transition
      if (toggle.classList.contains("active")) {
          toggle.classList.remove("active");
      }
      else {
          toggle.classList.add("active");
      }
    }
</script>

<section id="footer" class="bg-gray">
  <div class="container grid-xl">
    


    <div class="columns">
      
      <div class="column col-6 col-lg-12 col-mx-auto" style="text-align: center;">
        简单是效率的灵魂 | 黔ICP备2021010295号
      </div>
      
      <div class="column col-6 col-lg-12 col-mx-auto" style="text-align: center;">
        Made by <a href="https://github.com/gicrisf/">gicrisf</a> -
        <strong>Zhuia</strong>&nbsp;<a href="https://github.com/gicrisf/zhuia">source code</a>
        is licensed under <a href="http://opensource.org/licenses/mit-license.php" target="_blank">MIT</a>.
      </div>
    </div>
  </div>
</section>
</body>
</html>
