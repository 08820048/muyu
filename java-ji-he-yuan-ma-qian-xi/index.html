<!DOCTYPE html>
<html lang="zh" data-theme="light" dir="ltr">
  <head>
    <title>Java集合源码浅析 - 八尺妖剑</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="description" content="简单是效率的灵魂"/>

    <meta property="og:title" content="八尺妖剑 -&nbsp;Java集合源码浅析" />
    <meta property="og:type" content="website"/><meta property="og:url" content="https:&#x2F;&#x2F;ilikexff.cn&#x2F;java-ji-he-yuan-ma-qian-xi&#x2F;"/><meta property="og:description" content="简单是效率的灵魂"/>


    <meta name="twitter:card" content="summary">


    <link rel="stylesheet" href="https://ilikexff.cn/spectre/spectre.css">
    <link rel="stylesheet" href="https://ilikexff.cn/theme.css"><link rel="stylesheet" href="https://ilikexff.cn/custom.css">
    

        
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>

    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script>
        function doRenderMath() {
            renderMathInElement(document.body, {
                delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false},
                {left: "\\(", right: "\\)", display: false},
                {left: "\\begin{equation}", right: "\\end{equation}", display: true},
                {left: "\\begin{align}", right: "\\end{align}", display: true},
                {left: "\\begin{alignat}", right: "\\end{alignat}", display: true},
                {left: "\\begin{gather}", right: "\\end{gather}", display: true},
                {left: "\\begin{CD}", right: "\\end{CD}", display: true},
                {left: "\\[", right: "\\]", display: true}
                ]
            });
        }
    </script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
        onload="doRenderMath()"></script>

      </head>
  <body id="top" class="sticky-footer"><div id="page-wrapper">
<header id="header" class="section">
  <section class="container grid-xl">
    <nav class="navbar">
      <section class="navbar-section">
        
<a class="site-logo" href="https:&#x2F;&#x2F;ilikexff.cn">
  
  <div class="col-mx-auto">
    <figure style="margin: 8px">
      <img class="img-responsive"
           style="max-height: 45px"
           alt="frontmatter image"
           src="https://ilikexff.cn/./logo.svg">
    </figure>
  </div>
  
</a>

      </section><!-- ./home button -->

      <section class="navbar-center hide-md"></section>

      <section class="navbar-section">
        <nav class="dropmenu animated hide-md">

<ul><li>
        <a href="https://ilikexff.cn/tags">标签</a>
    </li><li>
        <a href="https://ilikexff.cn/categories">分类</a>
    </li><li>
        <a href="https://ilikexff.cn/about">关于</a>
    </li></ul>


          </nav>
      </section><!-- ./desktop-menu -->
    </nav>
  </section><!-- ./container -->
</header>


<div class="mobile-menu">
  <div class="button_container" id="toggle" onclick="openOverlay()">
    <span class="top"></span>
    <span class="middle"></span>
    <span class="bottom"></span>
  </div>
</div><!--./mobile-menu-->


<section id="start"><section id="body-wrapper" class="section">
          <section class="container grid-xl">
<div id="breadcrumbs" itemtype="http://schema.org/BreadcrumbList" class="hide-sm">
  
    
    <span><a href="https:&#x2F;&#x2F;ilikexff.cn&#x2F;">Home</a></span>
  
    <span><a href="https:&#x2F;&#x2F;ilikexff.cn&#x2F;java-ji-he-yuan-ma-qian-xi&#x2F;">Java集合源码浅析</a></span>
</div>
<div class="columns">
              <div id="item" class="column col-8 col-md-12 extra-spacing">
<div class="card">
  

    <div class="card-header">
      <div class="card-title" style="margin-top: .25rem;"><div>
          <h1 class="post-title">Java集合源码浅析</h1>
          
    <div class="post-meta" style="display: inline-flex">
        <span class="blog-date" style="display: inline-flex;">
          <i class="gg-calendar" style="margin-right: 5px;"></i><time datetime="2023.06.15">
          2023.06.15
          </time></span><span class="post-author" style="margin-left: 5px; display: inline-flex;">
          - 
    慕予
        </span></div>

        </div></div>
    </div><!--./card-header-->

    <div class="card-body">
      
        <h3 id="geng-xin-ri-zhi-tada">更新日志🎉<a class="zola-anchor" href="#geng-xin-ri-zhi-tada" aria-label="Anchor link for: geng-xin-ri-zhi-tada">🔗</a></h3>
<p>2023-01-29 星期六</p>
<blockquote>
<ul>
<li>修正一些已知错误</li>
<li>调整文章布局结构</li>
<li>修正错别字词</li>
</ul>
</blockquote>
<p>2022-05-26 10:20:23 星期四</p>
<blockquote>
<ul>
<li>修正语言表达逻辑</li>
<li>删除/修改了错别字词</li>
<li>更新了部分配图</li>
</ul>
</blockquote>
<p>2022-08-02</p>
<blockquote>
<ul>
<li>修正错别字</li>
<li>修正语言表达逻辑</li>
</ul>
</blockquote>
<p>2022-08-22</p>
<blockquote>
<ul>
<li>还是修已知的正错别词语</li>
</ul>
</blockquote>
<hr />
<hr />
<p>Java集合解读</p>
<h2 id="ideakuai-jie-jian">IDEA快捷键<a class="zola-anchor" href="#ideakuai-jie-jian" aria-label="Anchor link for: ideakuai-jie-jian">🔗</a></h2>
<blockquote>
<p>查看源码:F4</p>
<p>进入实现:Ctrl+Alt+B(鼠标点击)</p>
<p>添加实现类:空格</p>
<p>显示图:Ctrl+Alt+Shift+U</p>
</blockquote>
<h2 id="gai-lan">概览<a class="zola-anchor" href="#gai-lan" aria-label="Anchor link for: gai-lan">🔗</a></h2>
<p>**说明：**以下内容的源码分析，如没有特别说明，均来自JDK8.</p>
<blockquote>
<ol>
<li>
<p>集合主要分为两组：单列集合和双列集合</p>
<blockquote>
<p>但列集合一般是指存放单个对象的集合，而双列集合一般是以&lt;k,v&gt;键值对形式存放数据的集合。</p>
</blockquote>
</li>
<li>
<p><code>Collection</code>接口下有两个重要的子接口<code>List</code>,<code>Set</code>，他们的实现子类都是单列集合。</p>
</li>
<li>
<p><code>Map</code>接口的实现子类有<code>HashTable</code>、<code>HashMap</code>、<code>TreeMap</code>,也都是双列集合。</p>
</li>
<li>
<p>以下是集合类下两大主接口的类图关系。</p>
</li>
</ol>
</blockquote>
<h3 id="collectionxi"><strong>Collection系</strong><a class="zola-anchor" href="#collectionxi" aria-label="Anchor link for: collectionxi">🔗</a></h3>
<p><img src="https://images.waer.ltd/img/20220525092920.png" alt="" /></p>
<blockquote>
<p>在Conllection接口下，派生出了三个主要的子接口，分别为无序集合<code>Set</code>,队列<code>Queue</code>和有序集合<code>List</code>。在三大子接口之下，还有着众多的实现子类或者派生的子接口，其中最常用的有：</p>
</blockquote>
<ul>
<li>TreeSet</li>
<li>LinkedHashSet</li>
<li>HashSet</li>
<li>LinkedList</li>
<li>ArrayList</li>
<li>Stack</li>
</ul>
<hr />
<h3 id="mapxi"><strong>Map系</strong><a class="zola-anchor" href="#mapxi" aria-label="Anchor link for: mapxi">🔗</a></h3>
<p><img src="https://images.waer.ltd/img/20220525092947.png" alt="" /></p>
<blockquote>
<p><code>Map</code>集合为双列集合。<code>Map</code>**没有直接继承的子接口,**主要有三个实现类，分别是<code>HashMap</code>、<code>HashTable</code>、<code>SortedMap</code>。在三个主要实现之下，比较常用的实现及其实现子类有：</p>
<ul>
<li><code>HashMap</code>(性能高，非线程安全)</li>
<li><code>Hashtable</code>(性能较低，线程安全，但属于老旧的API，一般不推荐使用)</li>
<li><code>TreeMap</code>(有序<code>map</code>)</li>
</ul>
</blockquote>
<hr />
<h2 id="xi-shuo">细说<a class="zola-anchor" href="#xi-shuo" aria-label="Anchor link for: xi-shuo">🔗</a></h2>
<h3 id="collection"><code>Collection</code><a class="zola-anchor" href="#collection" aria-label="Anchor link for: collection">🔗</a></h3>
<p>由于<code>Collection</code>接口直接继承了<code>Iterable</code>，它是没有实现的，它的所有方法都是由它的<strong>子接口</strong>的实现类进行实现，所以这里就以<code>Collection</code>下子接口<code>List</code>的实现类<code>ArrayList</code>来讲解。注意<code>List</code>是<strong>有序集合且元素可以重复</strong>，而<code>Set</code>则是<strong>无序集合，元素不可重复</strong>。</p>
<p><strong>讲解的方法列表</strong></p>
<blockquote>
<ul>
<li>add:添加单个元素</li>
<li>remove：输出指定元素</li>
<li>contains:查找元素是否存在</li>
<li>size:获取元素个数</li>
<li>isEmpty:判断是否为空</li>
<li>clear:清空</li>
<li>addAll:添加多个元素</li>
<li>containsAll:查找多个元素是否都存在</li>
<li>removeAll:输出多个元素</li>
</ul>
</blockquote>
<p><strong>基本用法演示</strong></p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">List</span><span> list </span><span style="color:#657b83;">= </span><span style="color:#859900;">new ArrayList</span><span style="color:#657b83;">()</span><span>;
</span><span style="color:#586e75;">/*添加单个元素*/
</span><span>list.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">Jack</span><span>&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#586e75;">//这里其实是一个自动装箱的操作:list.add(new Integer(10))
</span><span>list.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">10</span><span style="color:#657b83;">)</span><span>;
</span><span>list.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span style="color:#b58900;">true</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">list:</span><span>&quot;</span><span style="color:#657b83;">+</span><span>list</span><span style="color:#657b83;">)</span><span>;
</span><span>
</span><span style="color:#586e75;">/*输出元素*/
</span><span style="color:#586e75;">//输出&quot;Jack&quot;
</span><span style="color:#586e75;">//list.remove(0);
</span><span style="color:#586e75;">//指定输出某个元素
</span><span>list.</span><span style="color:#b58900;">remove</span><span style="color:#657b83;">(</span><span style="color:#b58900;">true</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">输出后的[list]:</span><span>&quot;</span><span style="color:#657b83;">+</span><span>list</span><span style="color:#657b83;">)</span><span>;
</span><span>
</span><span style="color:#586e75;">/*查找某个元素是否存在*/
</span><span style="color:#586e75;">//true
</span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>list.</span><span style="color:#b58900;">contains</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">Jack</span><span>&quot;</span><span style="color:#657b83;">))</span><span>;
</span><span>
</span><span style="color:#586e75;">/*获取元素个数*/
</span><span style="color:#586e75;">//2
</span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>list.</span><span style="color:#b58900;">size</span><span style="color:#657b83;">())</span><span>;
</span><span>
</span><span style="color:#586e75;">/*判断集合是否为空*/
</span><span style="color:#586e75;">//false
</span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>list.</span><span style="color:#b58900;">isEmpty</span><span style="color:#657b83;">())</span><span>;
</span><span>
</span><span style="color:#586e75;">/*清空集合*/
</span><span>list.</span><span style="color:#b58900;">clear</span><span style="color:#657b83;">()</span><span>;
</span><span style="color:#586e75;">//清空后的[list]：[]
</span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">清空后的[list]：</span><span>&quot;</span><span style="color:#657b83;">+</span><span>list</span><span style="color:#657b83;">)</span><span>;
</span><span>
</span><span style="color:#586e75;">/*添加多个元素*/
</span><span style="color:#859900;">ArrayList</span><span> list2 </span><span style="color:#657b83;">= </span><span style="color:#859900;">new ArrayList</span><span style="color:#657b83;">()</span><span>;
</span><span>list2.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">西游记</span><span>&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span>list2.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">西厢记</span><span>&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span>list.</span><span style="color:#b58900;">addAll</span><span style="color:#657b83;">(</span><span>list2</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#586e75;">//添加多个元素后的[list]:[西游记, 西厢记]
</span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">添加多个元素后的[list]:</span><span>&quot;</span><span style="color:#657b83;">+</span><span>list</span><span style="color:#657b83;">)</span><span>;
</span><span>
</span><span style="color:#586e75;">/*判断多个元素是否都存在*/
</span><span style="color:#586e75;">//true
</span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>list.</span><span style="color:#b58900;">containsAll</span><span style="color:#657b83;">(</span><span>list2</span><span style="color:#657b83;">))</span><span>;
</span><span>
</span><span style="color:#586e75;">/*输出多个元素*/
</span><span>list.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">华强北</span><span>&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#586e75;">//true
</span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>list.</span><span style="color:#b58900;">removeAll</span><span style="color:#657b83;">(</span><span>list2</span><span style="color:#657b83;">))</span><span>;
</span><span style="color:#586e75;">//华强北
</span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>list</span><span style="color:#657b83;">)</span><span>;
</span></code></pre>
<p><strong>遍历用法</strong></p>
<blockquote>
<p>上面的类图已经知道，<code>Collection</code>接口还有一个<code>Iterable</code>父接口。它的部分实现源码中第一个方法如下:</p>
<p><img src="https://images.waer.ltd/img/20220320114101.png" alt="" /></p>
<p>可以看到，该方法可以返回元素的<code>iterator</code>对象。只要是实现了接口的所有子类，都有一个<code>iterator()</code>方法。在对元素的遍历上，都可以采用迭代器的方式进行遍历。所以<code>Collection</code><strong>及其所有子类实现</strong>，我们都可以获取到每个元素的迭代器并用在对元素的遍历操作上。需要注意的是，<code>iterator</code><strong>仅用来遍历集合，本身并不存放任何对象。</strong></p>
</blockquote>
<p><strong>迭代器的执行原理</strong></p>
<blockquote>
<p>作为<code>Collection</code>的父接口，<code>Iterator</code>的方法如下：</p>
<p><img src="https://images.waer.ltd/img/20220320141211.png" alt="" /></p>
</blockquote>
<blockquote>
<p>我们一般在使用迭代器进行遍历的时候，都会用到一个<code>while</code>循环，循环的条件是<code>iterator.hasNext()</code>，也就是说，在每次得到遍历元素之前，<code>iterator</code>对象会调用自身的<code>hasNext()</code>方法，对集合里的元素进行判断，<strong>只有当存在下一个元素时，迭代器才会继续往下执行</strong>，否则，迭代结束。</p>
<p><img src="https://images.waer.ltd/img/20220320140135.png" alt="" /></p>
<p>可以看到，<code>Iterator</code>的<code>hasNext()</code>方法返回一个<strong>布尔值</strong>，如果该迭代对象还存在元素的情况下。这个方法就相当于一个指向集合元素的指针，每一次调用都会向下移动以检查<strong>是否到达集合尾部</strong>，在移动的同时，它还会调用<code>next()</code>方法，该方法会将移动后该指针指向位置上的元素进行返回。为了有效的防止空指针，每次在调用<code>Next()</code>之前，会先调用<code>hasNext()</code>,这是有必要的。如果说不存在下一个元素，则会抛出一个<code>NoSuchElementException</code>异常。</p>
</blockquote>
<p><strong>Iterator使用示例</strong></p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">package </span><span style="color:#b58900;">collection</span><span>;
</span><span>
</span><span style="color:#cb4b16;">import </span><span style="color:#859900;">java</span><span>.</span><span style="color:#859900;">util</span><span>.</span><span style="color:#859900;">ArrayList</span><span>;
</span><span style="color:#cb4b16;">import </span><span style="color:#859900;">java</span><span>.</span><span style="color:#859900;">util</span><span>.</span><span style="color:#859900;">Collection</span><span>;
</span><span style="color:#cb4b16;">import </span><span style="color:#859900;">java</span><span>.</span><span style="color:#859900;">util</span><span>.</span><span style="color:#859900;">Iterator</span><span>;
</span><span>
</span><span style="color:#586e75;">/**
</span><span style="color:#586e75;"> * </span><span style="color:#859900;">@author</span><span style="color:#586e75;">: 八尺妖剑
</span><span style="color:#586e75;"> * @date: 2022/3/20 14:17
</span><span style="color:#586e75;"> * @description: 演示迭代器[Iterator]的使用
</span><span style="color:#586e75;"> * @blog:www.waer.ltd
</span><span style="color:#586e75;"> */
</span><span>@</span><span style="color:#268bd2;">SuppressWarnings</span><span style="color:#657b83;">({</span><span>&quot;</span><span style="color:#2aa198;">all</span><span>&quot;</span><span style="color:#657b83;">})
</span><span style="color:#93a1a1;">public </span><span style="color:#268bd2;">class </span><span style="color:#b58900;">CollectionIterator </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#93a1a1;">public static </span><span style="color:#268bd2;">void </span><span style="color:#b58900;">main</span><span style="color:#657b83;">(</span><span style="color:#859900;">String</span><span style="color:#93a1a1;">[] </span><span style="color:#268bd2;">args</span><span style="color:#657b83;">) {
</span><span>        </span><span style="color:#859900;">Collection</span><span> col </span><span style="color:#657b83;">= </span><span style="color:#859900;">new ArrayList</span><span style="color:#657b83;">()</span><span>;
</span><span>        col.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span style="color:#859900;">new Book</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">C++ Primer Plus</span><span>&quot;,&quot;</span><span style="color:#2aa198;">Stephen Prata</span><span>&quot;,</span><span style="color:#6c71c4;">57.4</span><span style="color:#657b83;">))</span><span>;
</span><span>        col.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span style="color:#859900;">new Book</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">程序员的数学</span><span>&quot;,&quot;</span><span style="color:#2aa198;">结城浩</span><span>&quot;,</span><span style="color:#6c71c4;">20.5</span><span style="color:#657b83;">))</span><span>;
</span><span>        col.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span style="color:#859900;">new Book</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">Java疯狂讲义</span><span>&quot;,&quot;</span><span style="color:#2aa198;">李刚</span><span>&quot;,</span><span style="color:#6c71c4;">80.7</span><span style="color:#657b83;">))</span><span>;
</span><span>
</span><span>        </span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">集合[col]:</span><span>&quot;</span><span style="color:#657b83;">+</span><span>col</span><span style="color:#657b83;">)</span><span>;
</span><span>        </span><span style="color:#586e75;">/*遍历集合*/
</span><span>        </span><span style="color:#586e75;">//1.获取集合的迭代对象
</span><span>        </span><span style="color:#859900;">Iterator</span><span> iterator </span><span style="color:#657b83;">=</span><span> col.</span><span style="color:#b58900;">iterator</span><span style="color:#657b83;">()</span><span>;
</span><span>        </span><span style="color:#586e75;">//2.while循环遍历数据
</span><span>        </span><span style="color:#859900;">while</span><span style="color:#657b83;">(</span><span>iterator.</span><span style="color:#b58900;">hasNext</span><span style="color:#657b83;">()){
</span><span>            </span><span style="color:#586e75;">//3.注意：iterator返回默认时一个Object类型(除非指定泛型)
</span><span>            </span><span style="color:#859900;">Object</span><span> o </span><span style="color:#657b83;">=</span><span> iterator.</span><span style="color:#b58900;">next</span><span style="color:#657b83;">()</span><span>;
</span><span>            </span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">[col]迭代返回:</span><span>&quot;</span><span style="color:#657b83;">+</span><span>o</span><span style="color:#657b83;">)</span><span>;
</span><span>        </span><span style="color:#657b83;">}
</span><span>        </span><span style="color:#586e75;">//4.当退出while循环之后，此时的iterator指向最后一个元素，在调用next()方法会报NoSuchElementException异常。
</span><span>        </span><span style="color:#586e75;">//如果需要再次遍历，需要重置迭代器。方法如下：
</span><span>        </span><span style="color:#586e75;">//IDEA支持快速生成迭代方法，使用[Ctrl+j]快捷键进行查看
</span><span>        iterator </span><span style="color:#657b83;">=</span><span> col.</span><span style="color:#b58900;">iterator</span><span style="color:#657b83;">()</span><span>;
</span><span>        </span><span style="color:#859900;">while </span><span style="color:#657b83;">(</span><span>iterator.</span><span style="color:#b58900;">hasNext</span><span style="color:#657b83;">()) {
</span><span>            </span><span style="color:#859900;">Object</span><span> o1 </span><span style="color:#657b83;">=</span><span>  iterator.</span><span style="color:#b58900;">next</span><span style="color:#657b83;">()</span><span>;
</span><span>            </span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">[col]再次迭代：</span><span>&quot;</span><span style="color:#657b83;">+</span><span>o1</span><span style="color:#657b83;">)</span><span>;
</span><span>        </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}
</span><span>
</span><span style="color:#586e75;">/**
</span><span style="color:#586e75;"> * 内部类
</span><span style="color:#586e75;"> */
</span><span style="color:#586e75;">class  Book{
</span><span style="color:#586e75;">    private String name;
</span><span style="color:#586e75;">    private String author;
</span><span style="color:#586e75;">    private double price;
</span><span style="color:#586e75;">
</span><span style="color:#586e75;">    public Book(String name, String author, double price) {
</span><span style="color:#586e75;">        this.name = name;
</span><span style="color:#586e75;">        this.author = author;
</span><span style="color:#586e75;">        this.price = price;
</span><span style="color:#586e75;">    }
</span><span style="color:#586e75;">
</span><span style="color:#586e75;">    @Override
</span><span style="color:#586e75;">    public String toString() {
</span><span style="color:#586e75;">        return &quot;Book{&quot; +
</span><span style="color:#586e75;">                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
</span><span style="color:#586e75;">                &quot;, author=&#39;&quot; + author + &#39;\&#39;&#39; +
</span><span style="color:#586e75;">                &quot;, price=&quot; + price +
</span><span style="color:#586e75;">                &#39;}&#39;;
</span><span style="color:#586e75;">    }
</span><span style="color:#586e75;">
</span><span style="color:#586e75;">    public String getName() {
</span><span style="color:#586e75;">        return name;
</span><span style="color:#586e75;">    }
</span><span style="color:#586e75;">
</span><span style="color:#586e75;">    public void setName(String name) {
</span><span style="color:#586e75;">        this.name = name;
</span><span style="color:#586e75;">    }
</span><span style="color:#586e75;">
</span><span style="color:#586e75;">    public String getAuthor() {
</span><span style="color:#586e75;">        return author;
</span><span style="color:#586e75;">    }
</span><span style="color:#586e75;">
</span><span style="color:#586e75;">    public void setAuthor(String author) {
</span><span style="color:#586e75;">        this.author = author;
</span><span style="color:#586e75;">    }
</span><span style="color:#586e75;">
</span><span style="color:#586e75;">    public double getPrice() {
</span><span style="color:#586e75;">        return price;
</span><span style="color:#586e75;">    }
</span><span style="color:#586e75;">
</span><span style="color:#586e75;">    public void setPrice(double price) {
</span><span style="color:#586e75;">        this.price = price;
</span><span style="color:#586e75;">    }
</span><span style="color:#586e75;">}
</span></code></pre>
<blockquote>
<p>一些需要注意的点，已经写在了注释当中。</p>
</blockquote>
<p><strong>增强for</strong></p>
<blockquote>
<p>所谓增强for，也就是针对普通for循环的增强。它可以替代<code>iterator</code>迭代器，相当于一个简化版的<code>iterator</code>,也正因为如此，<strong>增强for只能用于遍历集合或者数组</strong>。</p>
</blockquote>
<p>基本语法：</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">for</span><span style="color:#657b83;">(</span><span>元素类型 元素名</span><span style="color:#859900;">:</span><span>集合或者数组名</span><span style="color:#657b83;">){
</span><span>    访问元素;
</span><span style="color:#657b83;">}
</span></code></pre>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">package </span><span style="color:#b58900;">collection</span><span>;
</span><span>
</span><span style="color:#cb4b16;">import </span><span style="color:#859900;">java</span><span>.</span><span style="color:#859900;">util</span><span>.</span><span style="color:#859900;">ArrayList</span><span>;
</span><span style="color:#cb4b16;">import </span><span style="color:#859900;">java</span><span>.</span><span style="color:#859900;">util</span><span>.</span><span style="color:#859900;">Collection</span><span>;
</span><span>
</span><span style="color:#586e75;">/**
</span><span style="color:#586e75;"> * </span><span style="color:#859900;">@author</span><span style="color:#586e75;">: 八尺妖剑
</span><span style="color:#586e75;"> * @date: 2022/3/20 14:56
</span><span style="color:#586e75;"> * @description: 演示增强for的使用
</span><span style="color:#586e75;"> * @blog:www.waer.ltd
</span><span style="color:#586e75;"> */
</span><span style="color:#93a1a1;">public </span><span style="color:#268bd2;">class </span><span style="color:#b58900;">CollectionFor </span><span style="color:#657b83;">{
</span><span>    @</span><span style="color:#268bd2;">SuppressWarnings</span><span style="color:#657b83;">({</span><span>&quot;</span><span style="color:#2aa198;">all</span><span>&quot;</span><span style="color:#657b83;">})
</span><span>    </span><span style="color:#93a1a1;">public static </span><span style="color:#268bd2;">void  </span><span style="color:#b58900;">main</span><span style="color:#657b83;">(</span><span style="color:#859900;">String</span><span style="color:#93a1a1;">[] </span><span style="color:#268bd2;">args</span><span style="color:#657b83;">) {
</span><span>        </span><span style="color:#859900;">Collection</span><span> col </span><span style="color:#657b83;">= </span><span style="color:#859900;">new ArrayList</span><span style="color:#657b83;">()</span><span>;
</span><span>        col.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span style="color:#859900;">new Book</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">C++ Primer Plus</span><span>&quot;,&quot;</span><span style="color:#2aa198;">Stephen Prata</span><span>&quot;,</span><span style="color:#6c71c4;">57.4</span><span style="color:#657b83;">))</span><span>;
</span><span>        col.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span style="color:#859900;">new Book</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">程序员的数学</span><span>&quot;,&quot;</span><span style="color:#2aa198;">结城浩</span><span>&quot;,</span><span style="color:#6c71c4;">20.5</span><span style="color:#657b83;">))</span><span>;
</span><span>        col.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span style="color:#859900;">new Book</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">Java疯狂讲义</span><span>&quot;,&quot;</span><span style="color:#2aa198;">李刚</span><span>&quot;,</span><span style="color:#6c71c4;">80.7</span><span style="color:#657b83;">))</span><span>;
</span><span>
</span><span>        </span><span style="color:#586e75;">/*使用增强for进行集合的遍历*/
</span><span>        </span><span style="color:#859900;">for</span><span style="color:#657b83;">(</span><span style="color:#859900;">Object</span><span> book</span><span style="color:#859900;">:</span><span>col</span><span style="color:#657b83;">){
</span><span>            </span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">book=</span><span>&quot;</span><span style="color:#657b83;">+</span><span>book</span><span style="color:#657b83;">)</span><span>;
</span><span>        </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}
</span></code></pre>
<h4 id="listjie-kou"><code>List</code>接口<a class="zola-anchor" href="#listjie-kou" aria-label="Anchor link for: listjie-kou">🔗</a></h4>
<p><strong>常用实现及其方法一览</strong></p>
<p><img src="https://images.waer.ltd/img/Lists.png" alt="" /></p>
<blockquote>
<p><code>List</code>接口是<code>Collection</code>的子接口，上面讲解的<code>ArrayList</code>的方法是来自<code>Collection</code>接口方法。而这些方在<code>Set</code>子接口中也可以使用。下面讲一下子接口<code>List</code>中的实现类，也是以<code>ArrayList</code>实现为例。</p>
</blockquote>
<blockquote>
<ul>
<li><code>List</code>集合类中的元素是有序(添加和取出顺序一致)的，且是可重复的。</li>
<li><code>List</code>集合中的每一个元素都有其对应的顺序索引，即他是支持<strong>索引</strong>的一类集合。</li>
<li><code>List</code>中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</li>
<li><code>List</code>子接口的主要常用实现类有<code>ArrayList</code>、<code>LinkedList</code>、<code>Vector</code>。</li>
</ul>
</blockquote>
<p><strong>List的一些方法</strong></p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">package </span><span style="color:#b58900;">List</span><span>;
</span><span>
</span><span style="color:#cb4b16;">import </span><span style="color:#859900;">java</span><span>.</span><span style="color:#859900;">util</span><span>.</span><span style="color:#859900;">ArrayList</span><span>;
</span><span style="color:#cb4b16;">import </span><span style="color:#859900;">java</span><span>.</span><span style="color:#859900;">util</span><span>.</span><span style="color:#859900;">List</span><span>;
</span><span>
</span><span style="color:#586e75;">/**
</span><span style="color:#586e75;"> * </span><span style="color:#859900;">@author</span><span style="color:#586e75;">: 八尺妖剑
</span><span style="color:#586e75;"> * @date: 2022/3/20 16:57
</span><span style="color:#586e75;"> * @description: List的方法演示
</span><span style="color:#586e75;"> * @blog:www.waer.ltd
</span><span style="color:#586e75;"> */
</span><span style="color:#93a1a1;">public </span><span style="color:#268bd2;">class </span><span style="color:#b58900;">ListMethod </span><span style="color:#657b83;">{
</span><span>    @</span><span style="color:#268bd2;">SuppressWarnings</span><span style="color:#657b83;">({</span><span>&quot;</span><span style="color:#2aa198;">all</span><span>&quot;</span><span style="color:#657b83;">})
</span><span>    </span><span style="color:#93a1a1;">public static </span><span style="color:#268bd2;">void </span><span style="color:#b58900;">main</span><span style="color:#657b83;">(</span><span style="color:#859900;">String</span><span style="color:#93a1a1;">[] </span><span style="color:#268bd2;">args</span><span style="color:#657b83;">) {
</span><span>        </span><span style="color:#859900;">List</span><span> list </span><span style="color:#657b83;">=</span><span style="color:#859900;">new ArrayList</span><span style="color:#657b83;">()</span><span>;
</span><span>        list.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">张无忌</span><span>&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span>        list.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">张天志</span><span>&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span>        </span><span style="color:#586e75;">/*在index位置插入元素e*/
</span><span>        </span><span style="color:#586e75;">/*注意：这里如果不指定下标的话，默认是以尾部追加的方式进行元素插入的*/
</span><span>        list.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">1</span><span>,&quot;</span><span style="color:#2aa198;">Tisox</span><span>&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span>        </span><span style="color:#586e75;">//list=[张无忌, Tisox, 张天志]
</span><span>        </span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">list=</span><span>&quot;</span><span style="color:#657b83;">+</span><span>list</span><span style="color:#657b83;">)</span><span>;
</span><span>
</span><span>        </span><span style="color:#586e75;">/*addAll(inr index,Collection e)：从index位置开始将元素e中的所有元素添加进来*/
</span><span>        </span><span style="color:#859900;">List</span><span> list2 </span><span style="color:#657b83;">=</span><span style="color:#859900;">new ArrayList</span><span style="color:#657b83;">()</span><span>;
</span><span>        list2.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">蜘蛛侠</span><span>&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span>        list2.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">钢铁侠</span><span>&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span>        list.</span><span style="color:#b58900;">addAll</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">1</span><span>,list2</span><span style="color:#657b83;">)</span><span>;
</span><span>        </span><span style="color:#586e75;">//list=[张无忌, 蜘蛛侠, 钢铁侠, Tisox, 张天志]
</span><span>        </span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">list=</span><span>&quot;</span><span style="color:#657b83;">+</span><span>list</span><span style="color:#657b83;">)</span><span>;
</span><span>        </span><span style="color:#586e75;">/*int intdexOf(Object obj):返回obj在当前集合中首次出现的位置*/
</span><span>        </span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>list.</span><span style="color:#b58900;">indexOf</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">蜘蛛侠</span><span>&quot;</span><span style="color:#657b83;">))</span><span>;
</span><span>
</span><span>        </span><span style="color:#586e75;">/*int lastIndexOf(Object obj):返回obj在当前集合中最后一次出现的位置*/
</span><span>        list.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">凋残</span><span>&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span>        </span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>list.</span><span style="color:#b58900;">lastIndexOf</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">凋残</span><span>&quot;</span><span style="color:#657b83;">))</span><span>;
</span><span>
</span><span>        </span><span style="color:#586e75;">/*remove(int index):移除指定index位置的元素，并返回此元素*/
</span><span>        list.</span><span style="color:#b58900;">remove</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">)</span><span>;
</span><span>        </span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">list=</span><span>&quot;</span><span style="color:#657b83;">+</span><span>list</span><span style="color:#657b83;">)</span><span>;
</span><span>
</span><span>        </span><span style="color:#586e75;">/*set(int index,Object ele):设置指定index位置出的元素为ele，相当于是替换元素*/
</span><span>        list.</span><span style="color:#b58900;">set</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">1</span><span>,&quot;</span><span style="color:#2aa198;">新的名字</span><span>&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span>        </span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">list=</span><span>&quot;</span><span style="color:#657b83;">+</span><span>list</span><span style="color:#657b83;">)</span><span>;
</span><span>
</span><span>        </span><span style="color:#586e75;">/*subList(int fromIndex,int toIndex):返回从fromIndex到toIndex位置的子集合*/
</span><span>        </span><span style="color:#586e75;">//返回一个左闭右开的区间
</span><span>        </span><span style="color:#859900;">List</span><span> reslist </span><span style="color:#657b83;">=</span><span> list.</span><span style="color:#b58900;">subList</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">2</span><span style="color:#657b83;">)</span><span>;
</span><span>        </span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">relist=</span><span>&quot;</span><span style="color:#657b83;">+</span><span>reslist</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}
</span></code></pre>
<p><strong>List的三种遍历方式</strong></p>
<blockquote>
<p>由于<code>ArrayList</code>、<code>LinkedList</code>和<code>Vector</code>都是<code>List</code>的实现子类，以下方法可以<strong>无缝切换</strong>，效果是一样的。</p>
</blockquote>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">package </span><span style="color:#b58900;">List</span><span>;
</span><span>
</span><span style="color:#cb4b16;">import </span><span style="color:#859900;">java</span><span>.</span><span style="color:#859900;">util</span><span>.</span><span style="color:#cb4b16;">*</span><span>;
</span><span>
</span><span style="color:#586e75;">/**
</span><span style="color:#586e75;"> * </span><span style="color:#859900;">@author</span><span style="color:#586e75;">: Tisox
</span><span style="color:#586e75;"> * @date: 2022/3/20 19:18
</span><span style="color:#586e75;"> * @description: List的三种遍历方式
</span><span style="color:#586e75;"> * @blog:www.waer.ltd
</span><span style="color:#586e75;"> */
</span><span style="color:#93a1a1;">public </span><span style="color:#268bd2;">class </span><span style="color:#b58900;">ListFor </span><span style="color:#657b83;">{
</span><span>    @</span><span style="color:#268bd2;">SuppressWarnings</span><span style="color:#657b83;">({</span><span>&quot;</span><span style="color:#2aa198;">all</span><span>&quot;</span><span style="color:#657b83;">})
</span><span>    </span><span style="color:#93a1a1;">public static </span><span style="color:#268bd2;">void </span><span style="color:#b58900;">main</span><span style="color:#657b83;">(</span><span style="color:#859900;">String</span><span style="color:#93a1a1;">[] </span><span style="color:#268bd2;">args</span><span style="color:#657b83;">) {
</span><span>        </span><span style="color:#586e75;">//List list =new Vector();
</span><span>        </span><span style="color:#859900;">List</span><span> list </span><span style="color:#657b83;">= </span><span style="color:#859900;">new LinkedList</span><span style="color:#657b83;">()</span><span>;
</span><span>        </span><span style="color:#586e75;">//List list = new ArrayList();
</span><span>        list.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">jack</span><span>&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span>        list.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">tom</span><span>&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span>        list.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">回锅肉</span><span>&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span>        list.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">鱼香肉丝</span><span>&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span>        list.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">砂锅粉</span><span>&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span>
</span><span>        </span><span style="color:#586e75;">/*1.迭代器遍历*/
</span><span>        </span><span style="color:#859900;">Iterator</span><span> iterator </span><span style="color:#657b83;">=</span><span> list.</span><span style="color:#b58900;">iterator</span><span style="color:#657b83;">()</span><span>;
</span><span>        </span><span style="color:#859900;">while </span><span style="color:#657b83;">(</span><span>iterator.</span><span style="color:#b58900;">hasNext</span><span style="color:#657b83;">()) {
</span><span>            </span><span style="color:#859900;">Object</span><span> next </span><span style="color:#657b83;">=</span><span> iterator.</span><span style="color:#b58900;">next</span><span style="color:#657b83;">()</span><span>;
</span><span>            </span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">[list]的[迭代器iterator]遍历=</span><span>&quot;</span><span style="color:#657b83;">+</span><span>list</span><span style="color:#657b83;">)</span><span>;
</span><span>        </span><span style="color:#657b83;">}
</span><span>        </span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">====================================</span><span>&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span>        </span><span style="color:#586e75;">/*2.增强for遍历*/
</span><span>        </span><span style="color:#859900;">for </span><span style="color:#657b83;">(</span><span style="color:#859900;">Object</span><span> o </span><span style="color:#859900;">:</span><span> list</span><span style="color:#657b83;">) {
</span><span>            </span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">[list]的[增强for]遍历=</span><span>&quot;</span><span style="color:#657b83;">+</span><span>list</span><span style="color:#657b83;">)</span><span>;
</span><span>        </span><span style="color:#657b83;">}
</span><span>        </span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">====================================</span><span>&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span>        </span><span style="color:#586e75;">/*3.普通for循环遍历*/
</span><span>        </span><span style="color:#859900;">for</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> i</span><span style="color:#657b83;">=</span><span style="color:#6c71c4;">0</span><span>;i</span><span style="color:#657b83;">&lt;</span><span>list.</span><span style="color:#b58900;">size</span><span style="color:#657b83;">()</span><span>;i</span><span style="color:#859900;">++</span><span style="color:#657b83;">){
</span><span>            </span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">[list]的[普通for循环]遍历=</span><span>&quot;</span><span style="color:#657b83;">+</span><span>list.</span><span style="color:#b58900;">get</span><span style="color:#657b83;">(</span><span>i</span><span style="color:#657b83;">))</span><span>;
</span><span>        </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}
</span></code></pre>
<h4 id="arraylist"><code>ArrayList</code><a class="zola-anchor" href="#arraylist" aria-label="Anchor link for: arraylist">🔗</a></h4>
<ul>
<li><code>ArrayList</code><strong>允许存入<code>null</code>值。</strong></li>
</ul>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">ArrayList</span><span> arrayList </span><span style="color:#657b83;">= </span><span style="color:#859900;">new ArrayList</span><span style="color:#657b83;">()</span><span>;
</span><span>arrayList.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span style="color:#b58900;">null</span><span style="color:#657b83;">)</span><span>;
</span><span>arrayList.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span>&quot;&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span>arrayList.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">Java</span><span>&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>arrayList</span><span style="color:#657b83;">)</span><span>;
</span></code></pre>
<ul>
<li>
<p>底层采用数组实现。</p>
</li>
<li>
<p><code>ArrayList</code>线程不安全</p>
</li>
</ul>
<p><img src="https://images.waer.ltd/img/20220320204436.png" alt="" /></p>
<blockquote>
<p>通过它的源码可以看到，他是没有<code>synchronized</code>关键字修饰的。也正是因为如此，它的效率是比较高的，所以如果需要保证线程安全的场景下，不建议使用<code>ArrayList</code>。</p>
</blockquote>
<h5 id="yuan-ma-fen-xi">源码分析<a class="zola-anchor" href="#yuan-ma-fen-xi" aria-label="Anchor link for: yuan-ma-fen-xi">🔗</a></h5>
<p>**<code>ArrayList</code>中维护了一个<code>Object</code>类型的数组<code>elementData[]</code>。**源码如下:</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">transient </span><span style="color:#859900;">Object</span><span style="color:#93a1a1;">[]</span><span> elementData;
</span></code></pre>
<p>这里的<code>elementData[]</code>数组的类型是<code>Object</code>类型，也就是说，它可以存放任意类型的数据，因为<code>Object</code>类是<strong>所有类的父类</strong>，也就是顶级父类。 关键字<code>transient</code>的作用是去除序列化，当某个属性被加上该关键字即表示它在进行序列化时会被忽略，不参与序列化操作。</p>
<h5 id="di-ceng-kuo-rong-yuan-li">底层扩容原理<a class="zola-anchor" href="#di-ceng-kuo-rong-yuan-li" aria-label="Anchor link for: di-ceng-kuo-rong-yuan-li">🔗</a></h5>
<blockquote>
<p><code>ArrayList</code>底层采用数组这种数据结构来实现，必然会有容量的限制，那么在它的底层是如何实现自动扩容的呢？这里以其中的<code>add()</code>方法进行浅析。</p>
</blockquote>
<p><code>ArrayList</code>有两个构造方法，分别是<strong>无参数构造和有参构造</strong>。下面是源码</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#586e75;">//无参构造
</span><span style="color:#93a1a1;">public </span><span style="color:#b58900;">ArrayList</span><span style="color:#657b83;">() {
</span><span>    </span><span style="color:#d33682;">this</span><span>.elementData </span><span style="color:#657b83;">= </span><span style="color:#cb4b16;">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span>;
</span><span style="color:#657b83;">}
</span><span style="color:#586e75;">//有参构造
</span><span style="color:#93a1a1;">public </span><span style="color:#b58900;">ArrayList</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> initialCapacity</span><span style="color:#657b83;">) {
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>initialCapacity </span><span style="color:#657b83;">&gt; </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">) {
</span><span>        </span><span style="color:#d33682;">this</span><span>.elementData </span><span style="color:#657b83;">= </span><span style="color:#859900;">new Object</span><span style="color:#268bd2;">[</span><span>initialCapacity</span><span style="color:#268bd2;">]</span><span>;
</span><span>    </span><span style="color:#657b83;">} </span><span style="color:#859900;">else if </span><span style="color:#657b83;">(</span><span>initialCapacity </span><span style="color:#657b83;">== </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">) {
</span><span>        </span><span style="color:#d33682;">this</span><span>.elementData </span><span style="color:#657b83;">= </span><span style="color:#cb4b16;">EMPTY_ELEMENTDATA</span><span>;
</span><span>    </span><span style="color:#657b83;">} </span><span style="color:#859900;">else </span><span style="color:#657b83;">{
</span><span>        </span><span style="color:#859900;">throw new IllegalArgumentException</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">Illegal Capacity: </span><span>&quot;</span><span style="color:#657b83;">+
</span><span>                                           initialCapacity</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}
</span></code></pre>
<p>两个构造方法不仅在参数上有所区别，他们的底层扩容原理也是不一样的，先看一下无参数的<code> ArrayList()</code>构造。</p>
<p>可以看到，在<strong>无参构造的方法</strong>中，它将数组的初始容量设为<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>。也就是一个空对象数组。这一点可以从下面的源码得知。</p>
<p><img src="https://images.waer.ltd/img/20220321195749.png" alt="" /></p>
<p>下面尝试在集合中添加元素，来分析add方法的执行过程。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#586e75;">//使用无参构造对集合进行初始化
</span><span style="color:#859900;">ArrayList</span><span> list </span><span style="color:#657b83;">= </span><span style="color:#859900;">new ArrayList</span><span style="color:#657b83;">()</span><span>;
</span><span style="color:#586e75;">//向其中添加10个元素
</span><span style="color:#859900;">for </span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> i </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">1</span><span>; i </span><span style="color:#657b83;">&lt;= </span><span style="color:#6c71c4;">10</span><span>; i</span><span style="color:#859900;">++</span><span style="color:#657b83;">) {
</span><span>    list.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span>i</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p><strong>执行过程和扩容原理</strong></p>
<ul>
<li>在初始化完成后，当我们触发add()时，它会先调用<code>valueOf()</code>方法对添加的元素进行一个<strong>装箱</strong>操作，这不是本次分析的重点，不再赘述。注意下面这个自动装箱的源码来自<strong>JDK11</strong></li>
</ul>
<p><img src="https://images.waer.ltd/img/20220321200829.png" alt="" /></p>
<ul>
<li>
<p>装箱结束后，进入<code>add(E e)</code>这个方法，该方法是集合中的一个<strong>重载方法，接收一个泛型参数</strong>，源码如下:</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">public </span><span style="color:#268bd2;">boolean </span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span style="color:#859900;">E</span><span> e</span><span style="color:#657b83;">) {
</span><span>    </span><span style="color:#b58900;">ensureCapacityInternal</span><span style="color:#657b83;">(</span><span>size </span><span style="color:#657b83;">+ </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">)</span><span>;  </span><span style="color:#586e75;">// Increments modCount!!
</span><span>    elementData[size</span><span style="color:#859900;">++</span><span>] </span><span style="color:#657b83;">=</span><span> e;
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#b58900;">true</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
</li>
</ul>
<p>首先，在执行正式的添加操作之前，会先执行<code>ensureCapacityInternal()</code>方法，该方法主要是用来<strong>确认集合的容量情况</strong>，决定是否需要扩容。再调用添加方法进行元素的添加。显然，这里出现的<code>ensureCapacityInternal()</code>方法是重点，源码如下：</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">private</span><span> void </span><span style="color:#b58900;">ensureCapacityInternal</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> minCapacity</span><span style="color:#657b83;">) {
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>elementData </span><span style="color:#657b83;">== </span><span style="color:#cb4b16;">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span style="color:#657b83;">) {
</span><span>        minCapacity </span><span style="color:#657b83;">= </span><span style="color:#859900;">Math</span><span>.</span><span style="color:#b58900;">max</span><span style="color:#657b83;">(</span><span style="color:#cb4b16;">DEFAULT_CAPACITY</span><span>, minCapacity</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#b58900;">ensureExplicitCapacity</span><span style="color:#657b83;">(</span><span>minCapacity</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>方法传入一个名为<code>minCapacity</code>的<code>int</code>类型变量，表示数组最小容量。接着判断<code>elementData</code>是否是<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>默认值，由于我们选择的是无参构造，所以<code>if</code>语句中的条件是成立的。接下来<code>Math.max(DEFAULT_CAPACITY, minCapacity)</code>在<strong>默认容量</strong>和<strong>最小容量</strong>之间取一个最大值并赋给<code>minCapacity</code>，也就是更新<code>minCapacity</code>的值。关于默认容量<code>DEFAULT_CAPACITY</code>，下面是它的声明：</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">private static final </span><span style="color:#268bd2;">int </span><span style="color:#cb4b16;">DEFAULT_CAPACITY </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">10</span><span>;
</span></code></pre>
<p>执行之后，<code>minCapacity</code>的值将更新为10;也就是说，这个方法目的是为了确认<code>minCapacity</code>的值，而在<code>if</code>之后，又出现了一个<code>ensureExplicitCapacity(minCapacity)</code>方法，在<code>if</code>判断条件不满足的情况下执行，参数就是上面更新后的<code>minCapacity</code>，可以猜测，这个方法应该也是对是否需要扩容进行一个判断的算法。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">private</span><span> void </span><span style="color:#b58900;">ensureExplicitCapacity</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> minCapacity</span><span style="color:#657b83;">) {
</span><span>    modCount</span><span style="color:#859900;">++</span><span>;
</span><span>    </span><span style="color:#586e75;">// overflow-conscious code
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>minCapacity </span><span style="color:#657b83;">-</span><span> elementData.length </span><span style="color:#657b83;">&gt; </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">)
</span><span>        </span><span style="color:#b58900;">grow</span><span style="color:#657b83;">(</span><span>minCapacity</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>注意,这里有一条为<code>modCount++;</code>的语句，他主要是记录当前集合被修改的次数，为了防止被多个线程操作，否则会抛异常。第4行中if的条件<code>minCapacity - elementData.length &gt; 0</code>表示最小容量与当前数组元素容量的一个<strong>差值大于0是否成立</strong>，将会直接调用下一个方法进行扩容，也就是<code>grow()</code>方法。</p>
<blockquote>
<p>比方说，此时的<code>minCapacity=10</code>，<code>elementData=0</code>,显然<code>10-0&gt;0</code>,也即是说，数组需要一个最小容量为10空间，而此时的容量为0，显然需要进行扩容操作。</p>
</blockquote>
<p>下面是<code>grow()</code>方法，也是扩容的核心实现。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">private</span><span> void </span><span style="color:#b58900;">grow</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> minCapacity</span><span style="color:#657b83;">) {
</span><span>    </span><span style="color:#586e75;">// overflow-conscious code
</span><span>    </span><span style="color:#268bd2;">int</span><span> oldCapacity </span><span style="color:#657b83;">=</span><span> elementData.length;
</span><span>    </span><span style="color:#268bd2;">int</span><span> newCapacity </span><span style="color:#657b83;">=</span><span> oldCapacity </span><span style="color:#657b83;">+ (</span><span>oldCapacity </span><span style="color:#859900;">&gt;&gt; </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>newCapacity </span><span style="color:#657b83;">-</span><span> minCapacity </span><span style="color:#657b83;">&lt; </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">)
</span><span>        newCapacity </span><span style="color:#657b83;">=</span><span> minCapacity;
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>newCapacity </span><span style="color:#657b83;">- </span><span style="color:#cb4b16;">MAX_ARRAY_SIZE </span><span style="color:#657b83;">&gt; </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">)
</span><span>        newCapacity </span><span style="color:#657b83;">= </span><span style="color:#b58900;">hugeCapacity</span><span style="color:#657b83;">(</span><span>minCapacity</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#586e75;">// minCapacity is usually close to size, so this is a win:
</span><span>    elementData </span><span style="color:#657b83;">= </span><span style="color:#859900;">Arrays</span><span>.</span><span style="color:#b58900;">copyOf</span><span style="color:#657b83;">(</span><span>elementData, newCapacity</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>可以看到，方法开始会先将数组容量<code>elementData.length</code>赋值给一个中间变量<code>oldCapacity</code>。接着为变量<code>newCapacity</code>进行赋值，算法是将<code>oldCapacity</code>旧<strong>的容量+旧容量的二分之一</strong>赋值给该变量。注意这里<code>(oldCapacity &gt;&gt; 1)</code>表将<code>oldCapacity</code>右移一位，<strong>等同于除以2</strong>，用位运算可以提高执行效率。反过来，如果是左移的话，代表乘以<code>2</code>。</p>
<p>又由于前面已经知道<code>elemenatData</code>其实是等于<code>0</code>的，那么直接导致这条赋值语句结果为<code>0</code>，也就是<code>newCapacity==0</code>，所以它后面紧接着出现了两个判断。</p>
<blockquote>
<ol>
<li>如果新的容量小于最小容量，那么将最小容量赋给这个新容量，<strong>完成一次扩容，此时数组的容量由0变为10.</strong></li>
<li>如果<code>newCapacity &gt; MAX_ARRAY_SIZE </code>,那么<code>newCpapcity</code>的值由方法<code>hugeCapacity()</code>决定。这个后面再说，我们继续当前的分析，在执行完上面的判断语句之后，最后对<code>elemantData</code>进行重新赋值，核心方法<code>Arrays.copyOf(elementData, newCapacity)</code>,该方法的作用是将<code>newCapacity</code>的值复制给<code>elementData</code>。之后<code>elementData</code>里面将会存在<strong>10个null</strong>值.</li>
</ol>
</blockquote>
<p>就是说，当我们<strong>首次</strong>使用该集合的<strong>无参构造</strong>初始化集合时，其实并不会触发<strong>1.5倍的底层扩容机制</strong>。注意，这里使用<code>copyOf()</code>方法的作用也是为了<strong>保留扩容之前已经存在集合中的元素</strong>，换句话说，每次扩容并不会导致已存在的元素丢失，而是在这些元素之后添加<code>N</code>个值为<code>null</code>的元素空间。比如这样:</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#586e75;">//null值得位置就是扩容的容量
</span><span style="color:#657b83;">{</span><span style="color:#6c71c4;">1</span><span>,</span><span style="color:#6c71c4;">2</span><span>,</span><span style="color:#6c71c4;">3</span><span>,</span><span style="color:#6c71c4;">4</span><span>,</span><span style="color:#6c71c4;">5</span><span>,</span><span style="color:#6c71c4;">6</span><span>,</span><span style="color:#6c71c4;">7</span><span>,</span><span style="color:#6c71c4;">8</span><span>,</span><span style="color:#6c71c4;">9</span><span>,</span><span style="color:#6c71c4;">10</span><span>,</span><span style="color:#b58900;">null</span><span>,</span><span style="color:#b58900;">null</span><span>,</span><span style="color:#b58900;">null</span><span>,</span><span style="color:#b58900;">null</span><span>,</span><span style="color:#b58900;">null</span><span style="color:#657b83;">}
</span></code></pre>
<p>当以上扩容操作完成之后，执行会返回到之前的<code>add()</code>方法：</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">public </span><span style="color:#268bd2;">boolean </span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span style="color:#859900;">E</span><span> e</span><span style="color:#657b83;">) {
</span><span>    </span><span style="color:#b58900;">ensureCapacityInternal</span><span style="color:#657b83;">(</span><span>size </span><span style="color:#657b83;">+ </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">)</span><span>;  </span><span style="color:#586e75;">// Increments modCount!!
</span><span>    elementData[size</span><span style="color:#859900;">++</span><span>] </span><span style="color:#657b83;">=</span><span> e;
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#b58900;">true</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>此时的<code>elementData</code>已经由最初的空数组扩容为大小为10的容量，当执行完<code>elementData[size++] = e;</code>之后，新的容量中第一个位置会被替换为元素<code>1</code>:</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span>[</span><span style="color:#6c71c4;">1</span><span>,</span><span style="color:#b58900;">null</span><span>,</span><span style="color:#b58900;">null</span><span>,</span><span style="color:#b58900;">null</span><span>,</span><span style="color:#b58900;">null</span><span>,</span><span style="color:#b58900;">null</span><span>,</span><span style="color:#b58900;">null</span><span>,</span><span style="color:#b58900;">null</span><span>,</span><span style="color:#b58900;">null</span><span>,</span><span style="color:#b58900;">null</span><span>]
</span></code></pre>
<blockquote>
<p>注意理解<strong>minCapacity</strong>和<strong>elementData</strong>的含义。前者的意思时我们用这个集合存放某些元素<strong>最少需要的空间</strong>，而后者表示此时这个集合<strong>本身拥有的空间</strong>，所以，扩容的目的在于扩张<strong>elementData</strong>的大小，以满足存放<strong>minCapacity</strong>所需。</p>
</blockquote>
<p>现在来看一下上面留下的**hugeCapacity(minCapacity)**方法，源码如下：</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">private static </span><span style="color:#268bd2;">int </span><span style="color:#b58900;">hugeCapacity</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> minCapacity</span><span style="color:#657b83;">) {
</span><span> </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>minCapacity </span><span style="color:#657b83;">&lt; </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// overflow
</span><span>     </span><span style="color:#859900;">throw new OutOfMemoryError</span><span style="color:#657b83;">()</span><span>;
</span><span> </span><span style="color:#859900;">return </span><span style="color:#657b83;">(</span><span>minCapacity </span><span style="color:#657b83;">&gt; </span><span style="color:#cb4b16;">MAX_ARRAY_SIZE</span><span style="color:#657b83;">) </span><span style="color:#859900;">? Integer</span><span>.</span><span style="color:#cb4b16;">MAX_VALUE </span><span style="color:#859900;">: </span><span style="color:#cb4b16;">MAX_ARRAY_SIZE</span><span>;
</span><span style="color:#657b83;">}
</span><span style="color:#586e75;">//注意：以下是MAX_ARRAY_SIZE的常量定义。
</span><span style="color:#93a1a1;">private static final </span><span style="color:#268bd2;">int </span><span style="color:#cb4b16;">MAX_ARRAY_SIZE </span><span style="color:#657b83;">= </span><span style="color:#859900;">Integer</span><span>.</span><span style="color:#cb4b16;">MAX_VALUE </span><span style="color:#657b83;">- </span><span style="color:#6c71c4;">8</span><span>;
</span><span style="color:#586e75;">//2147483647是Integer.MAX_VALUE
</span></code></pre>
<p>这个方法其实就是对数组<strong>大小边界进行一个判断和限制</strong>，要求数组大小在<code>0</code>到<code>MAX_VALUE</code>之间。如果<code>&lt;0</code>直接抛出一个<code>OutOfMemoryError</code>异常，否则返回一个值作为数组容量的上限，这里用了一个三元表达式作为返回语句。</p>
<p>如果<code>最小容量大于MAX_ARRAY_SIZE，</code>则将<code>Integer.MAX_VALUE</code>的值赋给它，否则还是用<code>MAX_ARRAY_SIZE。</code></p>
<p>再看一下<strong>为什么这里****MAX_ARRAY_SIZE</strong>是<strong>Integer.MAX_VALUE-8</strong>，也即是**2147483647-8=2,147,483,639****而不是减其他数值？**关于这个问题，其实再源码的注释中就已经写清楚了。</p>
<p><img src="https://images.waer.ltd/img/20220322112254.png" alt="" /></p>
<p>大致意思就是如果直接使用<strong>Integer.MAX_VALUE</strong>的话，在某些虚拟机中，可能会出现溢出的问题。不过一般情况下，我们还是认为它的值可以直接看作是与<strong>Integer.MAX_VALUE</strong>相同。以下是来自<code>stackoverflow</code>的一个解答，可以参考一下。</p>
<p><a href="https://stackoverflow.com/questions/35756277/why-the-maximum-array-size-of-arraylist-is-integer-max-value-8">Why the maximum array size of ArrayList is Integer.MAX_VALUE - 8?</a></p>
<p><strong>有参构造的扩容原理</strong></p>
<p>上面分析了调用<strong>无参构造器</strong>创建集合后，它底层的扩容原理，其实只要理解了之后。那么关于<strong>有参构造</strong>的扩容，就很容易理解了。</p>
<p>下面是它的有参构造器源码，前面也提到过。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#586e75;">/**
</span><span style="color:#586e75;">     * Constructs an empty list with the specified initial capacity.
</span><span style="color:#586e75;">     *
</span><span style="color:#586e75;">     * </span><span style="color:#859900;">@param  </span><span style="color:#268bd2;">initialCapacity</span><span style="color:#586e75;">  the initial capacity of the list
</span><span style="color:#586e75;">     * </span><span style="color:#859900;">@throws </span><span style="color:#586e75;">IllegalArgumentException if the specified initial capacity
</span><span style="color:#586e75;">     *         is negative
</span><span style="color:#586e75;">     */
</span><span style="color:#586e75;">public ArrayList(int initialCapacity) {
</span><span style="color:#586e75;">    if (initialCapacity &gt; 0) {
</span><span style="color:#586e75;">        this.elementData = new Object[initialCapacity];
</span><span style="color:#586e75;">    } else if (initialCapacity == 0) {
</span><span style="color:#586e75;">        this.elementData = EMPTY_ELEMENTDATA;
</span><span style="color:#586e75;">    } else {
</span><span style="color:#586e75;">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+initialCapacity);
</span><span style="color:#586e75;">    }
</span><span style="color:#586e75;">}
</span></code></pre>
<p>这段代码很容易理解，我们在调用该构造器进行初始化时传入一个初始大小<code>initialCapacity</code>作为数组的<strong>初始容量</strong>。如果该容量<strong>大于0，<strong>此时<code>elementData</code>数组会直接</strong>用该值作为数组的长度创建一个新的<code>Object</code>数组，以完成初始化</strong>。否则如果传入的初始值为<code>0</code>，会对<code>elementData</code>进行一个常量赋值操作，将数组初始化为<code>EMPTY_ELEMENTDATA</code>大小的数组，该常量定义如下：</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">private static final </span><span style="color:#859900;">Object</span><span style="color:#93a1a1;">[] </span><span style="color:#cb4b16;">EMPTY_ELEMENTDATA </span><span style="color:#657b83;">= {}</span><span>;
</span></code></pre>
<p>也就是创建一个空数组。如果不在以上两种情况之外的，直接抛一个<strong>IllegalArgumentException</strong>异常结束。但是一般情况下，既然我们决定调用了该构造器，一般不会直接甩个<code>0</code>进去，这样做的意义不大。</p>
<p>在初始化完成后，进入添加方法，方法会先对现有的数组容量进行检查，如果发现所<strong>需最小容量大于当前初始化传入的容量</strong>，则会先进入<code>grow()</code>方法完成扩容，这里扩容不会进入第一个<code>if</code>判断，因为初始化传入的<code>elementData</code><strong>必然是大于0的</strong>，程序会直接执行源码中的<strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);<strong>这行逻辑，<strong>直接采取1.5倍扩容的机制</strong>对数组进行扩容后，将扩容后的整个数组空间直接复制一份，该操作会在原有元素的基础上追加扩容部分的空间，<strong>该部分的值默认使用null来填充</strong>，这些和前面分析</strong>无参构造扩容</strong>时候是一样的。此时再返回添加方法内部执行添加，添加成功之后之前扩容的<code>null</code>部分会被刚添加的元素取代，以此类推，直到下一次容量不够时，又再一次触发<code>1.5</code>b倍的扩容机制。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">private</span><span> void </span><span style="color:#b58900;">grow</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> minCapacity</span><span style="color:#657b83;">) {
</span><span> </span><span style="color:#586e75;">// overflow-conscious code
</span><span> </span><span style="color:#268bd2;">int</span><span> oldCapacity </span><span style="color:#657b83;">=</span><span> elementData.length;
</span><span> </span><span style="color:#268bd2;">int</span><span> newCapacity </span><span style="color:#657b83;">=</span><span> oldCapacity </span><span style="color:#657b83;">+ (</span><span>oldCapacity </span><span style="color:#859900;">&gt;&gt; </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">)</span><span>;
</span><span> </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>newCapacity </span><span style="color:#657b83;">-</span><span> minCapacity </span><span style="color:#657b83;">&lt; </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">)
</span><span>     newCapacity </span><span style="color:#657b83;">=</span><span> minCapacity;
</span><span> </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>newCapacity </span><span style="color:#657b83;">- </span><span style="color:#cb4b16;">MAX_ARRAY_SIZE </span><span style="color:#657b83;">&gt; </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">)
</span><span>     newCapacity </span><span style="color:#657b83;">= </span><span style="color:#b58900;">hugeCapacity</span><span style="color:#657b83;">(</span><span>minCapacity</span><span style="color:#657b83;">)</span><span>;
</span><span> </span><span style="color:#586e75;">// minCapacity is usually close to size, so this is a win:
</span><span> elementData </span><span style="color:#657b83;">= </span><span style="color:#859900;">Arrays</span><span>.</span><span style="color:#b58900;">copyOf</span><span style="color:#657b83;">(</span><span>elementData, newCapacity</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p><strong>实例演示</strong></p>
<p>通过一个具体的例子，来解释帮助理解上面所说的扩容原理(无参构造)。</p>
<ul>
<li><strong>无参构造器</strong></li>
</ul>
<blockquote>
<p>假设我们调用 了<code>ArrayList()</code>对集合<code>list</code>进行了初始化并尝试向其中添加元素，下面模拟这个大致过程：</p>
<ol>
<li>初始化完成，创建一个空的对象数组<code>elementData[] = {}</code>。</li>
<li>进入<code>add()</code>方法，根据当前添加元素所需空间对已有空间进行判断，显然我们添加第一个元素时，<code>minCapacity=1,</code>而<code>elementData=0。</code></li>
<li>此时不忙着执行添加，而是调用<code>ensureCapacityInternal()</code>方法：
<ol>
<li>该方法发现，初始化的<code>elementData=DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，则执行一个<code>Math.max()</code>方法，该方法直接将<code>minCapacity</code>的值改为<code>10</code>。此时我们的<code>minCapacity=10</code>,而<code>elementData</code>还是<code>0</code>；</li>
<li>进入**<code>ensureExplicitCapacity()</code>**方法，满足判断条件发现，<strong>所需最小容量&gt;当前容量</strong>，需要扩容，触发<code>grow()</code>方法。
<ol>
<li>检查并记录<code>elementData</code>的长度，发现此时该值为<code>0</code>，<strong>由于0的1.5倍还是0，此时扩容算法无意义不执行。</strong></li>
<li>进入第一个<code>if</code>判断，发现条件满足，直接将<code>minCapacity</code>的值赋给一个新的变量<code>newCapacity=10</code></li>
<li>执行数组的<code>copyOf()</code>方法，将会开辟一个容量为<code>10</code>的数组。</li>
<li>程序跳回<code>add()</code>方法，执行元素的添加。</li>
<li><code>add()</code>方法执行结束。</li>
</ol>
</li>
</ol>
</li>
</ol>
</blockquote>
<p><strong>也就是说，如果我们调用无参构造器初始化集合，首次扩容并不会按照<code>1.5</code>倍的机制来，而是直接给你开一个大小为<code>10</code>的数组，只有当这<code>10</code>个空间全部用完之后，之后的每一次扩容，就都会采用<code>1.5</code>倍的机制进行扩容，因此首次调用的方法栈是比较绕的，但是从第二次开始，或者使用有参构造器初始化的时候就会少一些判断，空间不够，直接开始<code>1.5</code>倍扩容机制走起。</strong></p>
<h5 id="1-5bei-kuo-rong-zen-yao-suan">1.5倍扩容怎么算？<a class="zola-anchor" href="#1-5bei-kuo-rong-zen-yao-suan" aria-label="Anchor link for: 1-5bei-kuo-rong-zen-yao-suan">🔗</a></h5>
<blockquote>
<p>假设当前容量值为<code>8</code>，下一次扩容的值就是<code>12</code>，算法过程很简单：</p>
<p>12 = 8+8/2</p>
<p>= 8+4</p>
<p>=12</p>
<p>只不过，在源代码中，算法使用右移<code>&gt;&gt;</code>代替除法，要知道，<strong>位运算的速度是远快于四则运算的</strong>。由此，如果需要再次扩容的话，<code>12</code>的容量会扩容为<code>12+6 = 18</code>。</p>
</blockquote>
<hr />
<h4 id="vector"><code>Vector</code><a class="zola-anchor" href="#vector" aria-label="Anchor link for: vector">🔗</a></h4>
<h5 id="ji-ben-jie-gou">基本结构<a class="zola-anchor" href="#ji-ben-jie-gou" aria-label="Anchor link for: ji-ben-jie-gou">🔗</a></h5>
<p><code>Vector</code>类的定义，它实现自<code>List</code>接口。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">public </span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Vector</span><span>&lt;</span><span style="color:#268bd2;">E</span><span>&gt;
</span><span>    </span><span style="color:#859900;">extends </span><span style="color:#268bd2;">AbstractList</span><span>&lt;</span><span style="color:#859900;">E</span><span>&gt;
</span><span>    </span><span style="color:#859900;">implements </span><span style="color:#268bd2;">List</span><span>&lt;</span><span style="color:#859900;">E</span><span>&gt;, </span><span style="color:#268bd2;">RandomAccess</span><span>, </span><span style="color:#268bd2;">Cloneable</span><span>, </span><span style="color:#268bd2;">java</span><span>.</span><span style="color:#268bd2;">io</span><span>.</span><span style="color:#268bd2;">Serializable
</span></code></pre>
<p>它的底层实现也是基于对象数组，它由<code>protected</code>修饰符修饰：</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">protected </span><span style="color:#859900;">Object</span><span style="color:#93a1a1;">[]</span><span> elementData;
</span></code></pre>
<p><code>Vector</code>是线程安全的，它的操作方法都有<code>synchronized</code>修饰，该关键字可以实现线程同步和互斥，所以他是线程安全的。比如其源码中的<code>indexOf()</code>方法，因此，一般在开发中，如果有线程安全的需要，可以考虑使用<code>Vector</code>。当然，这也并非是必须的，关于线程安全的集合或者说实现，还有专门的类去管理，<code>Vector</code>在<code>JDK1.0</code>版本中就有的，算是一个老前辈了，尽管它线程安全，但也不一定就是最佳的选择。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">public synchronized </span><span style="color:#268bd2;">int </span><span style="color:#b58900;">indexOf</span><span style="color:#657b83;">(</span><span style="color:#859900;">Object</span><span> o, </span><span style="color:#268bd2;">int</span><span> index</span><span style="color:#657b83;">) {
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>o </span><span style="color:#657b83;">== </span><span style="color:#b58900;">null</span><span style="color:#657b83;">) {
</span><span>        </span><span style="color:#859900;">for </span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> i </span><span style="color:#657b83;">=</span><span> index ; i </span><span style="color:#657b83;">&lt;</span><span> elementCount ; i</span><span style="color:#859900;">++</span><span style="color:#657b83;">)
</span><span>            </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>elementData[i]</span><span style="color:#657b83;">==</span><span style="color:#b58900;">null</span><span style="color:#657b83;">)
</span><span>                </span><span style="color:#859900;">return</span><span> i;
</span><span>    </span><span style="color:#657b83;">} </span><span style="color:#859900;">else </span><span style="color:#657b83;">{
</span><span>        </span><span style="color:#859900;">for </span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> i </span><span style="color:#657b83;">=</span><span> index ; i </span><span style="color:#657b83;">&lt;</span><span> elementCount ; i</span><span style="color:#859900;">++</span><span style="color:#657b83;">)
</span><span>            </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>o.</span><span style="color:#b58900;">equals</span><span style="color:#657b83;">(</span><span>elementData[i]</span><span style="color:#657b83;">))
</span><span>                </span><span style="color:#859900;">return</span><span> i;
</span><span>    </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#657b83;">-</span><span style="color:#6c71c4;">1</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<h5 id="yuan-ma-fen-xi-1">源码分析<a class="zola-anchor" href="#yuan-ma-fen-xi-1" aria-label="Anchor link for: yuan-ma-fen-xi-1">🔗</a></h5>
<h6 id="kuo-rong-ji-zhi"><strong>扩容机制</strong><a class="zola-anchor" href="#kuo-rong-ji-zhi" aria-label="Anchor link for: kuo-rong-ji-zhi">🔗</a></h6>
<p><strong>默认10满后，按照2倍扩容。如果指定大小，则每次按2倍扩容。</strong></p>
<p><strong>创建一个无参的vector之后，它会默认直接给你一个大小为10的空间。直截了当。</strong></p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">public </span><span style="color:#b58900;">Vector</span><span style="color:#657b83;">() {
</span><span>    </span><span style="color:#d33682;">this</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">10</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>接着执行添加操作，跳转到<code>add()</code>方法(这里就不再提自动装箱的操作了)，源码如下,咋一看是不是和前面分析的<code>ArrayList</code>的源码如出一辙？除了一个<code>modCount++</code>之外，还是会在添加元素之前先执行一个名为<code>ensureCapacityHelper</code>的方法，基于前面<code>ArrayList</code>源码的阅读理解，这里不用多想也能猜到，这个方法的作用，无非就是对目前的数组容量进行判断，看看是不是需要扩容。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">public synchronized </span><span style="color:#268bd2;">boolean </span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span style="color:#859900;">E</span><span> e</span><span style="color:#657b83;">) {
</span><span>    modCount</span><span style="color:#859900;">++</span><span>;
</span><span>    </span><span style="color:#b58900;">ensureCapacityHelper</span><span style="color:#657b83;">(</span><span>elementCount </span><span style="color:#657b83;">+ </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">)</span><span>;
</span><span>    elementData[elementCount</span><span style="color:#859900;">++</span><span>] </span><span style="color:#657b83;">=</span><span> e;
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#b58900;">true</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>进入<code>ensureCapacityHelper</code>的源码看看,可以看到这实现和<code>ArrayList</code>中的实现几乎一样，还是判断最小所需空间和当前数组的容量关系，显然，这里<code>elementData=10,</code>而<code>minCapacity=1</code>，<strong>不满足扩容的条件</strong>，因此这里不会进入<code>grow()</code>方法。直接返回<code>add()</code>执行元素的添加，一次添加执行结束。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">private</span><span> void </span><span style="color:#b58900;">ensureCapacityHelper</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> minCapacity</span><span style="color:#657b83;">) {
</span><span>    </span><span style="color:#586e75;">// overflow-conscious code
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>minCapacity </span><span style="color:#657b83;">-</span><span> elementData.length </span><span style="color:#657b83;">&gt; </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">)
</span><span>        </span><span style="color:#b58900;">grow</span><span style="color:#657b83;">(</span><span>minCapacity</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>下面我们假设，要添加第<code>11</code>个元素，此时原来的10个空间已经不够，自然会触发扩容机制，下面是该扩容方法的实现源码：</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#586e75;">// 扩容方法
</span><span style="color:#93a1a1;">private</span><span> void </span><span style="color:#b58900;">grow</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> minCapacity</span><span style="color:#657b83;">) {
</span><span>    </span><span style="color:#586e75;">// overflow-conscious code
</span><span>    </span><span style="color:#268bd2;">int</span><span> oldCapacity </span><span style="color:#657b83;">=</span><span> elementData.length;
</span><span>    </span><span style="color:#268bd2;">int</span><span> newCapacity </span><span style="color:#657b83;">=</span><span> oldCapacity </span><span style="color:#657b83;">+ ((</span><span>capacityIncrement </span><span style="color:#657b83;">&gt; </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">) </span><span style="color:#859900;">?</span><span> capacityIncrement </span><span style="color:#859900;">:</span><span> oldCapacity</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>newCapacity </span><span style="color:#657b83;">-</span><span> minCapacity </span><span style="color:#657b83;">&lt; </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">)
</span><span>        newCapacity </span><span style="color:#657b83;">=</span><span> minCapacity;
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>newCapacity </span><span style="color:#657b83;">- </span><span style="color:#cb4b16;">MAX_ARRAY_SIZE </span><span style="color:#657b83;">&gt; </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">)
</span><span>        newCapacity </span><span style="color:#657b83;">= </span><span style="color:#b58900;">hugeCapacity</span><span style="color:#657b83;">(</span><span>minCapacity</span><span style="color:#657b83;">)</span><span>;
</span><span>    elementData </span><span style="color:#657b83;">= </span><span style="color:#859900;">Arrays</span><span>.</span><span style="color:#b58900;">copyOf</span><span style="color:#657b83;">(</span><span>elementData, newCapacity</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#657b83;">}
</span><span style="color:#586e75;">// 关于capacityIncrement的定义：
</span><span>   </span><span style="color:#586e75;">/**
</span><span style="color:#586e75;">     * The amount by which the capacity of the vector is automatically
</span><span style="color:#586e75;">     * incremented when its size becomes greater than its capacity.  If
</span><span style="color:#586e75;">     * the capacity increment is less than or equal to zero, the capacity
</span><span style="color:#586e75;">     * of the vector is doubled each time it needs to grow.
</span><span style="color:#586e75;">     *
</span><span style="color:#586e75;">     * </span><span style="color:#859900;">@serial
</span><span style="color:#586e75;">     */
</span><span style="color:#586e75;">    protected int capacityIncrement;
</span></code></pre>
<p>根据源码了解到，它会先将<code>elementData</code>的长度放到一个名为<code>oldCapacity</code>的变量中并创建一个新的容量<code>newCapacity</code>,该变量的值就是扩容的核心原理，其中<code> int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity)</code>这段三元表达式会先判断<code>capacityIncrement</code>的值是否<code>&gt;0</code>,如果成立，那么<code>capacityIncrement</code>的值保持不变，那么整个表达式就是<code>newCapacity = oldCapacity+capacityIncrement</code>。</p>
<p>否则将会是<code>newCapacity =oldCapacity+oldCapactity</code>,也就<code>newCapacity </code>会<strong>变为原来两倍的容量，<strong>最后依旧是采用<code>copyOf()</code>方法将扩容后的空间复制到原空间，完成扩容。关于其中两个<code>if</code>判断的逻辑和之前对<code>ArrayList</code>的分析是类似的，不再赘述。通过这个源码也发现了，这个<code>2</code>倍扩容的算法中，有一个名为<code>capacityIncrement</code>的</strong>容量增量</strong>，具体作用面会在下面有参构造器中进行分析。</p>
<p><strong>有参构造器源码分析</strong></p>
<p>该构造器的源码如下，构造器是有两个参数的，其中一个便是上面提到的容量增量参数<code>capacityIncrement</code>。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">public </span><span style="color:#b58900;">Vector</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> initialCapacity, </span><span style="color:#268bd2;">int</span><span> capacityIncrement</span><span style="color:#657b83;">) {
</span><span>    </span><span style="color:#d33682;">super</span><span style="color:#657b83;">()</span><span>;
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>initialCapacity </span><span style="color:#657b83;">&lt; </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">)
</span><span>        </span><span style="color:#859900;">throw new IllegalArgumentException</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">Illegal Capacity: </span><span>&quot;</span><span style="color:#657b83;">+
</span><span>                                           initialCapacity</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#d33682;">this</span><span>.elementData </span><span style="color:#657b83;">= </span><span style="color:#859900;">new Object</span><span style="color:#268bd2;">[</span><span>initialCapacity</span><span style="color:#268bd2;">]</span><span>;
</span><span>    </span><span style="color:#d33682;">this</span><span>.capacityIncrement </span><span style="color:#657b83;">=</span><span> capacityIncrement;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>方法体首先会先调用父类的无参构造。如果我们不指定<code>capacityIncrement</code>的值，它默认是<code>0</code>，也就是<strong>无增量</strong>，一般在调用无参构造器时就是属于这种情况，**在没有明确容量增量时，扩容会按照原容量的2两倍进行，**如果指定具体的值，我们在<code>grow()</code>方法中看到，<code>  int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity);</code>这个表达式将产生一个新的容量值，<strong>该值的大小由原来的容量+指定的容量增量决定</strong>。那么可能会开始疑惑， 既然说了是<code>2</code>倍扩容，那么加一个容量增量算怎么回事？</p>
<p>如果指定了该增量的值，不就改变了2倍扩容的机制了吗？其实不完全是，在<code>vector</code>源码中，其实存在三个构造器，上面这个便是可以指定扩容增量的构造器，如果你不需要指定第二个参数，那么还可以看到，它还有一个普通的带一个参数的构造，源码如下：</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">public </span><span style="color:#b58900;">Vector</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> initialCapacity</span><span style="color:#657b83;">) {
</span><span>    </span><span style="color:#d33682;">this</span><span style="color:#657b83;">(</span><span>initialCapacity, </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>该构造器尽管只需要一个参数，但它在创建之后会默认给<code>capacityIncrement</code>赋值为0，这也就是不管你是空参构造还是带参构造对<code>Vector</code>进行初始化，在扩容时都会用到<code>capacityIncrement</code>这样一个参数，这也是扩容算法中三元表达式的意义，<strong>你可以不写，但我必须得用</strong>，所以才会有默认的<code>0</code>,这是不冲突的。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#586e75;">/*无参构造*/
</span><span style="color:#859900;">Vector</span><span> vector </span><span style="color:#657b83;">= </span><span style="color:#859900;">new Vector</span><span style="color:#657b83;">()</span><span>;
</span><span style="color:#586e75;">/*指定一个参数：默认为集合的初始大小*/
</span><span style="color:#859900;">Vector</span><span> vector2 </span><span style="color:#657b83;">= </span><span style="color:#859900;">new Vector</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">6</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#586e75;">/*指定两个参数：依次时集合大小和扩容时的容量增量*/
</span><span style="color:#859900;">Vector</span><span> vector3</span><span style="color:#657b83;">= </span><span style="color:#859900;">new Vector</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">6</span><span>,</span><span style="color:#6c71c4;">3</span><span style="color:#657b83;">)</span><span>;
</span></code></pre>
<hr />
<h4 id="linkedlist"><code>LinkedList</code><a class="zola-anchor" href="#linkedlist" aria-label="Anchor link for: linkedlist">🔗</a></h4>
<h5 id="ji-ben-jie-gou-1">基本结构<a class="zola-anchor" href="#ji-ben-jie-gou-1" aria-label="Anchor link for: ji-ben-jie-gou-1">🔗</a></h5>
<ul>
<li><code>LinkedList</code>底层实现采用了<strong>双向链表</strong>和<strong>双端队列</strong>。</li>
<li>可以添加任意元素且元素可以重复(因为实现自List接口)，同时包括<code>null</code>。</li>
<li>非线程安全的集合，没有实现同步。</li>
<li>在其中维护的两个属性<code>first</code>和<code>last</code>分别指向首尾节点，<code>prev</code>指向前驱节点，<code>next</code>指向后继节点。</li>
<li>因此<code>LinkedList</code>的元素<strong>删除和添加的操作效率相对较高</strong>。</li>
</ul>
<h5 id="yuan-ma-fen-xi-2">源码分析<a class="zola-anchor" href="#yuan-ma-fen-xi-2" aria-label="Anchor link for: yuan-ma-fen-xi-2">🔗</a></h5>
<p>[待更新……]</p>
<h4 id="ru-he-xuan-ze">如何选择<a class="zola-anchor" href="#ru-he-xuan-ze" aria-label="Anchor link for: ru-he-xuan-ze">🔗</a></h4>
<blockquote>
<p>如何选择使用<code>ArrayList</code>和<code>LinkedList</code>?根据我们实际的使用场景或者需求</p>
</blockquote>
<ul>
<li>如果涉及改查操作比较多，建议<code>ArrayList</code>。</li>
<li>如果增删操作比较多，建议<code>LinkedList</code>。</li>
<li>一般来说，在程序中<code>80%~90%</code>都是查询操作，因此大部分情况下会选择使用<code>ArrayList</code>。</li>
<li>当然，选择哪一个并非一成不变，在实际的项目中，甚至可能出现<code>ArrayList</code>和<code>LinkedList</code>同时使用的情况，也是正常的，所以要求最好都会使用。</li>
</ul>
<hr />
<h4 id="setjie-kou"><code>Set</code>接口<a class="zola-anchor" href="#setjie-kou" aria-label="Anchor link for: setjie-kou">🔗</a></h4>
<p>下面主要讲解<code>Set</code>子接口下的主要实现类。</p>
<p><strong>常用方法和实现</strong></p>
<p><img src="https://images.waer.ltd/img/Set.png" alt="" /></p>
<p><strong>Set的基本介绍</strong></p>
<ul>
<li>
<p>无序(元素的添加与取出的顺序不一致)，无索引。</p>
<blockquote>
<p>注意理解这里的无序的含义，并不是说，每一次取出的顺序都是随机的，而是指当执行了一次取出之后，今后的每一次相同的操作，它取出的元素顺序都与第一次相同，但<strong>这个顺序又和添加进去的顺序不保持一致</strong>。</p>
</blockquote>
</li>
<li>
<p>不允许重复元素。</p>
</li>
<li>
<p>还有一点，由于它是<code>Collection</code>的子接口，自然也支持其父接口中的特性，比如迭代对象，增强for等等。</p>
</li>
</ul>
<h4 id="hashset"><code>HashSet</code><a class="zola-anchor" href="#hashset" aria-label="Anchor link for: hashset">🔗</a></h4>
<h5 id="ji-ben-jie-gou-2">基本结构<a class="zola-anchor" href="#ji-ben-jie-gou-2" aria-label="Anchor link for: ji-ben-jie-gou-2">🔗</a></h5>
<blockquote>
<p><code>HashSet</code>作为<code>Set</code>典型的实现类之一，拥有<code>Set</code>的全部属性，这里不再赘述。</p>
</blockquote>
<h5 id="yuan-ma-jie-du">源码解读<a class="zola-anchor" href="#yuan-ma-jie-du" aria-label="Anchor link for: yuan-ma-jie-du">🔗</a></h5>
<h6 id="chu-shi-hua-yu-ji-ben-yuan-li">初始化与基本原理<a class="zola-anchor" href="#chu-shi-hua-yu-ji-ben-yuan-li" aria-label="Anchor link for: chu-shi-hua-yu-ji-ben-yuan-li">🔗</a></h6>
<p>我们先看一下<code>HashSet</code>的基本用法，其实，<code>HashSet</code>在实现上，就是一个<code>HashMap</code>,这一点可以从它的构造器说起。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span> </span><span style="color:#859900;">Set</span><span> hashSet </span><span style="color:#657b83;">= </span><span style="color:#859900;">new HashSet</span><span style="color:#657b83;">()</span><span>;
</span></code></pre>
<p>以下是<code>HashSet</code>的无参构造器源码，可以看到，当我们创建一个<code>HashSet</code>对象时，它在底层直接<code>new</code>了一个<code>HashMap</code>，这又不得不说一下<code>HashMap</code>的底层，它是由<strong>数组+链表+红黑树</strong>构成，所以相对来说是比较复杂的。</p>
<p><img src="https://images.waer.ltd/img/20220323200228.png" alt="" /></p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">public </span><span style="color:#b58900;">HashSet</span><span style="color:#657b83;">() {
</span><span>    map </span><span style="color:#657b83;">= </span><span style="color:#859900;">new HashMap</span><span>&lt;&gt;</span><span style="color:#657b83;">()</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>换句话说，要分析<code>HashSet</code>的源码，其实就是分析<code>HashMap</code>的原理。<code>HashSet</code>一个明显的特点就是不能添加重复的元素，但这里的<strong>重复</strong>也许不是你想象中的那么简单。</p>
<p>下面开始分析一下其中的添加元素的<code>add()</code>方法在底层是如何实现的。</p>
<blockquote>
<ul>
<li><strong>添加一个元素时，会先得到一个<code>hash</code>值，根据该值转成一个索引值。</strong></li>
<li><strong>找到存储数据表<code>table</code>，检查该索引是否已在<code>table</code>中存在有元素</strong>：
<ul>
<li><strong>如果没有，直接将该元素加入。</strong></li>
<li><strong>如果有，会调用<code>equals</code>方法进行比较操作，如果比较结果为<code>true</code>,添加失败，否则，将会在末尾添加元素。</strong></li>
<li><strong>在<code>Java8</code>中，如果一条链表的元素个数达到<code>TREEIFY_THRESHOLD</code>且<code>table</code>的大小<code>&gt;=</code>MIN_TREEIFY_CAPACITY,就会触发树化机制，即会由单链表结构转换为一棵红黑树。</strong></li>
</ul>
</li>
</ul>
</blockquote>
<p>为例更好的理解它的执行过程和原理，我们按照下面这几行代码来讲解:</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">HashSet</span><span> hashSet </span><span style="color:#657b83;">= </span><span style="color:#859900;">new HashSet</span><span style="color:#657b83;">()</span><span>;
</span><span>hashSet.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">Java</span><span>&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span>hashSet.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">C++</span><span>&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span>hashSet.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">Java</span><span>&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">hashSet=</span><span>&quot;</span><span style="color:#657b83;">+</span><span>hashSet</span><span style="color:#657b83;">)</span><span>;
</span></code></pre>
<p>代码逻辑很简单，就是向<code>HashSet</code>中添加三个元素，其中有<strong>两个元素是重复</strong>的，这是为了理解它底层是如何判断元素重复的。</p>
<p>执行代码，首先会进入<code>HashSet</code>的构造器，直接创建一个值为空的<code>HashMap</code>，这点在上面已经说过。进入<code>add()</code>方法，它的实现源码如下：</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#586e75;">//HashSet中add方法的源码实现
</span><span style="color:#93a1a1;">public </span><span style="color:#268bd2;">boolean </span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span style="color:#859900;">E</span><span> e</span><span style="color:#657b83;">) {
</span><span>    </span><span style="color:#859900;">return</span><span> map.</span><span style="color:#b58900;">put</span><span style="color:#657b83;">(</span><span>e, </span><span style="color:#cb4b16;">PRESENT</span><span style="color:#657b83;">)==</span><span style="color:#b58900;">null</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>方法很简单，直接调用了<code>map</code>的<code>put()</code>方法,注意到，这个方法除了我们需要添加的元素<code>e</code>之外，它还有一个名为<code>PRESENT</code>的常量参数，关于这个参数的理解，源码中是这样介绍的：</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#586e75;">// Dummy value to associate with an Object in the backing Map
</span><span style="color:#93a1a1;">private static final </span><span style="color:#859900;">Object </span><span style="color:#cb4b16;">PRESENT </span><span style="color:#657b83;">= </span><span style="color:#859900;">new Object</span><span style="color:#657b83;">()</span><span>;
</span></code></pre>
<p><code>PRESENT</code>其实是一个<code>static final</code>修饰的对象，在上面的方法中作为<code>put(k,v)</code>中<code>value</code>的占位，并没有其他实际的作用。这里不必深究。不知道有没有注意到，<code>add</code>方法中将<code>map.put(e,PRESENT)==null</code>作为返回值，为什么这里会是<code>null</code>呢？这和<code>HashMap</code>底层实现有关系，我们先继续往下，后面自然就会明白了。下面进入<code>put</code>方法内部看看。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#586e75;">//HashSet中map.put(e,PERSENT)方法源码
</span><span style="color:#93a1a1;">public </span><span style="color:#859900;">V </span><span style="color:#b58900;">put</span><span style="color:#657b83;">(</span><span style="color:#859900;">K</span><span> key, </span><span style="color:#859900;">V</span><span> value</span><span style="color:#657b83;">) {
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#b58900;">putVal</span><span style="color:#657b83;">(</span><span style="color:#b58900;">hash</span><span style="color:#657b83;">(</span><span>key</span><span style="color:#657b83;">)</span><span>, key, value, </span><span style="color:#b58900;">false</span><span>, </span><span style="color:#b58900;">true</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>方法中有一个<code>putVal</code>的方法，可以看到其中的第一个参数<code>hash(key)</code>表示通过这个方法获取<code>key</code>的<code>hash</code>值。这里的<code>key</code>也就是我们传入的待添加的元素，进入该方法：果然，<code>hash</code>方法的作用就是计算<code>key</code>的<code>hash值</code>，算法都在这条三元表达式当中了，可以简单看一下。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#586e75;">//HashMap中的hash()方法实现
</span><span style="color:#93a1a1;">static final </span><span style="color:#268bd2;">int </span><span style="color:#b58900;">hash</span><span style="color:#657b83;">(</span><span style="color:#859900;">Object</span><span> key</span><span style="color:#657b83;">) {
</span><span>    </span><span style="color:#268bd2;">int</span><span> h;
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#657b83;">(</span><span>key </span><span style="color:#657b83;">== </span><span style="color:#b58900;">null</span><span style="color:#657b83;">) </span><span style="color:#859900;">? </span><span style="color:#6c71c4;">0 </span><span style="color:#859900;">: </span><span style="color:#657b83;">(</span><span>h </span><span style="color:#657b83;">=</span><span> key.</span><span style="color:#b58900;">hashCode</span><span style="color:#657b83;">()) </span><span style="color:#859900;">^ </span><span style="color:#657b83;">(</span><span>h </span><span style="color:#859900;">&gt;&gt;&gt; </span><span style="color:#6c71c4;">16</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>核心算法<code>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，意思就是如果传入的<code>key</code>为<code>null</code>,那么直接返回0，也就是不执行任何实际操作。<strong>否则会使用<code>hashCode()</code>方法获取<code>key</code>的哈希码和无符号右移16位之后的值进行一个异或操作</strong>，将该异或的结果返回作为<code>key</code>最终的<code>hash</code>值。这样作主要是为了保证<strong>高16位和低16未的特征，减少碰撞，减低<code>hash</code>冲突的几率</strong>。</p>
<p>注意，<code>hash</code>和<code>hashCode</code>并不是一回事。</p>
<blockquote>
<p>这里的<code>hash</code>仅仅是用来在<code>HashMap</code>中计算<code>key</code>对应的散列码。它的算法中用到了<code>hashCode()</code>这个方法，<code>hashCode</code>是在<code>Objct</code>中定义的，用来获取每个元素对应的散列值，<strong>底层使用的C语言作为实现</strong>,属于<code>native</code>方法。换句话说，使用<code>hashCode()</code>方法可以计算<code>Java</code>中每一个元素的一个哈希值。而<code>hash()</code>方法在这里的作就相对局限，使用的算法也相对简单很多，具体的关于<code>hash和hashCode()</code>的内容，可以自己研究，这里不作展开。</p>
</blockquote>
<p>理解了<code>hash</code>的计算方式之后，继续往后看，在获取到<code>key</code>的<code>hash</code>，方法会返回进入到<code>putVal()</code>方法中，这是整个添加操作的底层实现的核心源码，也是一个难点。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">final </span><span style="color:#859900;">V </span><span style="color:#b58900;">putVal</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> hash, </span><span style="color:#859900;">K</span><span> key, </span><span style="color:#859900;">V</span><span> value, </span><span style="color:#268bd2;">boolean</span><span> onlyIfAbsent,
</span><span>               </span><span style="color:#268bd2;">boolean</span><span> evict</span><span style="color:#657b83;">) {
</span><span>    </span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt;</span><span style="color:#93a1a1;">[]</span><span> tab; </span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt; p; </span><span style="color:#268bd2;">int</span><span> n, i;
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">((</span><span>tab </span><span style="color:#657b83;">=</span><span> table</span><span style="color:#657b83;">) == </span><span style="color:#b58900;">null </span><span style="color:#859900;">|| </span><span style="color:#657b83;">(</span><span>n </span><span style="color:#657b83;">=</span><span> tab.length</span><span style="color:#657b83;">) == </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">)
</span><span>        n </span><span style="color:#657b83;">= (</span><span>tab </span><span style="color:#657b83;">= </span><span style="color:#b58900;">resize</span><span style="color:#657b83;">())</span><span>.length;
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">((</span><span>p </span><span style="color:#657b83;">=</span><span> tab[i </span><span style="color:#657b83;">= (</span><span>n </span><span style="color:#657b83;">- </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">) </span><span style="color:#859900;">&amp;</span><span> hash]</span><span style="color:#657b83;">) == </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)
</span><span>        tab[i] </span><span style="color:#657b83;">= </span><span style="color:#b58900;">newNode</span><span style="color:#657b83;">(</span><span>hash, key, value, </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#859900;">else </span><span style="color:#657b83;">{
</span><span>        </span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt; e; </span><span style="color:#859900;">K</span><span> k;
</span><span>        </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>p.hash </span><span style="color:#657b83;">==</span><span> hash </span><span style="color:#859900;">&amp;&amp;</span><span style="color:#657b83;">((</span><span>k </span><span style="color:#657b83;">=</span><span> p.key</span><span style="color:#657b83;">) ==</span><span> key </span><span style="color:#859900;">|| </span><span style="color:#657b83;">(</span><span>key </span><span style="color:#657b83;">!= </span><span style="color:#b58900;">null </span><span style="color:#859900;">&amp;&amp;</span><span> key.</span><span style="color:#b58900;">equals</span><span style="color:#657b83;">(</span><span>k</span><span style="color:#657b83;">))))
</span><span>            e </span><span style="color:#657b83;">=</span><span> p;
</span><span>        </span><span style="color:#859900;">else if </span><span style="color:#657b83;">(</span><span>p </span><span style="color:#859900;">instanceof TreeNode</span><span style="color:#657b83;">)
</span><span>            e </span><span style="color:#657b83;">= ((</span><span style="color:#859900;">TreeNode</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt;</span><span style="color:#657b83;">)</span><span>p</span><span style="color:#657b83;">)</span><span>.</span><span style="color:#b58900;">putTreeVal</span><span style="color:#657b83;">(</span><span style="color:#d33682;">this</span><span>, tab, hash, key, value</span><span style="color:#657b83;">)</span><span>;
</span><span>        </span><span style="color:#859900;">else </span><span style="color:#657b83;">{
</span><span>            </span><span style="color:#859900;">for </span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> binCount </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">0</span><span>; ; </span><span style="color:#859900;">++</span><span>binCount</span><span style="color:#657b83;">) {
</span><span>                </span><span style="color:#859900;">if </span><span style="color:#657b83;">((</span><span>e </span><span style="color:#657b83;">=</span><span> p.next</span><span style="color:#657b83;">) == </span><span style="color:#b58900;">null</span><span style="color:#657b83;">) {
</span><span>                    p.next </span><span style="color:#657b83;">= </span><span style="color:#b58900;">newNode</span><span style="color:#657b83;">(</span><span>hash, key, value, </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)</span><span>;
</span><span>                    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>binCount </span><span style="color:#657b83;">&gt;= </span><span style="color:#cb4b16;">TREEIFY_THRESHOLD </span><span style="color:#657b83;">- </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// -1 for 1st
</span><span>                        </span><span style="color:#b58900;">treeifyBin</span><span style="color:#657b83;">(</span><span>tab, hash</span><span style="color:#657b83;">)</span><span>;
</span><span>                    </span><span style="color:#859900;">break</span><span>;
</span><span>                </span><span style="color:#657b83;">}
</span><span>                </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>e.hash </span><span style="color:#657b83;">==</span><span> hash </span><span style="color:#859900;">&amp;&amp;</span><span style="color:#657b83;">((</span><span>k </span><span style="color:#657b83;">=</span><span> e.key</span><span style="color:#657b83;">) ==</span><span> key </span><span style="color:#859900;">|| </span><span style="color:#657b83;">(</span><span>key </span><span style="color:#657b83;">!= </span><span style="color:#b58900;">null </span><span style="color:#859900;">&amp;&amp;</span><span> key.</span><span style="color:#b58900;">equals</span><span style="color:#657b83;">(</span><span>k</span><span style="color:#657b83;">))))
</span><span>                    </span><span style="color:#859900;">break</span><span>;
</span><span>                p </span><span style="color:#657b83;">=</span><span> e;
</span><span>            </span><span style="color:#657b83;">}
</span><span>        </span><span style="color:#657b83;">}
</span><span>        </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>e </span><span style="color:#657b83;">!= </span><span style="color:#b58900;">null</span><span style="color:#657b83;">) { </span><span style="color:#586e75;">// existing mapping for key
</span><span>            </span><span style="color:#859900;">V</span><span> oldValue </span><span style="color:#657b83;">=</span><span> e.value;
</span><span>            </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span style="color:#859900;">!</span><span>onlyIfAbsent </span><span style="color:#859900;">||</span><span> oldValue </span><span style="color:#657b83;">== </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)
</span><span>                e.value </span><span style="color:#657b83;">=</span><span> value;
</span><span>            </span><span style="color:#b58900;">afterNodeAccess</span><span style="color:#657b83;">(</span><span>e</span><span style="color:#657b83;">)</span><span>;
</span><span>            </span><span style="color:#859900;">return</span><span> oldValue;
</span><span>        </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#859900;">++</span><span>modCount;
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span style="color:#859900;">++</span><span>size </span><span style="color:#657b83;">&gt;</span><span> threshold</span><span style="color:#657b83;">)
</span><span>        </span><span style="color:#b58900;">resize</span><span style="color:#657b83;">()</span><span>;
</span><span>    </span><span style="color:#b58900;">afterNodeInsertion</span><span style="color:#657b83;">(</span><span>evict</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#b58900;">null</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>在方法体的开始，定义了几个局部变量，以备后面使用(废话)。继续看下面的代码，这是方法体的第一个if判断，主要的作用是判断并创建一个<code>table</code>，注意，这里的<code>table</code>是一个数组+链表形式的结构，也就是数组每一个索引出的元素都是一条单链表的形式。这一点前面有提到。具体的逻辑是，</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">if </span><span style="color:#657b83;">((</span><span>tab </span><span style="color:#657b83;">=</span><span> table</span><span style="color:#657b83;">) == </span><span style="color:#b58900;">null </span><span style="color:#859900;">|| </span><span style="color:#657b83;">(</span><span>n </span><span style="color:#657b83;">=</span><span> tab.length</span><span style="color:#657b83;">) == </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">){
</span><span>     n </span><span style="color:#657b83;">= (</span><span>tab </span><span style="color:#657b83;">= </span><span style="color:#b58900;">resize</span><span style="color:#657b83;">())</span><span>.length;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>首先，对于<code>if</code>中的<code>(tab = table) == null </code>条件，程序先将<code>table</code>赋值给<code>tab</code>变量，判断集合中是否已经存在<code>table</code>数据，或者说该数组的长度是否为<code>0</code>。如果上述条件有一个成立，则表示<strong>这是第一次向集合中添加元素</strong>，<code>hashMap</code>会自动调用<code>resize()</code>方法对<code>table[]</code>进行首次扩容，以用来存放接下来的元素，所以，明白了这个判断的作用，也就不难推测，为什么这条<code>if</code>判断语句会放在方法的开始了，也可以推测，只要不是首次添加元素，就不再会进入该判断，直接走后面的逻辑。那么现在的关注点就该转移到这个<code>resize()</code>方法中，看一下它的源码：</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">final </span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt;</span><span style="color:#93a1a1;">[] </span><span style="color:#b58900;">resize</span><span style="color:#657b83;">() {
</span><span>    </span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt;</span><span style="color:#93a1a1;">[]</span><span> oldTab </span><span style="color:#657b83;">=</span><span> table;
</span><span>    </span><span style="color:#268bd2;">int</span><span> oldCap </span><span style="color:#657b83;">= (</span><span>oldTab </span><span style="color:#657b83;">== </span><span style="color:#b58900;">null</span><span style="color:#657b83;">) </span><span style="color:#859900;">? </span><span style="color:#6c71c4;">0 </span><span style="color:#859900;">:</span><span> oldTab.length;
</span><span>    </span><span style="color:#268bd2;">int</span><span> oldThr </span><span style="color:#657b83;">=</span><span> threshold;
</span><span>    </span><span style="color:#268bd2;">int</span><span> newCap, newThr </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">0</span><span>;
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>oldCap </span><span style="color:#657b83;">&gt; </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">) {
</span><span>        </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>oldCap </span><span style="color:#657b83;">&gt;= </span><span style="color:#cb4b16;">MAXIMUM_CAPACITY</span><span style="color:#657b83;">) {
</span><span>            threshold </span><span style="color:#657b83;">= </span><span style="color:#859900;">Integer</span><span>.</span><span style="color:#cb4b16;">MAX_VALUE</span><span>;
</span><span>            </span><span style="color:#859900;">return</span><span> oldTab;
</span><span>        </span><span style="color:#657b83;">}
</span><span>        </span><span style="color:#859900;">else if </span><span style="color:#657b83;">((</span><span>newCap </span><span style="color:#657b83;">=</span><span> oldCap </span><span style="color:#859900;">&lt;&lt; </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">) &lt; </span><span style="color:#cb4b16;">MAXIMUM_CAPACITY </span><span style="color:#859900;">&amp;&amp;
</span><span>                 oldCap </span><span style="color:#657b83;">&gt;= </span><span style="color:#cb4b16;">DEFAULT_INITIAL_CAPACITY</span><span style="color:#657b83;">)
</span><span>            newThr </span><span style="color:#657b83;">=</span><span> oldThr </span><span style="color:#859900;">&lt;&lt; </span><span style="color:#6c71c4;">1</span><span>; </span><span style="color:#586e75;">// double threshold
</span><span>    </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#859900;">else if </span><span style="color:#657b83;">(</span><span>oldThr </span><span style="color:#657b83;">&gt; </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// initial capacity was placed in threshold
</span><span>        newCap </span><span style="color:#657b83;">=</span><span> oldThr;
</span><span>    </span><span style="color:#859900;">else </span><span style="color:#657b83;">{               </span><span style="color:#586e75;">// zero initial threshold signifies using defaults
</span><span>        newCap </span><span style="color:#657b83;">= </span><span style="color:#cb4b16;">DEFAULT_INITIAL_CAPACITY</span><span>;
</span><span>        newThr </span><span style="color:#657b83;">= (</span><span style="color:#268bd2;">int</span><span style="color:#657b83;">)(</span><span style="color:#cb4b16;">DEFAULT_LOAD_FACTOR </span><span style="color:#657b83;">* </span><span style="color:#cb4b16;">DEFAULT_INITIAL_CAPACITY</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>newThr </span><span style="color:#657b83;">== </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">) {
</span><span>        </span><span style="color:#268bd2;">float</span><span> ft </span><span style="color:#657b83;">= (</span><span style="color:#268bd2;">float</span><span style="color:#657b83;">)</span><span>newCap </span><span style="color:#657b83;">*</span><span> loadFactor;
</span><span>        newThr </span><span style="color:#657b83;">= (</span><span>newCap </span><span style="color:#657b83;">&lt; </span><span style="color:#cb4b16;">MAXIMUM_CAPACITY </span><span style="color:#859900;">&amp;&amp;</span><span> ft </span><span style="color:#657b83;">&lt; (</span><span style="color:#268bd2;">float</span><span style="color:#657b83;">)</span><span style="color:#cb4b16;">MAXIMUM_CAPACITY </span><span style="color:#859900;">?
</span><span>                  </span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span style="color:#657b83;">)</span><span>ft </span><span style="color:#859900;">: Integer</span><span>.</span><span style="color:#cb4b16;">MAX_VALUE</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#657b83;">}
</span><span>    threshold </span><span style="color:#657b83;">=</span><span> newThr;
</span><span>    @</span><span style="color:#268bd2;">SuppressWarnings</span><span style="color:#657b83;">({</span><span>&quot;</span><span style="color:#2aa198;">rawtypes</span><span>&quot;,&quot;</span><span style="color:#2aa198;">unchecked</span><span>&quot;</span><span style="color:#657b83;">})
</span><span>    </span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt;</span><span style="color:#93a1a1;">[]</span><span> newTab </span><span style="color:#657b83;">= (</span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt;</span><span style="color:#93a1a1;">[]</span><span style="color:#657b83;">)</span><span style="color:#859900;">new Node</span><span style="color:#268bd2;">[</span><span>newCap</span><span style="color:#268bd2;">]</span><span>;
</span><span>    table </span><span style="color:#657b83;">=</span><span> newTab;
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>oldTab </span><span style="color:#657b83;">!= </span><span style="color:#b58900;">null</span><span style="color:#657b83;">) {
</span><span>        </span><span style="color:#859900;">for </span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> j </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">0</span><span>; j </span><span style="color:#657b83;">&lt;</span><span> oldCap; </span><span style="color:#859900;">++</span><span>j</span><span style="color:#657b83;">) {
</span><span>            </span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt; e;
</span><span>            </span><span style="color:#859900;">if </span><span style="color:#657b83;">((</span><span>e </span><span style="color:#657b83;">=</span><span> oldTab[j]</span><span style="color:#657b83;">) != </span><span style="color:#b58900;">null</span><span style="color:#657b83;">) {
</span><span>                oldTab[j] </span><span style="color:#657b83;">= </span><span style="color:#b58900;">null</span><span>;
</span><span>                </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>e.next </span><span style="color:#657b83;">== </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)
</span><span>                    newTab[e.hash </span><span style="color:#859900;">&amp; </span><span style="color:#657b83;">(</span><span>newCap </span><span style="color:#657b83;">- </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">)</span><span>] </span><span style="color:#657b83;">=</span><span> e;
</span><span>                </span><span style="color:#859900;">else if </span><span style="color:#657b83;">(</span><span>e </span><span style="color:#859900;">instanceof TreeNode</span><span style="color:#657b83;">)
</span><span>                    </span><span style="color:#657b83;">((</span><span style="color:#859900;">TreeNode</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt;</span><span style="color:#657b83;">)</span><span>e</span><span style="color:#657b83;">)</span><span>.</span><span style="color:#b58900;">split</span><span style="color:#657b83;">(</span><span style="color:#d33682;">this</span><span>, newTab, j, oldCap</span><span style="color:#657b83;">)</span><span>;
</span><span>                </span><span style="color:#859900;">else </span><span style="color:#657b83;">{ </span><span style="color:#586e75;">// preserve order
</span><span>                    </span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt; loHead </span><span style="color:#657b83;">= </span><span style="color:#b58900;">null</span><span>, loTail </span><span style="color:#657b83;">= </span><span style="color:#b58900;">null</span><span>;
</span><span>                    </span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt; hiHead </span><span style="color:#657b83;">= </span><span style="color:#b58900;">null</span><span>, hiTail </span><span style="color:#657b83;">= </span><span style="color:#b58900;">null</span><span>;
</span><span>                    </span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt; next;
</span><span>                    </span><span style="color:#859900;">do </span><span style="color:#657b83;">{
</span><span>                        next </span><span style="color:#657b83;">=</span><span> e.next;
</span><span>                        </span><span style="color:#859900;">if </span><span style="color:#657b83;">((</span><span>e.hash </span><span style="color:#859900;">&amp;</span><span> oldCap</span><span style="color:#657b83;">) == </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">) {
</span><span>                            </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>loTail </span><span style="color:#657b83;">== </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)
</span><span>                                loHead </span><span style="color:#657b83;">=</span><span> e;
</span><span>                            </span><span style="color:#859900;">else
</span><span>                                loTail.next </span><span style="color:#657b83;">=</span><span> e;
</span><span>                            loTail </span><span style="color:#657b83;">=</span><span> e;
</span><span>                        </span><span style="color:#657b83;">}
</span><span>                        </span><span style="color:#859900;">else </span><span style="color:#657b83;">{
</span><span>                            </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>hiTail </span><span style="color:#657b83;">== </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)
</span><span>                                hiHead </span><span style="color:#657b83;">=</span><span> e;
</span><span>                            </span><span style="color:#859900;">else
</span><span>                                hiTail.next </span><span style="color:#657b83;">=</span><span> e;
</span><span>                            hiTail </span><span style="color:#657b83;">=</span><span> e;
</span><span>                        </span><span style="color:#657b83;">}
</span><span>                    </span><span style="color:#657b83;">} </span><span style="color:#859900;">while </span><span style="color:#657b83;">((</span><span>e </span><span style="color:#657b83;">=</span><span> next</span><span style="color:#657b83;">) != </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)</span><span>;
</span><span>                    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>loTail </span><span style="color:#657b83;">!= </span><span style="color:#b58900;">null</span><span style="color:#657b83;">) {
</span><span>                        loTail.next </span><span style="color:#657b83;">= </span><span style="color:#b58900;">null</span><span>;
</span><span>                        newTab[j] </span><span style="color:#657b83;">=</span><span> loHead;
</span><span>                    </span><span style="color:#657b83;">}
</span><span>                    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>hiTail </span><span style="color:#657b83;">!= </span><span style="color:#b58900;">null</span><span style="color:#657b83;">) {
</span><span>                        hiTail.next </span><span style="color:#657b83;">= </span><span style="color:#b58900;">null</span><span>;
</span><span>                        newTab[j </span><span style="color:#657b83;">+</span><span> oldCap] </span><span style="color:#657b83;">=</span><span> hiHead;
</span><span>                    </span><span style="color:#657b83;">}
</span><span>                </span><span style="color:#657b83;">}
</span><span>            </span><span style="color:#657b83;">}
</span><span>        </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#859900;">return</span><span> newTab;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>那就看下它的扩容原理吧。首先呢，如前面说所，它开始就创建了一个<code>table[]</code>。将该数组的引用赋给<code>oldTab</code>,</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span> </span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt;</span><span style="color:#93a1a1;">[]</span><span> oldTab </span><span style="color:#657b83;">=</span><span> table;
</span></code></pre>
<p>注意这里这个数组首次定义并非在这个方法中，而是在<code>HashMap</code>源码中有做的一个定义，<strong>它也是不可被序列化的</strong>。接着会先判断该<code>table</code>是否是首次创建，如果是，直接初始化为0，否则就是<code>oldTab</code>的大小，为什么会这么说呢，因为这个<code>resize()</code>方法可不只是执行这一次，在<code>putVal()</code>方法的后续的逻辑中还会用到，也就是会出现再次扩容的情况，那么存在一个<code>oldTab</code>的值也就不难理解了吧。</p>
<p>如果<code>oldCap&gt;0</code>，进一步判断它是否<code>&gt;=</code>最大容量<code>MAXNUM_CAPACITY</code>,关于<code>MAXNUM_CAPACITY</code>的定义如下</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#586e75;">//MAXIMUM_CAPACITY定义
</span><span style="color:#93a1a1;">static final </span><span style="color:#268bd2;">int </span><span style="color:#cb4b16;">MAXIMUM_CAPACITY </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">1 </span><span style="color:#859900;">&lt;&lt; </span><span style="color:#6c71c4;">30</span><span>;
</span></code></pre>
<p>如果该条件成立，会给<code>threshod</code>重新赋一个新的容量值，即<code>Integer</code>的上限，反之进入下一个判断<code> ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</code>,将<code>oldCap</code>左移1位,也就是两倍的<code>oldCap</code>赋给一个新的变量<code>newCap</code>,如果该值小于<code>MAXNUM_CAPACITY</code>并且原来的容量<code>oldCap</code>大于等于初始默认容量值<code>DEFAULT_INITIAL_CAPACITY</code>的话，就将新的<code>newThr</code>扩为原来(<code>oldThr</code>)的两倍大小。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#586e75;">//DEFAULT_INITIAL_CAPACITY定义
</span><span style="color:#93a1a1;">static final </span><span style="color:#268bd2;">int </span><span style="color:#cb4b16;">DEFAULT_INITIAL_CAPACITY </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">1 </span><span style="color:#859900;">&lt;&lt; </span><span style="color:#6c71c4;">4</span><span>; </span><span style="color:#586e75;">// aka 16
</span><span style="color:#586e75;">//1&lt;&lt;4等价于1X2^4=2x2x2x2=16
</span></code></pre>
<blockquote>
<p><strong>这里先对上面源码中涉及到的几个变量简单说明一下</strong>，<strong>不然频繁的<code>=</code>赋值操作一波又一波，可能会给整懵圈。</strong></p>
<ol>
<li><code>oldCap</code>:数组原先(准备扩容之前)的容量。</li>
<li><code>oldThr</code>：其实就是<code>threshold</code>的一个暂存局部变量，用来暂存<code>threshold</code>的值。</li>
<li><code>threshold</code>：这是一个定义在<code>HashMap</code>的的全局变量(<strong>可以这么说，实际上<code>Java</code>中没有全局变量这种概念</strong>),它用来存放<code>table[]</code>的一个容量值，或者说<strong>阈值</strong>。所以最终决定是否需要扩容取决于这个全局变量来判断。</li>
<li><code>newCap</code>:同理于<code>oldCap</code>。</li>
</ol>
</blockquote>
<p>继续回到最外层<code>if</code>判断的<code>else if</code>逻辑中，这里先是对<code>newThr</code>是否大于0作了判断，如果<code>&gt;0</code>成立，那么新的容量<code>newCap</code>的值沿用<code>oldThr</code>,否则将会执行下面这段代码,<code>newCap</code>的值默认设置为<code>DEFAULT_INITIAL_CAPACITY</code>也就是<code>16</code>,并且<code>newThr</code>的值更新为<code>(int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</code>。这里参与<code>*</code>运算的除了初始默认容量<code>DEFAULT_INITIAL_CAPACITY</code>外，还有一个重要的常量参数<code>DEFAULT_LOAD_FACTOR</code>，我们称为<strong>负载因子</strong>，换句话说，这个因子的值决定了你每次扩容的具体大小。它是默认值为<code>0.75</code>,也就是说当我们数组占用量达到本身容量的75%时，就会触发首次扩容(<code>resize</code>)操作。当然，最后还进行了强制类型转换为<code>int</code>。</p>
<p>所以不难理解，如果我们是首次使用<code>HashMap</code>进行<code>put</code>操作，方法会直接进入这一步进行初始化。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">else </span><span style="color:#657b83;">{</span><span style="color:#586e75;">// zero initial threshold signifies using defaults
</span><span>    newCap </span><span style="color:#657b83;">= </span><span style="color:#cb4b16;">DEFAULT_INITIAL_CAPACITY</span><span>;
</span><span>    newThr </span><span style="color:#657b83;">= (</span><span style="color:#268bd2;">int</span><span style="color:#657b83;">)(</span><span style="color:#cb4b16;">DEFAULT_LOAD_FACTOR </span><span style="color:#657b83;">* </span><span style="color:#cb4b16;">DEFAULT_INITIAL_CAPACITY</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<blockquote>
<p>具体一点说，当阈值达到<code>16*0.75</code>时，也即是16大小的容量用掉了12个大小时就会触发首次<code>resize</code>。</p>
</blockquote>
<p>这个<strong>负载因子</strong>不是固定不变的，而且有一点需要说明的是，这个<code>resize()</code>方法中，<strong>负载因子是可以手动传入的</strong>，这一点在<code>HashMap</code>的另一个构造方法中有体现，当然，这个后面再说。这里主要讲的还是无参构造器的执行原理，你需要理解<code>resize()</code>方法的两个主要作用，第一个就是上面巴拉巴拉这一堆，<strong>主要是用来对数组进行初始化工作</strong>(当然，你也可以理解为首次扩容，这只是一种说法而已，一般我们会将首次扩容称为初始化，因为其实<strong>扩容的概念是建立在已有容量的基础上的</strong>)，而此后再调用<code>resize()</code>就执行的是扩容工作了，但它的扩容工作可没有初始化这么简单。</p>
<p>但为了能更清晰的理解，我们还是继续首次<code>put</code>操作的主线进行分析。接着上面说，初始化结束之后，会得到一个初始的阈值<code>newThr=16</code>,并将该阈值重新赋给全局<code>threshold</code>保存。计算出<code>table[]</code>的一个初始大小之后，利用该值直接创建一个大小为<code>newCap</code>的新的<code>newTab</code>给<code>table</code>返回，有了这个<code>table</code>，我们就可以在里面存放元素了，比如存放一个字符串<code>Java</code>。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span>threshold </span><span style="color:#657b83;">=</span><span> newThr;
</span><span>@</span><span style="color:#268bd2;">SuppressWarnings</span><span style="color:#657b83;">({</span><span>&quot;</span><span style="color:#2aa198;">rawtypes</span><span>&quot;,&quot;</span><span style="color:#2aa198;">unchecked</span><span>&quot;</span><span style="color:#657b83;">})
</span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt;</span><span style="color:#93a1a1;">[]</span><span> newTab </span><span style="color:#657b83;">= (</span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt;</span><span style="color:#93a1a1;">[]</span><span style="color:#657b83;">)</span><span style="color:#859900;">new Node</span><span style="color:#268bd2;">[</span><span>newCap</span><span style="color:#268bd2;">]</span><span>;
</span><span>table </span><span style="color:#657b83;">=</span><span> newTab;
</span></code></pre>
<p>但光是初始化一个16大小的<code>table</code>是远远不够的。我们知道，既然是数组里面存放元素，是需要一个索引的，根据这个索引去找到一个对应的位置，再将该元素覆盖上去，完成元素的添加。</p>
<p>所以我们先回到上一个方法<code>putVal()</code>方法：接着上面切入进来的<code>resize()</code>方法之后讲解。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">if </span><span style="color:#657b83;">((</span><span>tab </span><span style="color:#657b83;">=</span><span> table</span><span style="color:#657b83;">) == </span><span style="color:#b58900;">null </span><span style="color:#859900;">|| </span><span style="color:#657b83;">(</span><span>n </span><span style="color:#657b83;">=</span><span> tab.length</span><span style="color:#657b83;">) == </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">)
</span><span>    n </span><span style="color:#657b83;">= (</span><span>tab </span><span style="color:#657b83;">= </span><span style="color:#b58900;">resize</span><span style="color:#657b83;">())</span><span>.length;
</span></code></pre>
<blockquote>
<p>上面这两行代码，也就是我们上面刚刚讲完的初始化操作的部分。</p>
</blockquote>
<p>看一下，在对<code>table</code>进行了初始化，并计算得到<code>key</code>的<code>hash</code>之后，后续的代码逻辑分解：</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">if </span><span style="color:#657b83;">((</span><span>p </span><span style="color:#657b83;">=</span><span> tab[i </span><span style="color:#657b83;">= (</span><span>n </span><span style="color:#657b83;">- </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">) </span><span style="color:#859900;">&amp;</span><span> hash]</span><span style="color:#657b83;">) == </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)
</span><span>    tab[i] </span><span style="color:#657b83;">= </span><span style="color:#b58900;">newNode</span><span style="color:#657b83;">(</span><span>hash, key, value, </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)</span><span>;
</span></code></pre>
<p>这里就是根据<code>hash</code>值计算一个索引<code>i</code>。方法是<code>(n-1) &amp; hash</code>,在获得索引之后，检查该索引位置的值<code>tab[i]</code>赋给变量<code>p</code>并判断是否为<code>null</code>，如果为<code>null</code>表示没有被使用，后面一句<code>tab[i] = newNode(hash, key, value, null);</code>直接将元素<code>key</code>存进去,当然，存入的元素除了我们自己传入的数据之外，还有计算出来的<code>hash</code>和一个<code>value</code>，传入<code>hash</code>主要是为了<strong>下一次计算，用来确定下次传入的值是否为重复元素。<strong>至于其中还有一个值为<code>null</code>的值，表示</strong>链表的下一个结点指向</strong>，当然，这里是首次<code>put</code>，所以<code>next</code>是不存在的，也就是<code>null</code>。当上面这段代码执行完毕之后，元素就被成功添加到<code>table</code>中了。</p>
<p><img src="C:/Users/22170/AppData/Roaming/Typora/typora-user-images/image-20220325162444469.png" alt="image-20220325162444469" /></p>
<blockquote>
<p>通过<code>debug</code>可以看到,<code>key</code>计算出的<code>hash=2301537</code>.那么这个索引就可以根据<code>(16-1)&amp;2301537</code>计算出来，它的值是为<code>1</code>的，也就是数组中第二个位置的索引。</p>
</blockquote>
<p><img src="C:/Users/22170/AppData/Roaming/Typora/typora-user-images/image-20220325162819682.png" alt="image-20220325162819682" /></p>
<p>元素添加之后，程序逻辑会直接执行到下面的代码</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">++</span><span>modCount;
</span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span style="color:#859900;">++</span><span>size </span><span style="color:#657b83;">&gt;</span><span> threshold</span><span style="color:#657b83;">)
</span><span>    </span><span style="color:#b58900;">resize</span><span style="color:#657b83;">()</span><span>;
</span><span style="color:#b58900;">afterNodeInsertion</span><span style="color:#657b83;">(</span><span>evict</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#859900;">return </span><span style="color:#b58900;">null</span><span>;
</span></code></pre>
<p>其中的<code>++modCount</code>我在<code>ArrayList</code>源码分析的文章中已经提过，他们的作用是一样的。判断<code>if (++size &gt; threshold)</code>，如果添加元素之后的数组容量<code>&gt;</code>目前的阈值<code>threshold</code>，会触发<code>resize()</code>。关于<code>afterNodeInsertion(evict);</code>方法，是<code>HashMap</code>留给它的子类去实现的一个方法，所以它是个空的方法。类似的方法还有：</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#586e75;">// Callbacks to allow LinkedHashMap post-actions
</span><span>void </span><span style="color:#b58900;">afterNodeAccess</span><span style="color:#657b83;">(</span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt; p</span><span style="color:#657b83;">) { }
</span><span>void </span><span style="color:#b58900;">afterNodeInsertion</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">boolean</span><span> evict</span><span style="color:#657b83;">) { }
</span><span>void </span><span style="color:#b58900;">afterNodeRemoval</span><span style="color:#657b83;">(</span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt; p</span><span style="color:#657b83;">) { }
</span></code></pre>
<p>接着<code>putVal()</code>方法最后返回一个<code>null</code>作为方法的结束。<strong>所以还记得前面留的一个问题吗</strong>？在<code>HashSet</code>源码中的<code>add()</code>方法的方法体里面，它的返回值是判断是否为<code>null</code>,再看一下吧还是。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">public </span><span style="color:#268bd2;">boolean </span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span style="color:#859900;">E</span><span> e</span><span style="color:#657b83;">) {
</span><span>    </span><span style="color:#859900;">return</span><span> map.</span><span style="color:#b58900;">put</span><span style="color:#657b83;">(</span><span>e, </span><span style="color:#cb4b16;">PRESENT</span><span style="color:#657b83;">)==</span><span style="color:#b58900;">null</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>表示执行<code>HashSet</code>中的<code>add()</code>方法添加一个元素，它底层实际上调用了<code>HashMap</code>中的<code>put()</code>方法去实现，能否添加成功的依据就是该<code>put()</code>方法是否返回<code>null</code>,如果是，<code>HashSet</code>的<code>add()</code>方法就返回一个<code>true</code>,最终表示着我们利用<code>HashSet</code>成功的添加了一个元素。否则，添加失败！！</p>
<hr />
<h6 id="qu-zhong-yuan-li">去重原理<a class="zola-anchor" href="#qu-zhong-yuan-li" aria-label="Anchor link for: qu-zhong-yuan-li">🔗</a></h6>
<blockquote>
<p>在理解了<code>HashMap</code>底层<code>table[]</code>的初始化逻辑之后，当我们向其中<code>put()</code>第二个元素时，它的底层是如何判断元素是否重复的呢？下面就以这个问题为主线开始分析。</p>
</blockquote>
<p>由于同样是添加的操作，前面的的几个步骤就不再赘述，比如底层调用<code>map.put()</code>，然后是<code>hash</code>的计算。直接进入<code>putVal()</code>方法开始看。这里再贴一遍它的源码：</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">final </span><span style="color:#859900;">V </span><span style="color:#b58900;">putVal</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> hash, </span><span style="color:#859900;">K</span><span> key, </span><span style="color:#859900;">V</span><span> value, </span><span style="color:#268bd2;">boolean</span><span> onlyIfAbsent,</span><span style="color:#268bd2;">boolean</span><span> evict</span><span style="color:#657b83;">) {
</span><span>    </span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt;</span><span style="color:#93a1a1;">[]</span><span> tab; </span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt; p; </span><span style="color:#268bd2;">int</span><span> n, i;
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">((</span><span>tab </span><span style="color:#657b83;">=</span><span> table</span><span style="color:#657b83;">) == </span><span style="color:#b58900;">null </span><span style="color:#859900;">|| </span><span style="color:#657b83;">(</span><span>n </span><span style="color:#657b83;">=</span><span> tab.length</span><span style="color:#657b83;">) == </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">)
</span><span>        n </span><span style="color:#657b83;">= (</span><span>tab </span><span style="color:#657b83;">= </span><span style="color:#b58900;">resize</span><span style="color:#657b83;">())</span><span>.length;
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">((</span><span>p </span><span style="color:#657b83;">=</span><span> tab[i </span><span style="color:#657b83;">= (</span><span>n </span><span style="color:#657b83;">- </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">) </span><span style="color:#859900;">&amp;</span><span> hash]</span><span style="color:#657b83;">) == </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)
</span><span>        tab[i] </span><span style="color:#657b83;">= </span><span style="color:#b58900;">newNode</span><span style="color:#657b83;">(</span><span>hash, key, value, </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#859900;">else </span><span style="color:#657b83;">{
</span><span>        </span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt; e; </span><span style="color:#859900;">K</span><span> k;
</span><span>        </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>p.hash </span><span style="color:#657b83;">==</span><span> hash </span><span style="color:#859900;">&amp;&amp;
</span><span>            </span><span style="color:#657b83;">((</span><span>k </span><span style="color:#657b83;">=</span><span> p.key</span><span style="color:#657b83;">) ==</span><span> key </span><span style="color:#859900;">|| </span><span style="color:#657b83;">(</span><span>key </span><span style="color:#657b83;">!= </span><span style="color:#b58900;">null </span><span style="color:#859900;">&amp;&amp;</span><span> key.</span><span style="color:#b58900;">equals</span><span style="color:#657b83;">(</span><span>k</span><span style="color:#657b83;">))))
</span><span>            e </span><span style="color:#657b83;">=</span><span> p;
</span><span>        </span><span style="color:#859900;">else if </span><span style="color:#657b83;">(</span><span>p </span><span style="color:#859900;">instanceof TreeNode</span><span style="color:#657b83;">)
</span><span>            e </span><span style="color:#657b83;">= ((</span><span style="color:#859900;">TreeNode</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt;</span><span style="color:#657b83;">)</span><span>p</span><span style="color:#657b83;">)</span><span>.</span><span style="color:#b58900;">putTreeVal</span><span style="color:#657b83;">(</span><span style="color:#d33682;">this</span><span>, tab, hash, key, value</span><span style="color:#657b83;">)</span><span>;
</span><span>        </span><span style="color:#859900;">else </span><span style="color:#657b83;">{
</span><span>            </span><span style="color:#859900;">for </span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> binCount </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">0</span><span>; ; </span><span style="color:#859900;">++</span><span>binCount</span><span style="color:#657b83;">) {
</span><span>                </span><span style="color:#859900;">if </span><span style="color:#657b83;">((</span><span>e </span><span style="color:#657b83;">=</span><span> p.next</span><span style="color:#657b83;">) == </span><span style="color:#b58900;">null</span><span style="color:#657b83;">) {
</span><span>                    p.next </span><span style="color:#657b83;">= </span><span style="color:#b58900;">newNode</span><span style="color:#657b83;">(</span><span>hash, key, value, </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)</span><span>;
</span><span>                    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>binCount </span><span style="color:#657b83;">&gt;= </span><span style="color:#cb4b16;">TREEIFY_THRESHOLD </span><span style="color:#657b83;">- </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// -1 for 1st
</span><span>                        </span><span style="color:#b58900;">treeifyBin</span><span style="color:#657b83;">(</span><span>tab, hash</span><span style="color:#657b83;">)</span><span>;
</span><span>                    </span><span style="color:#859900;">break</span><span>;
</span><span>                </span><span style="color:#657b83;">}
</span><span>                </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>e.hash </span><span style="color:#657b83;">==</span><span> hash </span><span style="color:#859900;">&amp;&amp;
</span><span>                    </span><span style="color:#657b83;">((</span><span>k </span><span style="color:#657b83;">=</span><span> e.key</span><span style="color:#657b83;">) ==</span><span> key </span><span style="color:#859900;">|| </span><span style="color:#657b83;">(</span><span>key </span><span style="color:#657b83;">!= </span><span style="color:#b58900;">null </span><span style="color:#859900;">&amp;&amp;</span><span> key.</span><span style="color:#b58900;">equals</span><span style="color:#657b83;">(</span><span>k</span><span style="color:#657b83;">))))
</span><span>                    </span><span style="color:#859900;">break</span><span>;
</span><span>                p </span><span style="color:#657b83;">=</span><span> e;
</span><span>            </span><span style="color:#657b83;">}
</span><span>        </span><span style="color:#657b83;">}
</span><span>        </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>e </span><span style="color:#657b83;">!= </span><span style="color:#b58900;">null</span><span style="color:#657b83;">) { </span><span style="color:#586e75;">// existing mapping for key
</span><span>            </span><span style="color:#859900;">V</span><span> oldValue </span><span style="color:#657b83;">=</span><span> e.value;
</span><span>            </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span style="color:#859900;">!</span><span>onlyIfAbsent </span><span style="color:#859900;">||</span><span> oldValue </span><span style="color:#657b83;">== </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)
</span><span>                e.value </span><span style="color:#657b83;">=</span><span> value;
</span><span>            </span><span style="color:#b58900;">afterNodeAccess</span><span style="color:#657b83;">(</span><span>e</span><span style="color:#657b83;">)</span><span>;
</span><span>            </span><span style="color:#859900;">return</span><span> oldValue;
</span><span>        </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#859900;">++</span><span>modCount;
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span style="color:#859900;">++</span><span>size </span><span style="color:#657b83;">&gt;</span><span> threshold</span><span style="color:#657b83;">)
</span><span>        </span><span style="color:#b58900;">resize</span><span style="color:#657b83;">()</span><span>;
</span><span>    </span><span style="color:#b58900;">afterNodeInsertion</span><span style="color:#657b83;">(</span><span>evict</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#b58900;">null</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>鉴于前面我们在添加第一个元素<code>Java</code>的时候，已经完成了<code>table[]</code>的初始化工作，所以下面这段代码不会再执行;</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">if </span><span style="color:#657b83;">((</span><span>tab </span><span style="color:#657b83;">=</span><span> table</span><span style="color:#657b83;">) == </span><span style="color:#b58900;">null </span><span style="color:#859900;">|| </span><span style="color:#657b83;">(</span><span>n </span><span style="color:#657b83;">=</span><span> tab.length</span><span style="color:#657b83;">) == </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">)</span><span> n </span><span style="color:#657b83;">= (</span><span>tab </span><span style="color:#657b83;">= </span><span style="color:#b58900;">resize</span><span style="color:#657b83;">())</span><span>.length;
</span></code></pre>
<p>而是直接带着前面计算得来得<code>Hash</code>通过与之前同样算法计算出元素<code>C++</code>(假设这是我们第二个添加的元素)在数组中的索引，代码如下：</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">if </span><span style="color:#657b83;">((</span><span>p </span><span style="color:#657b83;">=</span><span> tab[i </span><span style="color:#657b83;">= (</span><span>n </span><span style="color:#657b83;">- </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">) </span><span style="color:#859900;">&amp;</span><span> hash]</span><span style="color:#657b83;">) == </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)</span><span> tab[i] </span><span style="color:#657b83;">= </span><span style="color:#b58900;">newNode</span><span style="color:#657b83;">(</span><span>hash, key, value, </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)</span><span>;
</span></code></pre>
<blockquote>
<p>注意哈，这里的<code>n</code>在初始化的时候已经计算出来，还是等于16的，改变的是<code>hash</code>值，假设为<code>65762</code>。那么根据上述算法计算得到它的索引为<code>15&amp;65762=2</code>。</p>
</blockquote>
<p>好了，既然索引也有了，并且我们添加的这个元素和第一个元素<code>Java</code>明显是不相等的，所以不会进入到<code>else if</code>判断中，因为<code>if</code>已经成立，后面的逻辑就是将该元素值直接添加到数组中索引为<code>2</code>的位置，当然，元素也是一个<code>Node&lt;k,v&gt;</code>类型。注意，这里存入参数中的最后一个值依旧还是<code>null</code>，因为前后两个元素并没有存放在同一条链表上，自然不会出现在尾部挂载的情况。</p>
<blockquote>
<p>下面将会进行第三个元素的添加，假设我们添加的元素是<code>Java</code>,是的，和<strong>首次添加的元素是相同的</strong>，看一下底层将会如何处理。</p>
</blockquote>
<p>同样我们直接跳到<code>putVal()</code>方法中。程序首先会进入到第二个<code>if</code>判断里，开始计算索引并作判断，也就是下面这段代码：</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">if </span><span style="color:#657b83;">((</span><span>p </span><span style="color:#657b83;">=</span><span> tab[i </span><span style="color:#657b83;">= (</span><span>n </span><span style="color:#657b83;">- </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">) </span><span style="color:#859900;">&amp;</span><span> hash]</span><span style="color:#657b83;">) == </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)
</span><span>    tab[i] </span><span style="color:#657b83;">= </span><span style="color:#b58900;">newNode</span><span style="color:#657b83;">(</span><span>hash, key, value, </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)</span><span>;
</span></code></pre>
<p>注意了，由于首次计算得出<code>Java</code>对应的索引为<code>2</code>,那么这次的结果也是相同的值，所以<code>if</code>中的条件显然不可能成立，因为索引为<code>2</code>的位置已经被占用，自然不会为<code>null</code>。所以程序将会进入下面的逻辑中：</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">else </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt; e; </span><span style="color:#859900;">K</span><span> k;
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>p.hash </span><span style="color:#657b83;">==</span><span> hash </span><span style="color:#859900;">&amp;&amp;
</span><span>        </span><span style="color:#657b83;">((</span><span>k </span><span style="color:#657b83;">=</span><span> p.key</span><span style="color:#657b83;">) ==</span><span> key </span><span style="color:#859900;">|| </span><span style="color:#657b83;">(</span><span>key </span><span style="color:#657b83;">!= </span><span style="color:#b58900;">null </span><span style="color:#859900;">&amp;&amp;</span><span> key.</span><span style="color:#b58900;">equals</span><span style="color:#657b83;">(</span><span>k</span><span style="color:#657b83;">))))
</span><span>        e </span><span style="color:#657b83;">=</span><span> p;
</span><span>    </span><span style="color:#859900;">else if </span><span style="color:#657b83;">(</span><span>p </span><span style="color:#859900;">instanceof TreeNode</span><span style="color:#657b83;">)
</span><span>        e </span><span style="color:#657b83;">= ((</span><span style="color:#859900;">TreeNode</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt;</span><span style="color:#657b83;">)</span><span>p</span><span style="color:#657b83;">)</span><span>.</span><span style="color:#b58900;">putTreeVal</span><span style="color:#657b83;">(</span><span style="color:#d33682;">this</span><span>, tab, hash, key, value</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#859900;">else </span><span style="color:#657b83;">{
</span><span>        </span><span style="color:#859900;">for </span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> binCount </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">0</span><span>; ; </span><span style="color:#859900;">++</span><span>binCount</span><span style="color:#657b83;">) {
</span><span>            </span><span style="color:#859900;">if </span><span style="color:#657b83;">((</span><span>e </span><span style="color:#657b83;">=</span><span> p.next</span><span style="color:#657b83;">) == </span><span style="color:#b58900;">null</span><span style="color:#657b83;">) {
</span><span>                p.next </span><span style="color:#657b83;">= </span><span style="color:#b58900;">newNode</span><span style="color:#657b83;">(</span><span>hash, key, value, </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)</span><span>;
</span><span>                </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>binCount </span><span style="color:#657b83;">&gt;= </span><span style="color:#cb4b16;">TREEIFY_THRESHOLD </span><span style="color:#657b83;">- </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// -1 for 1st
</span><span>                    </span><span style="color:#b58900;">treeifyBin</span><span style="color:#657b83;">(</span><span>tab, hash</span><span style="color:#657b83;">)</span><span>;
</span><span>                </span><span style="color:#859900;">break</span><span>;
</span><span>            </span><span style="color:#657b83;">}
</span><span>            </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>e.hash </span><span style="color:#657b83;">==</span><span> hash </span><span style="color:#859900;">&amp;&amp;
</span><span>                </span><span style="color:#657b83;">((</span><span>k </span><span style="color:#657b83;">=</span><span> e.key</span><span style="color:#657b83;">) ==</span><span> key </span><span style="color:#859900;">|| </span><span style="color:#657b83;">(</span><span>key </span><span style="color:#657b83;">!= </span><span style="color:#b58900;">null </span><span style="color:#859900;">&amp;&amp;</span><span> key.</span><span style="color:#b58900;">equals</span><span style="color:#657b83;">(</span><span>k</span><span style="color:#657b83;">))))
</span><span>                </span><span style="color:#859900;">break</span><span>;
</span><span>            p </span><span style="color:#657b83;">=</span><span> e;
</span><span>        </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#657b83;">}
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>e </span><span style="color:#657b83;">!= </span><span style="color:#b58900;">null</span><span style="color:#657b83;">) { </span><span style="color:#586e75;">// existing mapping for key
</span><span>        </span><span style="color:#859900;">V</span><span> oldValue </span><span style="color:#657b83;">=</span><span> e.value;
</span><span>        </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span style="color:#859900;">!</span><span>onlyIfAbsent </span><span style="color:#859900;">||</span><span> oldValue </span><span style="color:#657b83;">== </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)
</span><span>            e.value </span><span style="color:#657b83;">=</span><span> value;
</span><span>        </span><span style="color:#b58900;">afterNodeAccess</span><span style="color:#657b83;">(</span><span>e</span><span style="color:#657b83;">)</span><span>;
</span><span>        </span><span style="color:#859900;">return</span><span> oldValue;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}
</span></code></pre>
<p>又是一堆<code>if else if</code>套娃操作。按照它的顺序，我们先分析第一个<code>if</code>的逻辑：</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>p.hash </span><span style="color:#657b83;">==</span><span> hash </span><span style="color:#859900;">&amp;&amp;</span><span style="color:#657b83;">((</span><span>k </span><span style="color:#657b83;">=</span><span> p.key</span><span style="color:#657b83;">) ==</span><span> key </span><span style="color:#859900;">|| </span><span style="color:#657b83;">(</span><span>key </span><span style="color:#657b83;">!= </span><span style="color:#b58900;">null </span><span style="color:#859900;">&amp;&amp;</span><span> key.</span><span style="color:#b58900;">equals</span><span style="color:#657b83;">(</span><span>k</span><span style="color:#657b83;">))))
</span><span>    e </span><span style="color:#657b83;">=</span><span> p;
</span></code></pre>
<p>鉴于<code>()</code>中涉及到了三处逻辑运算，方便理解，我们将它逐层进行拆分讲解。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#657b83;">(</span><span>k </span><span style="color:#657b83;">=</span><span> p.key</span><span style="color:#657b83;">) ==</span><span> key </span><span style="color:#859900;">|| </span><span style="color:#657b83;">(</span><span>key </span><span style="color:#657b83;">!= </span><span style="color:#b58900;">null </span><span style="color:#859900;">&amp;&amp;</span><span> key.</span><span style="color:#b58900;">equals</span><span style="color:#657b83;">(</span><span>k</span><span style="color:#657b83;">))
</span></code></pre>
<p>首先看<code>||</code>的左边<code>(k=p.key)==key</code>:意思是先将<code>p</code>中的<code>key</code>值赋给变量<code>k</code>,再与<code>key</code>进行一个比较，判断是否为同一个<code>key</code>值(对象)，注意了，这里的两个<code>key</code>的意思，前一个<code>key</code>(也就是<code>k</code>)**代表的是数组之前已经存在数组中的元素，**而后一个<code>key</code><strong>就是当前传入的元素</strong>，具体的也就是指我们第一次存入的<code>Java</code>和本次存入的<code>Java</code>。</p>
<p>再看<code>||</code>右边<code>(key != null &amp;&amp; key.equals(k)</code>,这是一个<code>&amp;&amp;</code>操作,需要操作符两边的条件同时成立，整个条件才会成立。首先判断存入的<code>key</code>是否为<code>null</code>，再判断<code>key</code>和<code>k</code>是否为相同（注意这里用了<code>equals()</code>方法,该方法可被重写），判断是否为相同的内容。回到外层的<code>p.hash==hash</code>这个判断，就是将已有索引处对应的元素(元素是存在<code>Node</code>上的)的<code>hash</code>值取出与当前元素的<code>Hash</code>进行比较。</p>
<p>所以归纳起来也就是当二者<code>hash</code>相同并且<code>key</code>也相同(同一个对象)的情况下，执行<code>e=p</code>赋值操作，将原位置的值进行覆盖。</p>
<p>如果上面的条件不成立，会判断<code>p</code>是否是红黑树，如果是，就调用对应的添加方法<code>putTreeVal()</code>进行添加，也就是下面的代码。这里的 <code>instanceof</code>关键字用来判断一个对象是否为一个类的实例。另外，<code>putTreeVal()</code>方法内部涉及到大量红黑树的代码，相对复杂很多，如果跳进去的话，估计一时半会出不来，所以这里暂时不作探究，会另外分开来学习，还是围绕着主线继续分析。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">else if </span><span style="color:#657b83;">(</span><span>p </span><span style="color:#859900;">instanceof TreeNode</span><span style="color:#657b83;">)
</span><span>    e </span><span style="color:#657b83;">= ((</span><span style="color:#859900;">TreeNode</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt;</span><span style="color:#657b83;">)</span><span>p</span><span style="color:#657b83;">)</span><span>.</span><span style="color:#b58900;">putTreeVal</span><span style="color:#657b83;">(</span><span style="color:#d33682;">this</span><span>, tab, hash, key, value</span><span style="color:#657b83;">)</span><span>;
</span></code></pre>
<p>否则，进入<code>else</code>逻辑中：</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">else </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#859900;">for </span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int</span><span> binCount </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">0</span><span>; ; </span><span style="color:#859900;">++</span><span>binCount</span><span style="color:#657b83;">) {
</span><span>        </span><span style="color:#859900;">if </span><span style="color:#657b83;">((</span><span>e </span><span style="color:#657b83;">=</span><span> p.next</span><span style="color:#657b83;">) == </span><span style="color:#b58900;">null</span><span style="color:#657b83;">) {
</span><span>            p.next </span><span style="color:#657b83;">= </span><span style="color:#b58900;">newNode</span><span style="color:#657b83;">(</span><span>hash, key, value, </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)</span><span>;
</span><span>            </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>binCount </span><span style="color:#657b83;">&gt;= </span><span style="color:#cb4b16;">TREEIFY_THRESHOLD </span><span style="color:#657b83;">- </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// -1 for 1st
</span><span>                </span><span style="color:#b58900;">treeifyBin</span><span style="color:#657b83;">(</span><span>tab, hash</span><span style="color:#657b83;">)</span><span>;
</span><span>            </span><span style="color:#859900;">break</span><span>;
</span><span>        </span><span style="color:#657b83;">}
</span><span>        </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>e.hash </span><span style="color:#657b83;">==</span><span> hash </span><span style="color:#859900;">&amp;&amp;
</span><span>            </span><span style="color:#657b83;">((</span><span>k </span><span style="color:#657b83;">=</span><span> e.key</span><span style="color:#657b83;">) ==</span><span> key </span><span style="color:#859900;">|| </span><span style="color:#657b83;">(</span><span>key </span><span style="color:#657b83;">!= </span><span style="color:#b58900;">null </span><span style="color:#859900;">&amp;&amp;</span><span> key.</span><span style="color:#b58900;">equals</span><span style="color:#657b83;">(</span><span>k</span><span style="color:#657b83;">))))
</span><span>            </span><span style="color:#859900;">break</span><span>;
</span><span>        p </span><span style="color:#657b83;">=</span><span> e;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}
</span></code></pre>
<p>开局一个<code>for</code>，目的明确，<strong>既然上面两种情况都不成立，那么说明该元素可能会在某一条链表节点上出现</strong>，比如下面这样：</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#268bd2;">Java-&gt;</span><span style="color:#859900;">C++</span><span style="color:#657b83;">-&gt;</span><span style="color:#268bd2;">Javascript-&gt;</span><span style="color:#859900;">Java
</span></code></pre>
<p>所以我们需要以遍历的方式去检查链表上的每一个节点，循环内部，通过<code>p</code>和<code>e</code>两个指针不停的循环比较。</p>
<p>如果过程中发现有一个和当前元素重复的元素，循环会立即结束，元素添加失败，否则就将当前元素直接挂到节点后面，完成添加。注意其中这段代码:</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>binCount </span><span style="color:#657b83;">&gt;= </span><span style="color:#cb4b16;">TREEIFY_THRESHOLD </span><span style="color:#657b83;">- </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">) </span><span style="color:#586e75;">// -1 for 1st
</span><span>    </span><span style="color:#b58900;">treeifyBin</span><span style="color:#657b83;">(</span><span>tab, hash</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#586e75;">//TREEIFY_THRESHOLD的定义
</span><span style="color:#93a1a1;">static final </span><span style="color:#268bd2;">int </span><span style="color:#cb4b16;">TREEIFY_THRESHOLD </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">8</span><span>;
</span></code></pre>
<p>这是在进行<strong>添加之后对当前这条链表进行一个判断</strong>，如果长度<code>&gt;=(TREEIFY_THRESHOLD=8)-1</code>的话，会调用<code>treeifBin()</code>方法对当前链表进行树化(转红黑树)，但是注意，光是这个条件满足还不足以开始树化，在这个方法的实现中，还添加了其他的添加用来判断，<code>treeifBin()</code>源码：</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">final</span><span> void </span><span style="color:#b58900;">treeifyBin</span><span style="color:#657b83;">(</span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt;</span><span style="color:#93a1a1;">[]</span><span> tab, </span><span style="color:#268bd2;">int</span><span> hash</span><span style="color:#657b83;">) {
</span><span>    </span><span style="color:#268bd2;">int</span><span> n, index; </span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt; e;
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>tab </span><span style="color:#657b83;">== </span><span style="color:#b58900;">null </span><span style="color:#859900;">|| </span><span style="color:#657b83;">(</span><span>n </span><span style="color:#657b83;">=</span><span> tab.length</span><span style="color:#657b83;">) &lt; </span><span style="color:#cb4b16;">MIN_TREEIFY_CAPACITY</span><span style="color:#657b83;">)
</span><span>        </span><span style="color:#b58900;">resize</span><span style="color:#657b83;">()</span><span>;
</span><span>    </span><span style="color:#859900;">else if </span><span style="color:#657b83;">((</span><span>e </span><span style="color:#657b83;">=</span><span> tab[index </span><span style="color:#657b83;">= (</span><span>n </span><span style="color:#657b83;">- </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">) </span><span style="color:#859900;">&amp;</span><span> hash]</span><span style="color:#657b83;">) != </span><span style="color:#b58900;">null</span><span style="color:#657b83;">) {
</span><span>        </span><span style="color:#859900;">TreeNode</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt; hd </span><span style="color:#657b83;">= </span><span style="color:#b58900;">null</span><span>, tl </span><span style="color:#657b83;">= </span><span style="color:#b58900;">null</span><span>;
</span><span>        </span><span style="color:#859900;">do </span><span style="color:#657b83;">{
</span><span>            </span><span style="color:#859900;">TreeNode</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt; p </span><span style="color:#657b83;">= </span><span style="color:#b58900;">replacementTreeNode</span><span style="color:#657b83;">(</span><span>e, </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)</span><span>;
</span><span>            </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>tl </span><span style="color:#657b83;">== </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)
</span><span>                hd </span><span style="color:#657b83;">=</span><span> p;
</span><span>            </span><span style="color:#859900;">else </span><span style="color:#657b83;">{
</span><span>                p.prev </span><span style="color:#657b83;">=</span><span> tl;
</span><span>                tl.next </span><span style="color:#657b83;">=</span><span> p;
</span><span>            </span><span style="color:#657b83;">}
</span><span>            tl </span><span style="color:#657b83;">=</span><span> p;
</span><span>        </span><span style="color:#657b83;">} </span><span style="color:#859900;">while </span><span style="color:#657b83;">((</span><span>e </span><span style="color:#657b83;">=</span><span> e.next</span><span style="color:#657b83;">) != </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)</span><span>;
</span><span>        </span><span style="color:#859900;">if </span><span style="color:#657b83;">((</span><span>tab[index] </span><span style="color:#657b83;">=</span><span> hd</span><span style="color:#657b83;">) != </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)
</span><span>            hd.</span><span style="color:#b58900;">treeify</span><span style="color:#657b83;">(</span><span>tab</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}
</span></code></pre>
<p>就是说，就算前面的条件(<code>&gt;=8</code>)已经成立，这里还会进行一个判断，具体逻辑如下：</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>tab </span><span style="color:#657b83;">== </span><span style="color:#b58900;">null </span><span style="color:#859900;">|| </span><span style="color:#657b83;">(</span><span>n </span><span style="color:#657b83;">=</span><span> tab.length</span><span style="color:#657b83;">) &lt; </span><span style="color:#cb4b16;">MIN_TREEIFY_CAPACITY</span><span style="color:#657b83;">)
</span><span>    </span><span style="color:#b58900;">resize</span><span style="color:#657b83;">()</span><span>;
</span></code></pre>
<p>它还会判断当前这个<code>table</code>的大小是否<code>&lt;MIN_TREEIFY_CAPACITY</code>也就是是否<code>&lt;64</code>。如果这个条件成立，那么会先对数组进行一个<code>resize()</code>扩容操作，而不是直接转红黑树。最后如果添加失败，会返回一个之前元素的<code>value</code>值。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>e </span><span style="color:#657b83;">!= </span><span style="color:#b58900;">null</span><span style="color:#657b83;">) { </span><span style="color:#586e75;">// existing mapping for key
</span><span>    </span><span style="color:#859900;">V</span><span> oldValue </span><span style="color:#657b83;">=</span><span> e.value;
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span style="color:#859900;">!</span><span>onlyIfAbsent </span><span style="color:#859900;">||</span><span> oldValue </span><span style="color:#657b83;">== </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)
</span><span>        e.value </span><span style="color:#657b83;">=</span><span> value;
</span><span>    </span><span style="color:#b58900;">afterNodeAccess</span><span style="color:#657b83;">(</span><span>e</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#859900;">return</span><span> oldValue;
</span><span>	</span><span style="color:#657b83;">}
</span><span style="background-color:#6e2e32;color:#839496;">}</span><span>
</span></code></pre>
<h6 id="kuo-rong-yuan-li">扩容原理<a class="zola-anchor" href="#kuo-rong-yuan-li" aria-label="Anchor link for: kuo-rong-yuan-li">🔗</a></h6>
<p>前面对整个流程有了大致的了解之后，下面主要针对它的<strong>扩容原理</strong>进行一个简单的总结。</p>
<p>关于扩容的原理，先说结论：</p>
<ul>
<li>
<p><code>HashSet</code>底层是<code>HashMap</code>，首次添加时，<code>table</code>数组的容量扩为16，初始临界值为12:</p>
<blockquote>
<p>threshold(阈值) = table.size()(table数组大小) * loadFactor(加载因子)</p>
<p>=16*0.75</p>
<p>=12</p>
</blockquote>
</li>
<li>
<p>如果<code>table</code>数组使用的部分达到了阈值，就会触发扩容，具体的扩容为<code>16*2=32</code>,也就是<strong>会按照两倍的扩容</strong>方式进行，基于这个容量再次计算新的扩容阈值:<code>32*0.75=24</code>,也就是如果本次扩容后的容量(32)使用达到24之后，就会再次触发下一次的2倍扩容机制，以此类推。</p>
</li>
</ul>
<p><strong>简单来说，以上就是<code>HashSet(本质HashMap)</code>的扩容原理，具体的，看下面源码分析。</strong></p>
<blockquote>
<p>在resize()方法中有这样一段代码</p>
</blockquote>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">else if </span><span style="color:#657b83;">((</span><span>newCap </span><span style="color:#657b83;">=</span><span> oldCap </span><span style="color:#859900;">&lt;&lt; </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">) &lt; </span><span style="color:#cb4b16;">MAXIMUM_CAPACITY </span><span style="color:#859900;">&amp;&amp;
</span><span>         oldCap </span><span style="color:#657b83;">&gt;= </span><span style="color:#cb4b16;">DEFAULT_INITIAL_CAPACITY</span><span style="color:#657b83;">)
</span><span>    newThr </span><span style="color:#657b83;">=</span><span> oldThr </span><span style="color:#859900;">&lt;&lt; </span><span style="color:#6c71c4;">1</span><span>; </span><span style="color:#586e75;">// double threshold
</span></code></pre>
<p>可以看到，新的容量是在原有容量的基础作了一个左移的操作，也就是和乘2是等效的，但用位运算效率会快很多。</p>
<blockquote>
<p>这是在pustVal()源码的部分代码：</p>
</blockquote>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">++</span><span>modCount;
</span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span style="color:#859900;">++</span><span>size </span><span style="color:#657b83;">&gt;</span><span> threshold</span><span style="color:#657b83;">)
</span><span>    </span><span style="color:#b58900;">resize</span><span style="color:#657b83;">()</span><span>;
</span><span style="color:#b58900;">afterNodeInsertion</span><span style="color:#657b83;">(</span><span>evict</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#859900;">return </span><span style="color:#b58900;">null</span><span>;
</span></code></pre>
<blockquote>
<p>resize();就是触发扩容时调用的扩容方法。具体的源码前面有讲过，不再赘述。</p>
</blockquote>
<p>在Java8中，如果一条链表的元素个数达到<code> TREEIFY_THRESHOLD</code>且此时<code>table</code>的大小&gt;=<code>MIN_TREEIFY_CAPACITY</code></p>
<p>时就会触发链表转红黑树的操作。提高性能。</p>
<blockquote>
<p>上面涉及到的两个常量在源代码中的定义如下：</p>
</blockquote>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">static final </span><span style="color:#268bd2;">int </span><span style="color:#cb4b16;">TREEIFY_THRESHOLD </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">8</span><span>;
</span><span style="color:#93a1a1;">static final </span><span style="color:#268bd2;">int </span><span style="color:#cb4b16;">MIN_TREEIFY_CAPACITY </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">64</span><span>;
</span></code></pre>
<p>转红黑树的方法源码如下，这里只需要看看大致的执行逻辑就好，关于红黑树具体的实现，不是本章的主要内容。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">final</span><span> void </span><span style="color:#b58900;">treeifyBin</span><span style="color:#657b83;">(</span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt;</span><span style="color:#93a1a1;">[]</span><span> tab, </span><span style="color:#268bd2;">int</span><span> hash</span><span style="color:#657b83;">) {
</span><span>    </span><span style="color:#268bd2;">int</span><span> n, index; </span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt; e;
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>tab </span><span style="color:#657b83;">== </span><span style="color:#b58900;">null </span><span style="color:#859900;">|| </span><span style="color:#657b83;">(</span><span>n </span><span style="color:#657b83;">=</span><span> tab.length</span><span style="color:#657b83;">) &lt; </span><span style="color:#cb4b16;">MIN_TREEIFY_CAPACITY</span><span style="color:#657b83;">)
</span><span>        </span><span style="color:#b58900;">resize</span><span style="color:#657b83;">()</span><span>;
</span><span>    </span><span style="color:#859900;">else if </span><span style="color:#657b83;">((</span><span>e </span><span style="color:#657b83;">=</span><span> tab[index </span><span style="color:#657b83;">= (</span><span>n </span><span style="color:#657b83;">- </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">) </span><span style="color:#859900;">&amp;</span><span> hash]</span><span style="color:#657b83;">) != </span><span style="color:#b58900;">null</span><span style="color:#657b83;">) {
</span><span>        </span><span style="color:#859900;">TreeNode</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt; hd </span><span style="color:#657b83;">= </span><span style="color:#b58900;">null</span><span>, tl </span><span style="color:#657b83;">= </span><span style="color:#b58900;">null</span><span>;
</span><span>        </span><span style="color:#859900;">do </span><span style="color:#657b83;">{
</span><span>            </span><span style="color:#859900;">TreeNode</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt; p </span><span style="color:#657b83;">= </span><span style="color:#b58900;">replacementTreeNode</span><span style="color:#657b83;">(</span><span>e, </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)</span><span>;
</span><span>            </span><span style="color:#859900;">if </span><span style="color:#657b83;">(</span><span>tl </span><span style="color:#657b83;">== </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)
</span><span>                hd </span><span style="color:#657b83;">=</span><span> p;
</span><span>            </span><span style="color:#859900;">else </span><span style="color:#657b83;">{
</span><span>                p.prev </span><span style="color:#657b83;">=</span><span> tl;
</span><span>                tl.next </span><span style="color:#657b83;">=</span><span> p;
</span><span>            </span><span style="color:#657b83;">}
</span><span>            tl </span><span style="color:#657b83;">=</span><span> p;
</span><span>        </span><span style="color:#657b83;">} </span><span style="color:#859900;">while </span><span style="color:#657b83;">((</span><span>e </span><span style="color:#657b83;">=</span><span> e.next</span><span style="color:#657b83;">) != </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)</span><span>;
</span><span>        </span><span style="color:#859900;">if </span><span style="color:#657b83;">((</span><span>tab[index] </span><span style="color:#657b83;">=</span><span> hd</span><span style="color:#657b83;">) != </span><span style="color:#b58900;">null</span><span style="color:#657b83;">)
</span><span>            hd.</span><span style="color:#b58900;">treeify</span><span style="color:#657b83;">(</span><span>tab</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}
</span></code></pre>
<p><strong>注意如果只是满足链表长度达到8的条件时，它还是会采用<code>resize()</code>方法对数组扩容，而不是直接转红黑树。</strong></p>
<p><strong>注意了！！</strong></p>
<blockquote>
<p>上面提到的触发数组扩容的条件中，<code>size</code>的大小大于负载因子才会触发，这里的<code>size</code>指<code>的是数组和链表中元素的和</code>，也就是只要我们向其中添加一个元素，不论这个元素是存在数组第一个位置，还是存在链表中某个位置，<code>size都会自增1</code>，这是一个比较容易搞错的地方，<strong>不要认为size就是指数组的长度，这是错误的。</strong></p>
</blockquote>
<hr />
<p><strong>为什么不直接使用<code>hash</code>来计算索引，而是要进行取模运算？</strong></p>
<blockquote>
<p>如果将哈希码映射到数组中的一个索引。可能会因为<code>hash</code>值过大而因此导致索引超出范围。所以一个最简单的方法是对哈希码和数组的长度进行模运算，如<code>hash(key) % n</code>。如此可以<strong>确保索引i总是在0和n之间。</strong></p>
</blockquote>
<p>但是Java在实现的时候，用的并不是上面说的算法，而是将<strong>数组的长度n减去1之后再与<code>hash</code>作<code>&amp;</code>运算得到</strong>，实现代码如下:</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span>i </span><span style="color:#657b83;">= (</span><span>n </span><span style="color:#657b83;">- </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">) </span><span style="color:#859900;">&amp;</span><span> hash;
</span></code></pre>
<hr />
<h4 id="linkedhashset">LinkedHashSet<a class="zola-anchor" href="#linkedhashset" aria-label="Anchor link for: linkedhashset">🔗</a></h4>
<h5 id="gai-shu">概述<a class="zola-anchor" href="#gai-shu" aria-label="Anchor link for: gai-shu">🔗</a></h5>
<ul>
<li><code>LinkedHashSet</code>是<code>Set</code>接口的一个实现子类，也是<code>HashSet</code>的子类。</li>
<li><code>LinkedHashSet</code>的底层是一个<code>LinkedHashMap</code>，底层维护了一个<strong>数组+双向链表</strong>。</li>
<li><code>LinkedHashSet</code>根据元素的<code>hashCode</code>值来决定元素的存储位置，同时<strong>使用链表来维护元素的次序</strong>，这就使得元素看起来是以插入的顺序保存的。</li>
<li>其次，<code>LinkedHashSet</code>也<strong>不允许添加重复元素</strong>。</li>
</ul>
<p><img src="https://images.waer.ltd/img/LinkedHashSet.png" alt="" /></p>
<p>在<code>LinkedHashSet</code>中维护了一个<code>hash</code>表和双向链表，每一个节点有<code>pre</code>和<code>next</code>属性，这样可以形成双向链表。在添加元素时，先求<code>hash</code>值，再求索引，确定该元素在哈希表中的位置，然后将添加的元素加入到双向链表（如果已经存在，不添加(原理和<code>hashset类似</code>)）。</p>
<h5 id="yuan-ma-jie-du-1">源码解读<a class="zola-anchor" href="#yuan-ma-jie-du-1" aria-label="Anchor link for: yuan-ma-jie-du-1">🔗</a></h5>
<ul>
<li>通过下面的示例来配合讲解：</li>
</ul>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#859900;">Set</span><span> set </span><span style="color:#657b83;">= </span><span style="color:#859900;">new LinkedHashSet</span><span style="color:#657b83;">()</span><span>;
</span><span>set.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">A</span><span>&quot;</span><span style="color:#657b83;">)</span><span>;
</span><span>set.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">120</span><span style="color:#657b83;">)</span><span>;
</span><span>set.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">120</span><span style="color:#657b83;">)</span><span>;
</span><span>set.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span style="color:#859900;">new User</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">李</span><span>&quot;,</span><span style="color:#6c71c4;">1001</span><span style="color:#657b83;">))</span><span>;
</span><span>set.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">123</span><span style="color:#657b83;">)</span><span>;
</span><span>set.</span><span style="color:#b58900;">add</span><span style="color:#657b83;">(</span><span style="color:#859900;">new String</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">hello</span><span>&quot;</span><span style="color:#657b83;">))</span><span>;
</span><span style="color:#859900;">System</span><span>.out.</span><span style="color:#b58900;">println</span><span style="color:#657b83;">(</span><span>set</span><span style="color:#657b83;">)</span><span>;
</span></code></pre>
<p>如果断点的方式，我们可以看到，<code>LinkedHashSet</code>的一个基本结构如下：</p>
<p><img src="https://images.waer.ltd/img/20220426085807.png" alt="" /></p>
<p>通过上图可以发现，其中存在一个<code>tail</code>和<code>head</code>的属性，这是典型的双向链表中才会用到的两个引用，或者指针(c/c++)，<strong>代表双向链表的头尾指针</strong>。即进一步验证了前面提到的<code>LinkedHashSet</code>的是一个<code>HashTable</code>和双向链表的组合。</p>
<p>其中的<code>table</code>类型其实是一个<code>HashMap$Node[]</code>类型，而每一个节点又是维护的<code>LinkedHashMap$Entry[]</code>类型。</p>
<p><img src="https://images.waer.ltd/img/20220426090925.png" alt="" /></p>
<p>为什么数组为<code>HashMap$Node[]数组类型</code>而存放的元素却是<code>LinkedHashMap$Entry[]</code>类型？</p>
<blockquote>
<p>说明<code>LinkedHashMap$Entry[]</code>肯定继<strong>承或者实现</strong>了<code>HashMap$Node[]</code>的，即通过<strong>数组多态</strong>的方式实现。注意这里的<code>$</code>符号标识$之后的类作为<code>$</code>之前的一个静态内部类，也即表示在<code>LinkedHashMap$Entry</code>中，<code>Entry</code>是<code>LinkedHashMap</code>的一个<strong>静态内部类。</strong></p>
</blockquote>
<p>在<code>LinkdeHashMap</code>中我们可以找到对应的源码验证。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">static </span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Entry</span><span>&lt;</span><span style="color:#268bd2;">K</span><span>,</span><span style="color:#268bd2;">V</span><span>&gt; </span><span style="color:#859900;">extends </span><span style="color:#268bd2;">HashMap</span><span>.</span><span style="color:#268bd2;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt; </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#859900;">Entry</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt; before, after;
</span><span>    </span><span style="color:#b58900;">Entry</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int hash</span><span>, </span><span style="color:#859900;">K </span><span style="color:#268bd2;">key</span><span>, </span><span style="color:#859900;">V </span><span style="color:#268bd2;">value</span><span>, </span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt; </span><span style="color:#268bd2;">next</span><span style="color:#657b83;">) {
</span><span>        </span><span style="color:#d33682;">super</span><span style="color:#657b83;">(</span><span>hash, key, value, next</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}
</span></code></pre>
<p>从上述的源码中不仅说明<code>Entry</code>是<code>LinkedHashMap</code>的内部类，也说明<code>LinkedHashMap$Entry[]</code>继承了<code>HashMap$Node[]</code>。</p>
<p>其中有两个<code>Entry&lt;K,V&gt;</code>类型的属性：<code>before</code>和<code>after</code>，可以理解为两个引用，主要用来完成各节点之间的连接。</p>
<p>同样，我们也可以通过查看<code>HashMap</code>的源码，验证上面的说法：<code>Node</code>同样作为其一个静态的内部类实现。并且该类还实现了其父接口<code>Map</code>中的<code>Entry&lt;K,V&gt;</code>。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">static </span><span style="color:#268bd2;">class </span><span style="color:#b58900;">Node</span><span>&lt;</span><span style="color:#268bd2;">K</span><span>,</span><span style="color:#268bd2;">V</span><span>&gt; </span><span style="color:#859900;">implements </span><span style="color:#268bd2;">Map</span><span>.</span><span style="color:#268bd2;">Entry</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt; </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#93a1a1;">final </span><span style="color:#268bd2;">int </span><span>hash;
</span><span>    </span><span style="color:#93a1a1;">final </span><span style="color:#859900;">K </span><span>key;
</span><span>    </span><span style="color:#859900;">V </span><span>value;
</span><span>    </span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt; next;
</span><span>
</span><span>    </span><span style="color:#b58900;">Node</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">int hash</span><span>, </span><span style="color:#859900;">K </span><span style="color:#268bd2;">key</span><span>, </span><span style="color:#859900;">V </span><span style="color:#268bd2;">value</span><span>, </span><span style="color:#859900;">Node</span><span>&lt;</span><span style="color:#859900;">K</span><span>,</span><span style="color:#859900;">V</span><span>&gt; </span><span style="color:#268bd2;">next</span><span style="color:#657b83;">) {
</span><span>        </span><span style="color:#d33682;">this</span><span>.hash </span><span style="color:#657b83;">=</span><span> hash;
</span><span>        </span><span style="color:#d33682;">this</span><span>.key </span><span style="color:#657b83;">=</span><span> key;
</span><span>        </span><span style="color:#d33682;">this</span><span>.value </span><span style="color:#657b83;">=</span><span> value;
</span><span>        </span><span style="color:#d33682;">this</span><span>.next </span><span style="color:#657b83;">=</span><span> next;
</span><span>    </span><span style="color:#657b83;">}
</span></code></pre>
<p><img src="https://images.waer.ltd/img/20220426092722.png" alt="" /></p>
<p>在存储元素时，每一个元素中依然是使用的<code>key</code>来存储，而<code>value</code>只是一个<code>object</code>类型的占位符，这里没有实际的意义。因为在<code>LinkedHashSet</code>中，我们<strong>不需要显式的去像Map中存一个<code>K,V</code>形式的值。</strong></p>
<ul>
<li>当我们添加一个重复元素时，<code>LinkedHashSet</code>会直接调用父类<code>HashSet</code>中的比较方法，对重复元素进行一个判断并去重，其实这里的原理和之前讲的<code>HashSet</code>原理是一样的，当添加元素是，<code>LinkedHashSet</code>还是会直接调用父类<code>HashSet</code>中的<code>add()</code>方法(该方法本质还是调用<code>HashMap</code>中的<code>put()</code>方法)，接着是<code>putVal()</code>关于这两个方法的源码在前面讲<code>HashSet</code>源码的时候就已经讲过，这里不再赘述。所以说，经管是不同的结构实现，但在元素判重的原理上其实使用的还是同一个逻辑。</li>
</ul>
<p><strong>说白了，LinkedHashSet本质上大部分还是HashMap</strong></p>
<ul>
<li>
<p><code>LinkedHashset</code>底层维护了一个<code>LinkedHashMap</code>结构，这一点可以类比于<code>HashSet</code>底层维护一个<code>HashMap</code>来进行对比记忆。而前面我们已经知道，<code>LinkedHashMap</code>其实就是<code>HashMap</code>的一个子类。</p>
</li>
<li>
<p>对于<code>LinkedHashSet</code>我们在理解了前面<code>HashSet</code>源码的基础上，只需要理解它底层的一个实现结构即可，也就是数组+双向链表的结构，回到一开始的哪个示例中，我们向set集合中添加了：</p>
</li>
</ul>
<blockquote>
<p>“A”，120, User,123</p>
</blockquote>
<p>之后，通过断点的方式可以看到他们之间的一个指向关系如下</p>
<p><img src="https://images.waer.ltd/img/20220426100922.png" alt="" /></p>
<blockquote>
<p>上图展示了内部元素节点中<code>after</code>和<code>before</code>的引用关系。仔细观察每一个<code>LinkedHashMap$Entry</code>后都会跟一个<code>@number</code>的标识，**这是用来标识该位置元素的一个唯一标记，或者你也可以理解为该元素在该结构中的一个地址。**因此，我们可以用该标识来唯一性的代表一元素值，注意其中每一各<code>after</code>或者<code>before</code>的指向关系，具体在后面我回画个图帮助理解。</p>
</blockquote>
<ul>
<li>再跳出元素内部<code>Entry</code>，我们看到在<code>table</code>中有两个名为<code>head</code>和<code>tail</code>的引用属性。用来标识该双向链表的头尾节点。</li>
</ul>
<p><img src="https://images.waer.ltd/img/20220426101903.png" alt="" /></p>
<p>将上面的逻辑以图片的形式展示出来大概就是下面这样：</p>
<p><img src="https://images.waer.ltd/img/LinkedHashSet.jpg" alt="" /></p>
<p>简单捋一下：</p>
<blockquote>
<ul>
<li>每向<code>LinkedHashSet</code>中添加一个元素，首先会根据该元素计算一个<code>hash</code>值，用来确定它在上面图中<code>table</code>数组中的索引位置。</li>
<li>通过上面的步骤添加多个元素之后，元素内部是一个<code>Entry[]</code>类型的结构，其中每一个元素都有一个<code>after</code>和<code>before</code>属性，用<strong>来指向它的前一个元素和后一个元素的位置。</strong></li>
<li>再通过两个属性<code>head</code>和<code>tail</code>来指向整个链表的头和尾，从而构成一个<strong>完整的含有头尾指针(引用)的双向链表。</strong></li>
<li>将该链表具象化出来可以大致表示为图中右边部分。换句话说，这里的<code>after</code>和<code>before</code>其实就相当于平时常用的<code>pre</code>和<code>next</code>指针，即前驱后继指针，只不过命名不同而已，没什么高深莫测的。</li>
<li>注意，和前面<code>HashSet</code>的数组+单链表的结构类似，每一个索引位都可以是一条完整的双向链表，就像图中索引为7的位置一样，而不是每个索引为只能有一个链表节点，这取决于元素计算出来的<code>hash</code>。</li>
<li>正是由于双向链表的特性，使得我们添加的元素顺序是相对有序的，<strong>也就是添加的顺序和打印出来的顺序是一样的。</strong></li>
</ul>
</blockquote>
<p><strong>关于扩容</strong></p>
<p>首先，<code>LinkedHashSet</code>如果使用无参数构造器初始化，那么它默认会开辟一个<code>16</code>大小的空间，负载因子依旧是<code>0.74</code>，首次扩容的阈值为<code>12</code>。这些数值是不是很眼熟？如果你看了前面<code>HashSet</code>的源码分析的话。</p>
<pre data-lang="java" style="background-color:#002b36;color:#839496;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#93a1a1;">public </span><span style="color:#b58900;">LinkedHashSet</span><span style="color:#657b83;">() {
</span><span>    </span><span style="color:#d33682;">super</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">16</span><span>, </span><span style="color:#6c71c4;">.75</span><span style="color:#268bd2;">f</span><span>, </span><span style="color:#b58900;">true</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>虽然讲的是<code>LinkdeHashSet</code>，但本质上分析的还是<code>HashSet</code>，再本质就是<code>LinkedHashMap</code>，再继续套娃你会发现，<strong>就是讲的<code>HashMap</code>，可见这家伙才是主角。</strong></p>
<hr />
<p>未完待续……</p>

      
    </div><!--./card-body-->

    <div class="card-footer">
      <div class="columns">
        <div class="column col-9 col-sm-7">
          <div class="taxonomies text-left">
            

    
          </div>
        </div><!--./col-6-->
        
        </div><!--./columns-->
    </div><!--./card-footer-->
</div><!--./card-->
</div>
              <div id="sidebar" class="column col-4 col-md-12">
                <div class="sidebar-content">
                  
                  
<div class="sidebar-widget">
  <div class="tile">
    <div class="tile-icon">
      <figure class="avatar avatar-xl">
        <img src="https://ilikexff.cn/avatar.png" alt="author avatar image">
      </figure>
    </div>
    <div class="tile-content">
      <p class="tile-title" style="font-weight: 600;">慕予</p>
      <p class="tile-subtitle">热爱编程，专注于技术分享和学习</p>
    </div>
</div><!--./tile-->
</div>

                  
                  
<div class="sidebar-widget">
  欢迎来到<strong>八尺妖剑</strong>！这里分享技术文章和编程心得。
</div><!-- end text widget -->

                  

                  </div><!--./sidebar-content-->
              </div>
            </div>
            
          </section>
        </section></section>
<section class="container grid-xl">
<ul class="pagination paginator">
  
  
</ul>
</section>
</div><!-- ./page-wrapper -->

    
<div class="mobile-container">
        <div class="overlay" id="overlay">
            <div style="padding: 1rem;">
              
<a class="site-logo" href="https:&#x2F;&#x2F;ilikexff.cn">
  
  <div class="col-mx-auto">
    <figure style="margin: 8px">
      <img class="img-responsive"
           style="max-height: 45px"
           alt="frontmatter image"
           src="https://ilikexff.cn/./logo.svg">
    </figure>
  </div>
  
</a>

            </div>
            <nav class="overlay-menu">
              

<ul class="tree treemenu treemenu-root"><li class="tree-empty">
      <span class="toggler"></span>
      <a href="https://ilikexff.cn/tags">标签</a>
    </li><li class="tree-empty">
      <span class="toggler"></span>
      <a href="https://ilikexff.cn/categories">分类</a>
    </li><li class="tree-empty">
      <span class="toggler"></span>
      <a href="https://ilikexff.cn/about">关于</a>
    </li></ul>


              </nav>
        </div>
    </div>

<script type="text/javascript">
  var overlay = document.getElementById('overlay');
  var toggle = document.getElementById('toggle');

  function openOverlay(){
      // Open overlay
      if (overlay.classList.contains("open")) {
          overlay.classList.remove("open");
      }
      else {
          overlay.classList.add("open");
      }

      // Button transition
      if (toggle.classList.contains("active")) {
          toggle.classList.remove("active");
      }
      else {
          toggle.classList.add("active");
      }
    }
</script>

<section id="footer" class="bg-gray">
  <div class="container grid-xl">
    


    <div class="columns">
      
      <div class="column col-6 col-lg-12 col-mx-auto" style="text-align: center;">
        简单是效率的灵魂 | 黔ICP备2021010295号
      </div>
      
      <div class="column col-6 col-lg-12 col-mx-auto" style="text-align: center;">
        Made by <a href="https://github.com/gicrisf/">gicrisf</a> -
        <strong>Zhuia</strong>&nbsp;<a href="https://github.com/gicrisf/zhuia">source code</a>
        is licensed under <a href="http://opensource.org/licenses/mit-license.php" target="_blank">MIT</a>.
      </div>
    </div>
  </div>
</section>
</body>
</html>
